diff -udprP mutt-1.5.21/ChangeLog.nntp mutt-nntp-sidebar/ChangeLog.nntp
--- mutt-1.5.21/ChangeLog.nntp	1969-12-31 17:00:00.000000000 -0700
+++ mutt-nntp-sidebar/ChangeLog.nntp	2011-06-03 07:05:58.909622665 -0700
@@ -0,0 +1,375 @@
+* Wed Sep 16 2010 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.5.21
+
+* Thu Aug 13 2009 Vsevolod Volkov <vvv@mutt.org.ua>
+- fixed writting references in nntp_save_cache_group()
+
+* Tue Jun 15 2009 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.5.20
+
+* Tue Mar 20 2009 Vsevolod Volkov <vvv@mutt.org.ua>
+- save Date: header of recorded outgoing articles
+
+* Tue Jan  6 2009 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.5.19
+
+* Mon May 19 2008 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.5.18
+- fixed SIGSEGV when followup or forward to newsgroup
+
+* Sun Nov  4 2007 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.5.17
+
+* Tue Jul  3 2007 Vsevolod Volkov <vvv@mutt.org.ua>
+- fixed arguments of nntp_format_str()
+
+* Fri Jun 15 2007 Vsevolod Volkov <vvv@mutt.org.ua>
+- fixed error selecting news group
+
+* Tue Jun 12 2007 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.5.16
+
+* Wed Apr 11 2007 Vsevolod Volkov <vvv@mutt.org.ua>
+- fixed posting error if $smtp_url is set
+- added support of print-style sequence %R (x-comment-to)
+
+* Sun Apr  8 2007 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.5.15
+- nntp://... url changed to news://...
+- added indicator of fetching descriptions progress
+
+* Tue Feb 28 2007 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.5.14
+
+* Tue Aug 15 2006 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.5.13
+
+* Mon Jul 17 2006 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.5.12
+- fixed reading empty .newsrc
+
+* Sat Sep 17 2005 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.5.11
+
+* Sat Aug 13 2005 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.5.10
+
+* Sun Mar 13 2005 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.5.9
+
+* Sun Feb 13 2005 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.5.8
+
+* Sat Feb  5 2005 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.5.7
+- function mutt_update_list_file() moved to newsrc.c and changed algorithm
+
+* Thu Jul  8 2004 Vsevolod Volkov <vvv@mutt.org.ua>
+- fixed error in nntp_logout_all()
+
+* Sat Apr  3 2004 Vsevolod Volkov <vvv@mutt.org.ua>
+- fixed debug output in mutt_newsrc_update()
+- added optional support of LISTGROUP command
+- fixed typo in nntp_parse_xref()
+
+* Tue Feb  3 2004 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.5.6
+
+* Thu Dec 18 2003 Vsevolod Volkov <vvv@mutt.org.ua>
+- fixed compose menu
+
+* Thu Nov  6 2003 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.5.5.1
+
+* Wed Nov  5 2003 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.5.5
+- added space after newsgroup name in .newsrc file
+
+* Sun May 18 2003 Vsevolod Volkov <vvv@mutt.org.ua>
+- nntp patch: fixed SIGSEGV when posting article
+
+* Sat Mar 22 2003 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.5.4
+
+* Sat Dec 21 2002 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.5.3
+- replace safe_free calls by the FREE macro
+
+* Fri Dec  6 2002 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.5.2
+- nntp authentication can be passed after any command
+
+* Sat May  4 2002 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.5.1
+
+* Thu May  2 2002 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.3.99
+
+* Wed Mar 13 2002 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.3.28
+- fixed SIGSEGV in <get-message>, <get-parent>, <get-children>,
+  <reconstruct-thread> functions
+- fixed message about nntp reconnect
+- fixed <attach-news-message> function using browser
+- added support of Followup-To: poster
+- added %n (new articles) in group_index_format
+- posting articles without inews by default
+
+* Wed Jan 23 2002 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.3.27
+
+* Fri Jan 18 2002 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.3.26
+
+* Thu Jan  3 2002 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.3.25
+- accelerated speed of access to news->newsgroups hash (by <gul@gul.kiev.ua>)
+- added default content disposition
+
+* Mon Dec  3 2001 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.3.24
+
+* Fri Nov  9 2001 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.3.23.2
+- fixed segfault if mutt_conn_find() returns null
+
+* Wed Oct 31 2001 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.3.23.1
+- added support of LISTGROUP command
+- added support for servers with broken overview
+- disabled <flag-message> function on news server
+- fixed error storing bad authentication information
+
+* Wed Oct 10 2001 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.3.23
+- fixed typo in buffy.c
+- added substitution of %s parameter in $inews variable
+
+* Fri Aug 31 2001 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.3.22.1
+- update to 1.3.22
+
+* Thu Aug 23 2001 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.3.21
+
+* Wed Jul 25 2001 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.3.20
+- removed 'server-hook', use 'account-hook' instead
+- fixed error opening NNTP server without newsgroup using -f option
+
+* Fri Jun  8 2001 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.3.19
+
+* Sat May  5 2001 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.3.18
+- fixed typo in nntp_attempt_features()
+- changed algorithm of XGTITLE command testing
+- disabled writing of NNTP password in debug file
+- fixed reading and writing of long newsrc lines
+- changed checking of last line while reading lines from server
+- fixed possible buffer overrun in nntp_parse_newsrc_line()
+- removed checking of XHDR command
+- compare NNTP return codes without trailing space
+
+* Thu Mar 29 2001 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.3.17
+- support for 'LIST NEWSGROUPS' command to read descriptions
+
+* Fri Mar  2 2001 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.3.16
+
+* Wed Feb 14 2001 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.3.15
+
+* Sun Jan 28 2001 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.3.14
+- show number of tagged messages patch from Felix von Leitner <leitner@fefe.de>
+
+* Sun Dec 31 2000 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.3.13
+
+* Sat Dec 30 2000 Vsevolod Volkov <vvv@mutt.org.ua>
+- Fixed problem if last article in group is deleted
+
+* Fri Dec 22 2000 Vsevolod Volkov <vvv@mutt.org.ua>
+- Fixed checking of XGTITLE command on some servers
+
+* Mon Dec 18 2000 Vsevolod Volkov <vvv@mutt.org.ua>
+- Added \r in AUTHINFO commands
+
+* Mon Nov 27 2000 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.3.12
+
+* Wed Nov  1 2000 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.3.11
+- fixed error opening newsgroup from mutt started with -g or -G
+
+* Thu Oct 12 2000 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.3.10
+- hotkey 'G' (get-message) replaced with '^G'
+
+* Thu Sep 21 2000 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.3.9
+- changed delay displaying error messages from 1 to 2 seconds
+- fixed error compiling with nntp and without imap
+
+* Wed Sep  6 2000 Vsevolod Volkov <vvv@mutt.org.ua>
+- fixed catchup in index
+- fixed nntp_open_mailbox()
+
+* Sat Sep  2 2000 Vsevolod Volkov <vvv@mutt.org.ua>
+- functions <edit> and <delete-entry> disabled
+- format of news mailbox names changed to url form
+- option nntp_attempts removed
+- option reconnect_news renamed to nntp_reconnect
+- default value of nntp_poll changed from 30 to 60
+- error handling improved
+
+* Wed Aug 30 2000 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.3.8
+- new option show_only_unread
+- add newsgroup completion
+
+* Fri Aug  4 2000 Vsevolod Volkov <vvv@mutt.kiev.ua>
+- update to 1.3.7
+
+* Sat Jul 29 2000 Vsevolod Volkov <vvv@mutt.kiev.ua>
+- update to 1.3.6
+
+* Sun Jul  9 2000 Vsevolod Volkov <vvv@mutt.kiev.ua>
+- update to 1.3.5
+- authentication code update
+- fix for changing to newsgroup from mailbox with read messages
+- socket code optimization
+
+* Wed Jun 21 2000 Vsevolod Volkov <vvv@mutt.kiev.ua>
+- update to 1.3.4
+
+* Wed Jun 14 2000 Vsevolod Volkov <vvv@mutt.kiev.ua>
+- don't substitute current newsgroup with deleted new messages
+
+* Mon Jun 12 2000 Vsevolod Volkov <vvv@mutt.kiev.ua>
+- update to 1.3.3
+- fix for substitution of newsgroup after reconnection
+- fix for loading newsgroups with very long names
+- fix for loading more than 32768 newsgroups
+
+* Wed May 24 2000 Vsevolod Volkov <vvv@mutt.kiev.ua>
+- update to 1.3.2
+
+* Sat May 20 2000 Vsevolod Volkov <vvv@mutt.kiev.ua>
+- update to 1.3.1
+
+* Fri May 12 2000 Vsevolod Volkov <vvv@mutt.kiev.ua>
+- update to 1.3
+
+* Thu May 11 2000 Vsevolod Volkov <vvv@mutt.kiev.ua>
+- update to 1.2
+
+* Thu May  4 2000 Vsevolod Volkov <vvv@mutt.kiev.ua>
+- update to 1.1.14
+
+* Sun Apr 23 2000 Vsevolod Volkov <vvv@mutt.kiev.ua>
+- update to 1.1.12
+
+* Fri Apr  7 2000 Vsevolod Volkov <vvv@mutt.kiev.ua>
+- add substitution of newsgroup with new messages by default
+
+* Wed Apr  5 2000 Vsevolod Volkov <vvv@mutt.kiev.ua>
+- add attach message from newsgroup
+- add one-line help in newsreader mode
+- disable 'change-dir' command in newsgroups browser
+- add -G option
+
+* Tue Apr  4 2000 Vsevolod Volkov <vvv@mutt.kiev.ua>
+- get default newsserver name from file /etc/nntpserver
+- use case insensitive server names
+- add print-style sequence %s to $newsrc
+- add -g option
+
+* Sat Apr  1 2000 Vsevolod Volkov <vvv@mutt.kiev.ua>
+- remove 'X-FTN-Origin' header processing
+
+* Thu Mar 30 2000 Vsevolod Volkov <vvv@mutt.kiev.ua>
+- update to 1.1.11
+- update to 1.1.10
+
+* Thu Mar 23 2000 Vsevolod Volkov <vvv@mutt.kiev.ua>
+- fix mutt_select_newsserver()
+- remove 'toggle-mode' function
+- add 'change-newsgroup' function
+
+* Wed Mar 22 2000 Vsevolod Volkov <vvv@mutt.kiev.ua>
+- fix server-hook
+
+* Tue Mar 21 2000 Vsevolod Volkov <vvv@mutt.kiev.ua>
+- fix error 'bounce' function after 'post'
+- add 'forward to newsgroup' function
+
+* Mon Mar 20 2000 Vsevolod Volkov <vvv@mutt.kiev.ua>
+- 'forward' function works in newsreader mode
+- add 'post' and 'followup' functions to pager and attachment menu
+- fix active descriptions and allowed flag reload
+
+* Tue Mar 14 2000 Vsevolod Volkov <vvv@mutt.kiev.ua>
+- update to 1.1.9
+- remove deleted newsgroups from list
+
+* Mon Mar 13 2000 Vsevolod Volkov <vvv@mutt.kiev.ua>
+- update .newsrc in browser
+
+* Sun Mar 12 2000 Vsevolod Volkov <vvv@mutt.kiev.ua>
+- reload .newsrc if externally modified
+- fix active cache update
+
+* Sun Mar  5 2000 Vsevolod Volkov <vvv@mutt.kiev.ua>
+- update to 1.1.8
+
+* Sat Mar  4 2000 Vsevolod Volkov <vvv@mutt.kiev.ua>
+- patch *.update_list_file is not required
+- count lines when loading descriptions
+- remove cache of unsubscribed newsgroups
+
+* Thu Mar  2 2000 Vsevolod Volkov <vvv@mutt.kiev.ua>
+- load list of newsgroups from cache faster
+
+* Wed Mar  1 2000 Vsevolod Volkov <vvv@mutt.kiev.ua>
+- update to 1.1.7
+
+* Tue Feb 29 2000 Vsevolod Volkov <vvv@mutt.kiev.ua>
+- fix unread messages in browser
+- fix newsrc_gen_entries()
+
+* Mon Feb 28 2000 Vsevolod Volkov <vvv@mutt.kiev.ua>
+- fix mutt_newsgroup_stat()
+- fix nntp_delete_cache()
+- fix nntp_get_status()
+- fix check_children()
+- fix nntp_fetch_headers()
+
+* Fri Feb 25 2000 Vsevolod Volkov <vvv@mutt.kiev.ua>
+- update to 1.1.5
+
+* Thu Feb 24 2000 Vsevolod Volkov <vvv@mutt.kiev.ua>
+- fix updating new messages in cache
+
+* Mon Feb 21 2000 Vsevolod Volkov <vvv@mutt.kiev.ua>
+- change default cache filenames
+- fix updating new messages in cache
+
+* Fri Feb 18 2000 Vsevolod Volkov <vvv@mutt.kiev.ua>
+- fix segmentation fault in news groups browser
+
+* Tue Feb 15 2000 Vsevolod Volkov <vvv@mutt.kiev.ua>
+- update to 1.1.4
+
+* Thu Feb 10 2000 Vsevolod Volkov <vvv@mutt.kiev.ua>
+- update to 1.1.3
+
+* Sun Jan 30 2000 Vsevolod Volkov <vvv@mutt.kiev.ua>
+- add X-Comment-To editing
+- add my_hdr support for Newsgroups:, Followup-To: and X-Comment-To: headers
+- add variables $ask_followup_to and $ask_x_comment_to
+
+* Fri Jan 28 2000 Vsevolod Volkov <vvv@mutt.kiev.ua>
+- update to 1.1.2
diff -udprP mutt-1.5.21/Makefile.am mutt-nntp-sidebar/Makefile.am
--- mutt-1.5.21/Makefile.am	2011-06-03 07:06:32.512955150 -0700
+++ mutt-nntp-sidebar/Makefile.am	2011-06-03 07:05:58.939622665 -0700
@@ -58,6 +58,7 @@ EXTRA_mutt_SOURCES = account.c bcache.c
 	mutt_idna.c mutt_sasl.c mutt_socket.c mutt_ssl.c mutt_ssl_gnutls.c \
 	mutt_tunnel.c pgp.c pgpinvoke.c pgpkey.c pgplib.c pgpmicalg.c \
 	pgppacket.c pop.c pop_auth.c pop_lib.c remailer.c resize.c sha1.c \
+	nntp.c newsrc.c \
 	smime.c smtp.c utf8.c wcwidth.c \
 	bcache.h browser.h hcache.h mbyte.h mutt_idna.h remailer.h url.h
 
@@ -69,6 +70,7 @@ EXTRA_DIST = COPYRIGHT GPL OPS OPS.PGP O
 	mutt_regex.h mutt_sasl.h mutt_socket.h mutt_ssl.h mutt_tunnel.h \
 	mx.h pager.h pgp.h pop.h protos.h rfc1524.h rfc2047.h \
 	rfc2231.h rfc822.h rfc3676.h sha1.h sort.h mime.types VERSION prepare \
+	nntp.h ChangeLog.nntp \
 	_regex.h OPS.MIX README.SECURITY remailer.c remailer.h browser.h \
 	mbyte.h lib.h extlib.c pgpewrap.c smime_keys.pl pgplib.h \
 	README.SSL smime.h group.h \
diff -udprP mutt-1.5.21/Makefile.am.orig mutt-nntp-sidebar/Makefile.am.orig
--- mutt-1.5.21/Makefile.am.orig	1969-12-31 17:00:00.000000000 -0700
+++ mutt-nntp-sidebar/Makefile.am.orig	2011-06-03 07:05:58.909622665 -0700
@@ -0,0 +1,181 @@
+## Process this file with automake to produce Makefile.in
+## Use aclocal -I m4; automake --foreign
+
+AUTOMAKE_OPTIONS = 1.6 foreign
+EXTRA_PROGRAMS = mutt_dotlock pgpring pgpewrap mutt_md5
+
+if BUILD_IMAP
+IMAP_SUBDIR = imap
+IMAP_INCLUDES = -I$(top_srcdir)/imap
+endif
+
+SUBDIRS = m4 po intl doc contrib $(IMAP_SUBDIR)
+
+bin_SCRIPTS = muttbug flea @SMIMEAUX_TARGET@
+
+if BUILD_HCACHE
+HCVERSION = hcversion.h
+endif
+
+BUILT_SOURCES = keymap_defs.h patchlist.c reldate.h $(HCVERSION)
+
+bin_PROGRAMS = mutt @DOTLOCK_TARGET@ @PGPAUX_TARGET@
+mutt_SOURCES = \
+	addrbook.c alias.c attach.c base64.c browser.c buffy.c color.c \
+	crypt.c cryptglue.c \
+	commands.c complete.c compose.c copy.c curs_lib.c curs_main.c date.c \
+	edit.c enter.c flags.c init.c filter.c from.c \
+	getdomain.c group.c \
+	handler.c hash.c hdrline.c headers.c help.c hook.c keymap.c \
+	main.c mbox.c menu.c mh.c mx.c pager.c parse.c pattern.c \
+	postpone.c query.c recvattach.c recvcmd.c \
+	rfc822.c rfc1524.c rfc2047.c rfc2231.c rfc3676.c \
+	score.c send.c sendlib.c signal.c sort.c \
+	status.c system.c thread.c charset.c history.c lib.c \
+	sidebar.c \
+	muttlib.c editmsg.c mbyte.c \
+	url.c ascii.c crypt-mod.c crypt-mod.h safe_asprintf.c
+
+nodist_mutt_SOURCES = $(BUILT_SOURCES)
+
+mutt_LDADD = @MUTT_LIB_OBJECTS@ @LIBOBJS@ $(LIBIMAP) $(MUTTLIBS) \
+	$(INTLLIBS) $(LIBICONV)  $(GPGME_LIBS)
+
+mutt_DEPENDENCIES = @MUTT_LIB_OBJECTS@ @LIBOBJS@ $(LIBIMAPDEPS) \
+	$(INTLDEPS)
+
+DEFS=-DPKGDATADIR=\"$(pkgdatadir)\" -DSYSCONFDIR=\"$(sysconfdir)\" \
+	-DBINDIR=\"$(bindir)\" -DMUTTLOCALEDIR=\"$(datadir)/locale\" \
+	-DHAVE_CONFIG_H=1
+
+AM_CPPFLAGS=-I. -I$(top_srcdir) $(IMAP_INCLUDES) $(GPGME_CFLAGS) -Iintl
+
+CPPFLAGS=@CPPFLAGS@
+
+EXTRA_mutt_SOURCES = account.c bcache.c crypt-gpgme.c crypt-mod-pgp-classic.c \
+	crypt-mod-pgp-gpgme.c crypt-mod-smime-classic.c \
+	crypt-mod-smime-gpgme.c dotlock.c gnupgparse.c hcache.c md5.c \
+	mutt_idna.c mutt_sasl.c mutt_socket.c mutt_ssl.c mutt_ssl_gnutls.c \
+	mutt_tunnel.c pgp.c pgpinvoke.c pgpkey.c pgplib.c pgpmicalg.c \
+	pgppacket.c pop.c pop_auth.c pop_lib.c remailer.c resize.c sha1.c \
+	smime.c smtp.c utf8.c wcwidth.c \
+	bcache.h browser.h hcache.h mbyte.h mutt_idna.h remailer.h url.h
+
+EXTRA_DIST = COPYRIGHT GPL OPS OPS.PGP OPS.CRYPT OPS.SMIME TODO UPDATING \
+	configure account.h \
+	attach.h buffy.h charset.h copy.h crypthash.h dotlock.h functions.h gen_defs \
+	globals.h hash.h history.h init.h keymap.h mutt_crypt.h \
+	mailbox.h mapping.h md5.h mime.h mutt.h mutt_curses.h mutt_menu.h \
+	mutt_regex.h mutt_sasl.h mutt_socket.h mutt_ssl.h mutt_tunnel.h \
+	mx.h pager.h pgp.h pop.h protos.h rfc1524.h rfc2047.h \
+	rfc2231.h rfc822.h rfc3676.h sha1.h sort.h mime.types VERSION prepare \
+	_regex.h OPS.MIX README.SECURITY remailer.c remailer.h browser.h \
+	mbyte.h lib.h extlib.c pgpewrap.c smime_keys.pl pgplib.h \
+	README.SSL smime.h group.h \
+	muttbug pgppacket.h depcomp ascii.h BEWARE PATCHES patchlist.sh \
+	ChangeLog mkchangelog.sh mutt_idna.h \
+	snprintf.c regex.c crypt-gpgme.h hcachever.sh.in
+
+EXTRA_SCRIPTS = smime_keys
+
+mutt_dotlock_SOURCES = mutt_dotlock.c
+mutt_dotlock_LDADD = @LIBOBJS@
+mutt_dotlock_DEPENDENCIES = @LIBOBJS@
+
+pgpring_SOURCES = pgppubring.c pgplib.c lib.c extlib.c sha1.c md5.c pgppacket.c ascii.c
+pgpring_LDADD = @LIBOBJS@ $(INTLLIBS) 
+pgpring_DEPENDENCIES = @LIBOBJS@ $(INTLDEPS)
+
+mutt_md5_SOURCES = md5.c
+mutt_md5_CFLAGS = -DMD5UTIL
+mutt_md5_LDADD =
+
+noinst_PROGRAMS = $(MUTT_MD5)
+
+mutt_dotlock.c: dotlock.c
+	cp $(srcdir)/dotlock.c mutt_dotlock.c
+
+CLEANFILES = mutt_dotlock.c keymap_alldefs.h $(BUILT_SOURCES)
+
+DISTCLEANFILES= flea smime_keys
+
+ACLOCAL_AMFLAGS = -I m4
+
+LDADD = @LIBOBJS@ @INTLLIBS@
+
+flea:	muttbug.sh
+	cp muttbug.sh flea
+	chmod +x flea
+
+smime_keys: $(srcdir)/smime_keys.pl
+	cp $(srcdir)/smime_keys.pl smime_keys
+	chmod +x smime_keys
+
+keymap_defs.h: $(OPS) $(srcdir)/gen_defs
+	$(srcdir)/gen_defs $(OPS) > keymap_defs.h
+
+keymap_alldefs.h: $(srcdir)/OPS $(srcdir)/OPS.PGP $(srcdir)/OPS.MIX $(srcdir)/OPS.CRYPT $(srcdir)/OPS.SMIME $(srcdir)/gen_defs
+	rm -f $@
+	$(srcdir)/gen_defs $(srcdir)/OPS $(srcdir)/OPS.PGP \
+		$(srcdir)/OPS.MIX $(srcdir)/OPS.CRYPT $(srcdir)/OPS.SMIME \
+			> keymap_alldefs.h
+
+reldate.h: $(srcdir)/ChangeLog
+	echo 'const char *ReleaseDate = "'`head -n 1 $(srcdir)/ChangeLog | LC_ALL=C cut -d ' ' -f 1`'";' > reldate.h.tmp; \
+	cmp -s reldate.h.tmp reldate.h || cp reldate.h.tmp reldate.h; \
+	rm reldate.h.tmp
+
+hcversion.h: $(srcdir)/mutt.h $(srcdir)/rfc822.h hcachever.sh $(MUTT_MD5)
+	( echo '#include "config.h"'; echo '#include "mutt.h"'; ) \
+	| $(CPP) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) - | sh ./hcachever.sh hcversion.h
+
+patchlist.c: $(srcdir)/PATCHES $(srcdir)/patchlist.sh
+	$(srcdir)/patchlist.sh < $(srcdir)/PATCHES > patchlist.c
+
+install-exec-hook:
+	if test -f $(DESTDIR)$(bindir)/mutt.dotlock && test -f $(DESTDIR)$(bindir)/mutt_dotlock ; then	\
+		rm -f $(DESTDIR)$(bindir)/mutt.dotlock ;		\
+		ln -sf $(DESTDIR)$(bindir)/mutt_dotlock $(DESTDIR)$(bindir)/mutt.dotlock ; \
+	fi
+	if test -f $(DESTDIR)$(bindir)/mutt_dotlock && test x@DOTLOCK_GROUP@ != x ; then \
+		chgrp @DOTLOCK_GROUP@ $(DESTDIR)$(bindir)/mutt_dotlock && \
+		chmod @DOTLOCK_PERMISSION@ $(DESTDIR)$(bindir)/mutt_dotlock || \
+		{ echo "Can't fix mutt_dotlock's permissions!" >&2 ; exit 1 ; } \
+	fi
+
+install-data-local:
+	$(srcdir)/mkinstalldirs $(DESTDIR)$(sysconfdir)
+	$(INSTALL) -m 644 $(srcdir)/mime.types $(DESTDIR)$(sysconfdir)/mime.types.dist
+	-if [ ! -f $(DESTDIR)$(sysconfdir)/mime.types ]; then \
+		$(INSTALL) -m 644 $(srcdir)/mime.types $(DESTDIR)$(sysconfdir); \
+	fi
+
+uninstall-local:
+	for i in mime.types ; do \
+		if cmp -s $(DESTDIR)$(sysconfdir)/$$i.dist $(DESTDIR)$(sysconfdir)/$$i ; then \
+			rm $(DESTDIR)$(sysconfdir)/$$i ; \
+		fi ; \
+		rm $(DESTDIR)$(sysconfdir)/$${i}.dist ; \
+	done
+
+pclean:
+	cat /dev/null > $(top_srcdir)/PATCHES
+
+check-security:
+	(cd $(top_srcdir) && ./check_sec.sh)
+
+commit:
+	@echo "make commit is obsolete; use hg-commit"; false
+
+update-changelog:
+	(cd $(top_srcdir); \
+	sh ./mkchangelog.sh | cat  - ChangeLog > ChangeLog.$$$$ && mv ChangeLog.$$$$ ChangeLog; \
+	$${VISUAL:-vi} ChangeLog)
+
+mutt-dist:
+	(cd $(srcdir) && ./build-release )
+
+update-doc:
+	(cd doc && $(MAKE) update-doc)
+
+.PHONY: commit pclean check-security
diff -udprP mutt-1.5.21/Makefile.in mutt-nntp-sidebar/Makefile.in
--- mutt-1.5.21/Makefile.in	2010-08-25 09:31:48.000000000 -0700
+++ mutt-nntp-sidebar/Makefile.in	2011-06-03 07:05:58.942955998 -0700
@@ -375,6 +375,7 @@ EXTRA_mutt_SOURCES = account.c bcache.c
 	mutt_idna.c mutt_sasl.c mutt_socket.c mutt_ssl.c mutt_ssl_gnutls.c \
 	mutt_tunnel.c pgp.c pgpinvoke.c pgpkey.c pgplib.c pgpmicalg.c \
 	pgppacket.c pop.c pop_auth.c pop_lib.c remailer.c resize.c sha1.c \
+	nntp.c newsrc.c \
 	smime.c smtp.c utf8.c wcwidth.c \
 	bcache.h browser.h hcache.h mbyte.h mutt_idna.h remailer.h url.h
 
@@ -386,6 +387,7 @@ EXTRA_DIST = COPYRIGHT GPL OPS OPS.PGP O
 	mutt_regex.h mutt_sasl.h mutt_socket.h mutt_ssl.h mutt_tunnel.h \
 	mx.h pager.h pgp.h pop.h protos.h rfc1524.h rfc2047.h \
 	rfc2231.h rfc822.h rfc3676.h sha1.h sort.h mime.types VERSION prepare \
+	nntp.h ChangeLog.nntp \
 	_regex.h OPS.MIX README.SECURITY remailer.c remailer.h browser.h \
 	mbyte.h lib.h extlib.c pgpewrap.c smime_keys.pl pgplib.h \
 	README.SSL smime.h group.h \
@@ -640,6 +642,8 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/mutt_tunnel.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/muttlib.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/mx.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/newsrc.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/nntp.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/pager.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/parse.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/patchlist.Po@am__quote@
diff -udprP mutt-1.5.21/OPS mutt-nntp-sidebar/OPS
--- mutt-1.5.21/OPS	2011-06-03 07:06:32.512955150 -0700
+++ mutt-nntp-sidebar/OPS	2011-06-03 07:05:58.942955998 -0700
@@ -8,14 +8,16 @@ OP_BOUNCE_MESSAGE "remail a message to a
 OP_BROWSER_NEW_FILE "select a new file in this directory"
 OP_BROWSER_VIEW_FILE "view file"
 OP_BROWSER_TELL "display the currently selected file's name"
-OP_BROWSER_SUBSCRIBE "subscribe to current mailbox (IMAP only)"
-OP_BROWSER_UNSUBSCRIBE "unsubscribe from current mailbox (IMAP only)"
+OP_BROWSER_SUBSCRIBE "subscribe to current mbox (IMAP/NNTP only)"
+OP_BROWSER_UNSUBSCRIBE "unsubscribe from current mbox (IMAP/NNTP only)"
 OP_BROWSER_TOGGLE_LSUB "toggle view all/subscribed mailboxes (IMAP only)"
 OP_BUFFY_LIST "list mailboxes with new mail"
+OP_CATCHUP "mark all articles in newsgroup as read"
 OP_CHANGE_DIRECTORY "change directories"
 OP_CHECK_NEW "check mailboxes for new mail"
 OP_COMPOSE_ATTACH_FILE "attach file(s) to this message"
 OP_COMPOSE_ATTACH_MESSAGE "attach message(s) to this message"
+OP_COMPOSE_ATTACH_NEWS_MESSAGE "attach newsmessage(s) to this message"
 OP_COMPOSE_EDIT_BCC "edit the BCC list"
 OP_COMPOSE_EDIT_CC "edit the CC list"
 OP_COMPOSE_EDIT_DESCRIPTION "edit attachment description"
@@ -26,7 +28,10 @@ OP_COMPOSE_EDIT_FROM "edit the from fiel
 OP_COMPOSE_EDIT_HEADERS "edit the message with headers"
 OP_COMPOSE_EDIT_MESSAGE "edit the message"
 OP_COMPOSE_EDIT_MIME "edit attachment using mailcap entry"
+OP_COMPOSE_EDIT_NEWSGROUPS "edit the newsgroups list"
 OP_COMPOSE_EDIT_REPLY_TO "edit the Reply-To field"
+OP_COMPOSE_EDIT_FOLLOWUP_TO "edit the Followup-To field"
+OP_COMPOSE_EDIT_X_COMMENT_TO "edit the X-Comment-To field"
 OP_COMPOSE_EDIT_SUBJECT "edit the subject of this message"
 OP_COMPOSE_EDIT_TO "edit the TO list"
 OP_CREATE_MAILBOX "create a new mailbox (IMAP only)"
@@ -85,8 +90,13 @@ OP_EXIT "exit this menu"
 OP_FILTER "filter attachment through a shell command"
 OP_FIRST_ENTRY "move to the first entry"
 OP_FLAG_MESSAGE "toggle a message's 'important' flag"
+OP_FOLLOWUP "followup to newsgroup"
+OP_FORWARD_TO_GROUP "forward to newsgroup"
 OP_FORWARD_MESSAGE "forward a message with comments"
 OP_GENERIC_SELECT_ENTRY "select the current entry"
+OP_GET_CHILDREN "get all children of the current message"
+OP_GET_MESSAGE "get message with Message-Id"
+OP_GET_PARENT "get parent of the current message"
 OP_GROUP_REPLY "reply to all recipients"
 OP_HALF_DOWN "scroll down 1/2 page"
 OP_HALF_UP "scroll up 1/2 page"
@@ -94,11 +104,14 @@ OP_HELP "this screen"
 OP_JUMP "jump to an index number"
 OP_LAST_ENTRY "move to the last entry"
 OP_LIST_REPLY "reply to specified mailing list"
+OP_LOAD_ACTIVE "load active file from NNTP server"
 OP_MACRO "execute a macro"
 OP_MAIL "compose a new mail message"
 OP_MAIN_BREAK_THREAD "break the thread in two"
 OP_MAIN_CHANGE_FOLDER "open a different folder"
 OP_MAIN_CHANGE_FOLDER_READONLY "open a different folder in read only mode"
+OP_MAIN_CHANGE_GROUP "open a different newsgroup"
+OP_MAIN_CHANGE_GROUP_READONLY "open a different newsgroup in read only mode"
 OP_MAIN_CLEAR_FLAG "clear a status flag from a message"
 OP_MAIN_DELETE_PATTERN "delete messages matching a pattern"
 OP_MAIN_IMAP_FETCH "force retrieval of mail from IMAP server"
@@ -138,6 +151,7 @@ OP_PAGER_HIDE_QUOTED "toggle display of
 OP_PAGER_SKIP_QUOTED "skip beyond quoted text"
 OP_PAGER_TOP "jump to the top of the message"
 OP_PIPE "pipe message/attachment to a shell command"
+OP_POST "post message to newsgroup"
 OP_PREV_ENTRY "move to the previous entry"
 OP_PREV_LINE "scroll up one line"
 OP_PREV_PAGE "move to the previous page"
@@ -146,6 +160,7 @@ OP_QUERY "query external program for add
 OP_QUERY_APPEND "append new query results to current results"
 OP_QUIT "save changes to mailbox and quit"
 OP_RECALL_MESSAGE "recall a postponed message"
+OP_RECONSTRUCT_THREAD "reconstruct thread containing current message"
 OP_REDRAW "clear and redraw the screen"
 OP_REFORMAT_WINCH "{internal}"
 OP_RENAME_MAILBOX "rename the current mailbox (IMAP only)"
@@ -160,18 +175,22 @@ OP_SEARCH_TOGGLE "toggle search pattern
 OP_SHELL_ESCAPE "invoke a command in a subshell"
 OP_SORT "sort messages"
 OP_SORT_REVERSE "sort messages in reverse order"
+OP_SUBSCRIBE_PATTERN "subscribe to newsgroups matching a pattern"
 OP_TAG "tag the current entry"
 OP_TAG_PREFIX "apply next function to tagged messages"
 OP_TAG_PREFIX_COND "apply next function ONLY to tagged messages"
 OP_TAG_SUBTHREAD "tag the current subthread"
 OP_TAG_THREAD "tag the current thread"
 OP_TOGGLE_NEW "toggle a message's 'new' flag"
+OP_TOGGLE_READ "toggle view of read messages"
 OP_TOGGLE_WRITE "toggle whether the mailbox will be rewritten"
 OP_TOGGLE_MAILBOXES "toggle whether to browse mailboxes or all files"
 OP_TOP_PAGE "move to the top of the page"
+OP_UNCATCHUP "mark all articles in newsgroup as unread"
 OP_UNDELETE "undelete the current entry"
 OP_UNDELETE_THREAD "undelete all messages in thread"
 OP_UNDELETE_SUBTHREAD "undelete all messages in subthread"
+OP_UNSUBSCRIBE_PATTERN "unsubscribe from newsgroups matching a pattern"
 OP_VERSION "show the Mutt version number and date"
 OP_VIEW_ATTACH "view attachment using mailcap entry if necessary"
 OP_VIEW_ATTACHMENTS "show MIME attachments"
diff -udprP mutt-1.5.21/PATCHES mutt-nntp-sidebar/PATCHES
--- mutt-1.5.21/PATCHES	2011-06-03 07:06:32.512955150 -0700
+++ mutt-nntp-sidebar/PATCHES	2011-06-03 07:05:58.942955998 -0700
@@ -1 +1,2 @@
+vvv.nntp
 patch-1.5.21.sidebar.5302767aa6aa.txt
diff -udprP mutt-1.5.21/account.c mutt-nntp-sidebar/account.c
--- mutt-1.5.21/account.c	2009-08-25 12:08:52.000000000 -0700
+++ mutt-nntp-sidebar/account.c	2011-06-03 07:05:58.909622665 -0700
@@ -51,6 +51,11 @@ int mutt_account_match (const ACCOUNT* a
     user = PopUser;
 #endif
   
+#ifdef USE_NNTP
+  if (a1->type == M_ACCT_TYPE_NNTP && NntpUser)
+    user = NntpUser;
+#endif
+
   if (a1->flags & a2->flags & M_ACCT_USER)
     return (!strcmp (a1->user, a2->user));
   if (a1->flags & M_ACCT_USER)
@@ -130,6 +135,16 @@ void mutt_account_tourl (ACCOUNT* accoun
   }
 #endif
 
+#ifdef USE_NNTP
+  if (account->type == M_ACCT_TYPE_NNTP)
+  {
+    if (account->flags & M_ACCT_SSL)
+      url->scheme = U_NNTPS;
+    else
+      url->scheme = U_NNTP;
+  }
+#endif
+
   url->host = account->host;
   if (account->flags & M_ACCT_PORT)
     url->port = account->port;
@@ -155,6 +170,10 @@ int mutt_account_getuser (ACCOUNT* accou
   else if ((account->type == M_ACCT_TYPE_POP) && PopUser)
     strfcpy (account->user, PopUser, sizeof (account->user));
 #endif
+#ifdef USE_NNTP
+  else if ((account->type == M_ACCT_TYPE_NNTP) && NntpUser)
+    strfcpy (account->user, NntpUser, sizeof (account->user));
+#endif
   else if (option (OPTNOCURSES))
     return -1;
   /* prompt (defaults to unix username), copy into account->user */
@@ -217,6 +236,10 @@ int mutt_account_getpass (ACCOUNT* accou
   else if ((account->type == M_ACCT_TYPE_SMTP) && SmtpPass)
     strfcpy (account->pass, SmtpPass, sizeof (account->pass));
 #endif
+#ifdef USE_NNTP
+  else if ((account->type == M_ACCT_TYPE_NNTP) && NntpPass)
+    strfcpy (account->pass, NntpPass, sizeof (account->pass));
+#endif
   else if (option (OPTNOCURSES))
     return -1;
   else
diff -udprP mutt-1.5.21/account.h mutt-nntp-sidebar/account.h
--- mutt-1.5.21/account.h	2008-03-19 13:07:06.000000000 -0700
+++ mutt-nntp-sidebar/account.h	2011-06-03 07:05:58.942955998 -0700
@@ -29,7 +29,8 @@ enum
   M_ACCT_TYPE_NONE = 0,
   M_ACCT_TYPE_IMAP,
   M_ACCT_TYPE_POP,
-  M_ACCT_TYPE_SMTP
+  M_ACCT_TYPE_SMTP,
+  M_ACCT_TYPE_NNTP
 };
 
 /* account flags */
diff -udprP mutt-1.5.21/attach.h mutt-nntp-sidebar/attach.h
--- mutt-1.5.21/attach.h	2008-03-19 13:07:06.000000000 -0700
+++ mutt-nntp-sidebar/attach.h	2011-06-03 07:05:58.939622665 -0700
@@ -50,7 +50,7 @@ void mutt_print_attachment_list (FILE *f
 
 void mutt_attach_bounce (FILE *, HEADER *, ATTACHPTR **, short, BODY *);
 void mutt_attach_resend (FILE *, HEADER *, ATTACHPTR **, short, BODY *);
-void mutt_attach_forward (FILE *, HEADER *, ATTACHPTR **, short, BODY *);
+void mutt_attach_forward (FILE *, HEADER *, ATTACHPTR **, short, BODY *, int);
 void mutt_attach_reply (FILE *, HEADER *, ATTACHPTR **, short, BODY *, int);
 
 #endif /* _ATTACH_H_ */
diff -udprP mutt-1.5.21/browser.c mutt-nntp-sidebar/browser.c
--- mutt-1.5.21/browser.c	2010-08-25 09:31:40.000000000 -0700
+++ mutt-nntp-sidebar/browser.c	2011-06-03 07:05:58.912955998 -0700
@@ -32,6 +32,9 @@
 #ifdef USE_IMAP
 #include "imap.h"
 #endif
+#ifdef USE_NNTP
+#include "nntp.h"
+#endif
 
 #include <stdlib.h>
 #include <dirent.h>
@@ -50,6 +53,19 @@ static struct mapping_t FolderHelp[] = {
   { NULL,	 0 }
 };
 
+#ifdef USE_NNTP
+static struct mapping_t FolderNewsHelp[] = {
+  { N_("Exit"),        OP_EXIT },
+  { N_("List"),        OP_TOGGLE_MAILBOXES },
+  { N_("Subscribe"),   OP_BROWSER_SUBSCRIBE },
+  { N_("Unsubscribe"), OP_BROWSER_UNSUBSCRIBE },
+  { N_("Catchup"),     OP_CATCHUP },
+  { N_("Mask"),        OP_ENTER_MASK },
+  { N_("Help"),        OP_HELP },
+  { NULL }
+};
+#endif
+
 typedef struct folder_t
 {
   struct folder_file *ff;
@@ -115,9 +131,17 @@ static void browser_sort (struct browser
     case SORT_ORDER:
       return;
     case SORT_DATE:
+#ifdef USE_NNTP
+      if (option (OPTNEWS))
+	return;
+#endif
       f = browser_compare_date;
       break;
     case SORT_SIZE:
+#ifdef USE_NNTP
+      if (option (OPTNEWS))
+	return;
+#endif
       f = browser_compare_size;
       break;
     case SORT_SUBJECT:
@@ -324,8 +348,106 @@ folder_format_str (char *dest, size_t de
   return (src);
 }
 
+#ifdef USE_NNTP
+static const char *
+newsgroup_format_str (char *dest, size_t destlen, size_t col, char op, const char *src,
+		       const char *fmt, const char *ifstring, const char *elsestring,
+		       unsigned long data, format_flag flags)
+{
+  char fn[SHORT_STRING], tmp[SHORT_STRING];
+  FOLDER *folder = (FOLDER *) data;
+
+  switch (op)
+  {
+    case 'C':
+      snprintf (tmp, sizeof (tmp), "%%%sd", fmt);
+      snprintf (dest, destlen, tmp, folder->num + 1);
+      break;
+      
+    case 'f':
+      strncpy (fn, folder->ff->name, sizeof(fn) - 1);
+      snprintf (tmp, sizeof (tmp), "%%%ss", fmt);
+      snprintf (dest, destlen, tmp, fn);
+      break;
+
+    case 'N':
+      snprintf (tmp, sizeof (tmp), "%%%sc", fmt);
+      if (folder->ff->nd->subscribed)
+	snprintf (dest, destlen, tmp, ' ');
+      else
+	snprintf (dest, destlen, tmp, folder->ff->new ? 'N' : 'u');
+      break;
+
+    case 'M':
+      snprintf (tmp, sizeof (tmp), "%%%sc", fmt);
+      if (folder->ff->nd->deleted)
+	snprintf (dest, destlen, tmp, 'D');
+      else
+	snprintf (dest, destlen, tmp, folder->ff->nd->allowed ? ' ' : '-');
+      break;
+
+    case 's':
+      if (flags & M_FORMAT_OPTIONAL)
+      {
+	if (folder->ff->nd->unread != 0)
+	  mutt_FormatString (dest, destlen, col, ifstring, newsgroup_format_str,
+		data, flags);
+	else
+	  mutt_FormatString (dest, destlen, col, elsestring, newsgroup_format_str,
+		data, flags);
+      }
+      else if (Context && Context->data == folder->ff->nd)
+      {
+	snprintf (tmp, sizeof (tmp), "%%%sd", fmt);
+	snprintf (dest, destlen, tmp, Context->unread);
+      }
+      else
+      {
+	snprintf (tmp, sizeof (tmp), "%%%sd", fmt);
+	snprintf (dest, destlen, tmp, folder->ff->nd->unread);
+      }
+      break;
+
+    case 'n':
+      if (Context && Context->data == folder->ff->nd)
+      {
+	snprintf (tmp, sizeof (tmp), "%%%sd", fmt);
+	snprintf (dest, destlen, tmp, Context->new);
+      }
+      else if (option (OPTMARKOLD) &&
+		folder->ff->nd->lastCached >= folder->ff->nd->firstMessage &&
+		folder->ff->nd->lastCached <= folder->ff->nd->lastMessage)
+      {
+	snprintf (tmp, sizeof (tmp), "%%%sd", fmt);
+	snprintf (dest, destlen, tmp, folder->ff->nd->lastMessage - folder->ff->nd->lastCached);
+      }
+      else
+      {
+	snprintf (tmp, sizeof (tmp), "%%%sd", fmt);
+	snprintf (dest, destlen, tmp, folder->ff->nd->unread);
+      }
+      break;
+
+    case 'd':
+      if (folder->ff->nd->desc != NULL)
+      {
+	snprintf (tmp, sizeof (tmp), "%%%ss", fmt);
+	snprintf (dest, destlen, tmp, folder->ff->nd->desc);
+      }
+      else
+      {
+	snprintf (tmp, sizeof (tmp), "%%%ss", fmt);
+	snprintf (dest, destlen, tmp, "");
+      }
+      break;
+  }
+  return (src);
+}
+#endif /* USE_NNTP */
+
 static void add_folder (MUTTMENU *m, struct browser_state *state,
-			const char *name, const struct stat *s, int new)
+			const char *name, const struct stat *s,
+			void *data, int new)
 {
   if (state->entrylen == state->entrymax)
   {
@@ -354,6 +476,10 @@ static void add_folder (MUTTMENU *m, str
 #ifdef USE_IMAP
   (state->entry)[state->entrylen].imap = 0;
 #endif
+#ifdef USE_NNTP
+  if (option (OPTNEWS))
+    (state->entry)[state->entrylen].nd = (NNTP_DATA *) data;
+#endif
   (state->entrylen)++;
 }
 
@@ -369,9 +495,35 @@ static void init_state (struct browser_s
     menu->data = state->entry;
 }
 
+/* get list of all files/newsgroups with mask */
 static int examine_directory (MUTTMENU *menu, struct browser_state *state,
 			      char *d, const char *prefix)
 {
+#ifdef USE_NNTP
+  if (option (OPTNEWS))
+  {
+    LIST *tmp;
+    NNTP_DATA *data;
+    NNTP_SERVER *news = CurrentNewsSrv;
+
+/*  mutt_buffy_check (0); */
+    init_state (state, menu);
+
+    for (tmp = news->list; tmp; tmp = tmp->next)
+    {
+      if (!(data = (NNTP_DATA *)tmp->data))
+	continue;
+      if (prefix && *prefix && strncmp (prefix, data->group,
+	    strlen (prefix)) != 0)
+	continue;
+      if (!((regexec (Mask.rx, data->group, 0, NULL, 0) == 0) ^ Mask.not))
+	continue;
+      add_folder (menu, state, data->group, NULL, data, data->new);
+    }
+  }
+  else
+#endif /* USE_NNTP */
+  {
   struct stat s;
   DIR *dp;
   struct dirent *de;
@@ -432,17 +584,40 @@ static int examine_directory (MUTTMENU *
     tmp = Incoming;
     while (tmp && mutt_strcmp (buffer, tmp->path))
       tmp = tmp->next;
-    add_folder (menu, state, de->d_name, &s, (tmp) ? tmp->new : 0);
+    add_folder (menu, state, de->d_name, &s, NULL, (tmp) ? tmp->new : 0);
+  }
+  closedir (dp);
   }
-  closedir (dp);  
   browser_sort (state);
   return 0;
 }
 
+/* get list of mailboxes/subscribed newsgroups */
 static int examine_mailboxes (MUTTMENU *menu, struct browser_state *state)
 {
   struct stat s;
   char buffer[LONG_STRING];
+
+#ifdef USE_NNTP
+  if (option (OPTNEWS))
+  {
+    LIST *tmp;
+    NNTP_DATA *data;
+    NNTP_SERVER *news = CurrentNewsSrv;
+
+/*  mutt_buffy_check (0); */
+    init_state (state, menu);
+
+    for (tmp = news->list; tmp; tmp = tmp->next)
+    {
+      if ((data = (NNTP_DATA *) tmp->data) != NULL && (data->new ||
+	  (data->subscribed && (!option (OPTSHOWONLYUNREAD) || data->unread))))
+        add_folder (menu, state, data->group, NULL, data, data->new);
+    }
+  }
+  else
+#endif
+  {
   BUFFY *tmp = Incoming;
 #ifdef USE_IMAP
   struct mailbox_state mbox;
@@ -460,14 +635,21 @@ static int examine_mailboxes (MUTTMENU *
     if (mx_is_imap (tmp->path))
     {
       imap_mailbox_state (tmp->path, &mbox);
-      add_folder (menu, state, tmp->path, NULL, mbox.new);
+      add_folder (menu, state, tmp->path, NULL, NULL, mbox.new);
       continue;
     }
 #endif
 #ifdef USE_POP
     if (mx_is_pop (tmp->path))
     {
-      add_folder (menu, state, tmp->path, NULL, tmp->new);
+      add_folder (menu, state, tmp->path, NULL, NULL, tmp->new);
+      continue;
+    }
+#endif
+#ifdef USE_NNTP
+    if (mx_is_nntp (tmp->path))
+    {
+      add_folder (menu, state, tmp->path, NULL, NULL, tmp->new);
       continue;
     }
 #endif
@@ -496,15 +678,20 @@ static int examine_mailboxes (MUTTMENU *
     strfcpy (buffer, NONULL(tmp->path), sizeof (buffer));
     mutt_pretty_mailbox (buffer, sizeof (buffer));
 
-    add_folder (menu, state, buffer, &s, tmp->new);
+    add_folder (menu, state, buffer, &s, NULL, tmp->new);
   }
   while ((tmp = tmp->next));
+  }
   browser_sort (state);
   return 0;
 }
 
 static int select_file_search (MUTTMENU *menu, regex_t *re, int n)
 {
+#ifdef USE_NNTP
+  if (option (OPTNEWS))
+    return (regexec (re, ((struct folder_file *) menu->data)[n].desc, 0, NULL, 0));
+#endif
   return (regexec (re, ((struct folder_file *) menu->data)[n].name, 0, NULL, 0));
 }
 
@@ -515,6 +702,12 @@ static void folder_entry (char *s, size_
   folder.ff = &((struct folder_file *) menu->data)[num];
   folder.num = num;
   
+#ifdef USE_NNTP
+  if (option (OPTNEWS))
+    mutt_FormatString (s, slen, 0, NONULL(GroupFormat), newsgroup_format_str, 
+      (unsigned long) &folder, M_FORMAT_ARROWCURSOR);
+  else
+#endif
   mutt_FormatString (s, slen, 0, NONULL(FolderFormat), folder_format_str, 
       (unsigned long) &folder, M_FORMAT_ARROWCURSOR);
 }
@@ -535,6 +728,17 @@ static void init_menu (struct browser_st
 
   menu->tagged = 0;
   
+#ifdef USE_NNTP
+  if (option (OPTNEWS))
+  {
+    if (buffy)
+      snprintf (title, titlelen, _("Subscribed newsgroups"));
+    else
+      snprintf (title, titlelen, _("Newsgroups on server [%s]"),
+		CurrentNewsSrv->conn->account.host);
+  }
+  else
+#endif
   if (buffy)
     snprintf (title, titlelen, _("Mailboxes [%d]"), mutt_buffy_check (0));
   else
@@ -590,6 +794,31 @@ void _mutt_select_file (char *f, size_t
   if (!folder)
     strfcpy (LastDirBackup, LastDir, sizeof (LastDirBackup));
 
+#ifdef USE_NNTP
+  if (option (OPTNEWS))
+  {
+    if (*f)
+      strfcpy (prefix, f, sizeof (prefix));
+    else
+    {
+      LIST *list;
+
+      /* default state for news reader mode is browse subscribed newsgroups */
+      buffy = 0;
+      for (list = CurrentNewsSrv->list; list; list = list->next)
+      {
+	NNTP_DATA *data = (NNTP_DATA *) list->data;
+
+	if (data && data->subscribed)
+	{
+	  buffy = 1;
+	  break;
+	}
+      }
+    }
+  }
+  else
+#endif
   if (*f)
   {
     mutt_expand_path (f, flen);
@@ -686,6 +915,9 @@ void _mutt_select_file (char *f, size_t
     menu->tag = file_tag;
 
   menu->help = mutt_compile_help (helpstr, sizeof (helpstr), MENU_FOLDER,
+#ifdef USE_NNTP
+    (option (OPTNEWS)) ? FolderNewsHelp :
+#endif
     FolderHelp);
 
   init_menu (&state, menu, title, sizeof (title), buffy);
@@ -824,7 +1056,11 @@ void _mutt_select_file (char *f, size_t
 	  }
 	}
 
+#ifdef USE_NNTP
+	if (buffy || option (OPTNEWS)) /* news have not path */
+#else
 	if (buffy)
+#endif
 	{
 	  strfcpy (f, state.entry[menu->current].name, flen);
 	  mutt_expand_path (f, flen);
@@ -882,14 +1118,6 @@ void _mutt_select_file (char *f, size_t
         break;
 
 #ifdef USE_IMAP
-      case OP_BROWSER_SUBSCRIBE:
-	imap_subscribe (state.entry[menu->current].name, 1);
-	break;
-
-      case OP_BROWSER_UNSUBSCRIBE:
-	imap_subscribe (state.entry[menu->current].name, 0);
-	break;
-
       case OP_BROWSER_TOGGLE_LSUB:
 	if (option (OPTIMAPLSUB))
 	  unset_option (OPTIMAPLSUB);
@@ -990,6 +1218,11 @@ void _mutt_select_file (char *f, size_t
       
       case OP_CHANGE_DIRECTORY:
 
+#ifdef USE_NNTP
+	if (option (OPTNEWS))
+	  break;
+#endif
+
 	strfcpy (buf, LastDir, sizeof (buf));
 #ifdef USE_IMAP
 	if (!state.imap_browse)
@@ -1255,6 +1488,190 @@ void _mutt_select_file (char *f, size_t
 	  else
 	    mutt_error _("Error trying to view file");
 	}
+	break;
+
+#ifdef USE_NNTP
+      case OP_CATCHUP:
+      case OP_UNCATCHUP:
+	if (option (OPTNEWS))
+	{
+	  struct folder_file *f = &state.entry[menu->current];
+	  NNTP_DATA *nd;
+
+	  if (i == OP_CATCHUP)
+	    nd = mutt_newsgroup_catchup (CurrentNewsSrv, f->name);
+	  else
+	    nd = mutt_newsgroup_uncatchup (CurrentNewsSrv, f->name);
+
+	  if (nd)
+	  {
+/*	    FOLDER folder;
+	    struct folder_file ff;
+	    char buffer[_POSIX_PATH_MAX + SHORT_STRING];
+
+	    folder.ff = &ff;
+	    folder.ff->name = f->name;
+	    folder.ff->st = NULL;
+	    folder.ff->is_new = nd->new;
+	    folder.ff->nd = nd;
+	    FREE (&f->desc);
+	    mutt_FormatString (buffer, sizeof (buffer), 0, NONULL(GroupFormat),
+		  newsgroup_format_str, (unsigned long) &folder,
+		  M_FORMAT_ARROWCURSOR);
+	    f->desc = safe_strdup (buffer); */
+	    if (menu->current + 1 < menu->max)
+	      menu->current++;
+	    menu->redraw = REDRAW_MOTION_RESYNCH;
+	  }
+	}
+	break;
+
+      case OP_LOAD_ACTIVE:
+	if (!option (OPTNEWS))
+	  break;
+
+	{
+	  LIST *tmp;
+	  NNTP_DATA *data;
+
+	  for (tmp = CurrentNewsSrv->list; tmp; tmp = tmp->next)
+	  {
+	    if ((data = (NNTP_DATA *)tmp->data))
+	      data->deleted = 1;
+	  }
+	}
+	nntp_get_active (CurrentNewsSrv);
+
+	destroy_state (&state);
+	if (buffy)
+	  examine_mailboxes (menu, &state);
+	else
+	  examine_directory (menu, &state, NULL, NULL);
+	init_menu (&state, menu, title, sizeof (title), buffy);
+	break;
+#endif /* USE_NNTP */
+
+#if defined USE_IMAP || defined USE_NNTP
+      case OP_BROWSER_SUBSCRIBE:
+      case OP_BROWSER_UNSUBSCRIBE:
+#endif
+#ifdef USE_NNTP
+      case OP_SUBSCRIBE_PATTERN:
+      case OP_UNSUBSCRIBE_PATTERN:
+        if (option (OPTNEWS))
+	{
+	  regex_t *rx = (regex_t *) safe_malloc (sizeof (regex_t));
+	  char *s = buf;
+	  int j = menu->current;
+	  NNTP_DATA *nd;
+	  NNTP_SERVER *news = CurrentNewsSrv;
+
+	  if (i == OP_SUBSCRIBE_PATTERN || i == OP_UNSUBSCRIBE_PATTERN)
+	  {
+	    char tmp[STRING];
+	    int err;
+
+	    buf[0] = 0;
+	    if (i == OP_SUBSCRIBE_PATTERN)
+	      snprintf (tmp, sizeof (tmp), _("Subscribe pattern: "));
+	    else
+	      snprintf (tmp, sizeof (tmp), _("Unsubscribe pattern: "));
+	    if (mutt_get_field (tmp, buf, sizeof (buf), 0) != 0 || !buf[0])
+	    {
+	      FREE (&rx);
+	      break;
+	    }
+
+	    if ((err = REGCOMP (rx, s, REG_NOSUB)) != 0)
+	    {
+	      regerror (err, rx, buf, sizeof (buf));
+	      regfree (rx);
+	      FREE (&rx);
+	      mutt_error ("%s", buf);
+	      break;
+	    }
+	    menu->redraw = REDRAW_FULL;
+	    j = 0;
+	  }
+	  else if (!state.entrylen)
+	  {
+	    mutt_error _("No newsgroups match the mask");
+	    break;
+	  }
+
+	  for ( ; j < state.entrylen; j++)
+	  {
+	    struct folder_file *f = &state.entry[j];
+
+	    if (i == OP_BROWSER_SUBSCRIBE || i == OP_BROWSER_UNSUBSCRIBE ||
+		  regexec (rx, f->name, 0, NULL, 0) == 0)
+	    {
+	      if (i == OP_BROWSER_SUBSCRIBE || i == OP_SUBSCRIBE_PATTERN)
+		nd = mutt_newsgroup_subscribe (news, f->name);
+	      else
+		nd = mutt_newsgroup_unsubscribe (news, f->name);
+/*	      if (nd)
+	      {
+		FOLDER folder;
+		char buffer[_POSIX_PATH_MAX + SHORT_STRING];
+
+		folder.name = f->name;
+		folder.f = NULL;
+		folder.new = nd->new;
+		folder.nd = nd;
+		FREE (&f->desc);
+		mutt_FormatString (buffer, sizeof (buffer), 0, NONULL(GroupFormat),
+			newsgroup_format_str, (unsigned long) &folder,
+			M_FORMAT_ARROWCURSOR);
+		f->desc = safe_strdup (buffer);
+	      } */
+	    }
+	    if (i == OP_BROWSER_SUBSCRIBE || i == OP_BROWSER_UNSUBSCRIBE)
+	    {
+	      if (menu->current + 1 < menu->max)
+		menu->current++;
+	      menu->redraw = REDRAW_MOTION_RESYNCH;
+	      break;
+	    }
+	  }
+	  if (i == OP_SUBSCRIBE_PATTERN)
+	  {
+	    LIST *grouplist = NULL;
+
+	    if (news)
+	      grouplist = news->list;
+	    for (; grouplist; grouplist = grouplist->next)
+	    {
+	      nd = (NNTP_DATA *) grouplist->data;
+	      if (nd && nd->group && !nd->subscribed)
+	      {
+		if (regexec (rx, nd->group, 0, NULL, 0) == 0)
+		{
+		  mutt_newsgroup_subscribe (news, nd->group);
+		  add_folder (menu, &state, nd->group, NULL, nd, nd->new);
+		}
+	      }
+	    }
+	    init_menu (&state, menu, title, sizeof (title), buffy);
+	  }
+	  mutt_newsrc_update (news);
+	  nntp_clear_cacheindex (news);
+	  if (i != OP_BROWSER_SUBSCRIBE && i != OP_BROWSER_UNSUBSCRIBE)
+	    regfree (rx);
+	  FREE (&rx);
+	}
+#ifdef USE_IMAP
+	else
+#endif /* USE_IMAP && USE_NNTP */
+#endif /* USE_NNTP */
+#ifdef USE_IMAP
+	{
+	  if (i == OP_BROWSER_SUBSCRIBE)
+	    imap_subscribe (state.entry[menu->current].name, 1);
+	  else
+	    imap_subscribe (state.entry[menu->current].name, 0);
+	}
+#endif /* USE_IMAP */
     }
   }
   
diff -udprP mutt-1.5.21/browser.h mutt-nntp-sidebar/browser.h
--- mutt-1.5.21/browser.h	2009-01-05 12:20:53.000000000 -0700
+++ mutt-nntp-sidebar/browser.h	2011-06-03 07:05:58.942955998 -0700
@@ -19,6 +19,10 @@
 #ifndef _BROWSER_H
 #define _BROWSER_H 1
 
+#ifdef USE_NNTP
+#include "nntp.h"
+#endif
+
 struct folder_file
 {
   mode_t mode;
@@ -37,6 +41,9 @@ struct folder_file
   unsigned selectable : 1;
   unsigned inferiors : 1;
 #endif
+#ifdef USE_NNTP
+  NNTP_DATA *nd;
+#endif
   unsigned tagged : 1;
 };
 
diff -udprP mutt-1.5.21/buffy.c mutt-nntp-sidebar/buffy.c
--- mutt-1.5.21/buffy.c	2011-06-03 07:06:32.512955150 -0700
+++ mutt-nntp-sidebar/buffy.c	2011-06-03 07:05:58.939622665 -0700
@@ -481,6 +481,9 @@ int mutt_buffy_check (int force)
 
   /* check device ID and serial number instead of comparing paths */
   if (!Context || Context->magic == M_IMAP || Context->magic == M_POP
+#ifdef USE_NNTP
+      || Context->magic == M_NNTP
+#endif
       || stat (Context->path, &contex_sb) != 0)
   {
     contex_sb.st_dev=0;
@@ -497,6 +500,11 @@ int mutt_buffy_check (int force)
 	tmp->magic = M_POP;
       else
 #endif
+#ifdef USE_NNTP
+      if ((tmp->magic == M_NNTP) || mx_is_nntp (tmp->path))
+	tmp->magic = M_NNTP;
+      else
+#endif
       if (stat (tmp->path, &sb) != 0 || (S_ISREG(sb.st_mode) && sb.st_size == 0) ||
 	  (!tmp->magic && (tmp->magic = mx_get_magic (tmp->path)) <= 0))
       {
@@ -512,8 +520,11 @@ int mutt_buffy_check (int force)
     /* check to see if the folder is the currently selected folder
      * before polling */
     if (!Context || !Context->path ||
-	(( tmp->magic == M_IMAP || tmp->magic == M_POP )
-	    ? mutt_strcmp (tmp->path, Context->path) :
+	(( tmp->magic == M_IMAP || tmp->magic == M_POP
+#ifdef USE_NNTP
+	    || tmp->magic == M_NNTP
+#endif
+	    ) ? mutt_strcmp (tmp->path, Context->path) :
 	      (sb.st_dev != contex_sb.st_dev || sb.st_ino != contex_sb.st_ino)))
     {
       switch (tmp->magic)
diff -udprP mutt-1.5.21/buffy.c.orig mutt-nntp-sidebar/buffy.c.orig
--- mutt-1.5.21/buffy.c.orig	2010-09-13 10:19:55.000000000 -0700
+++ mutt-nntp-sidebar/buffy.c.orig	2011-06-03 07:05:58.916289332 -0700
@@ -340,6 +340,68 @@ static int buffy_maildir_hasnew (BUFFY*
   return rc;
 }
 
+/* update message counts for the sidebar */
+void buffy_maildir_update (BUFFY* mailbox)
+{
+  char path[_POSIX_PATH_MAX];
+  DIR *dirp;
+  struct dirent *de;
+  char *p;
+
+  mailbox->msgcount = 0;
+  mailbox->msg_unread = 0;
+  mailbox->msg_flagged = 0;
+
+  snprintf (path, sizeof (path), "%s/new", mailbox->path);
+        
+  if ((dirp = opendir (path)) == NULL)
+  {   
+    mailbox->magic = 0;
+    return;
+  } 
+      
+  while ((de = readdir (dirp)) != NULL)
+  {
+    if (*de->d_name == '.')
+      continue;
+
+    if (!(p = strstr (de->d_name, ":2,")) || !strchr (p + 3, 'T')) {
+      mailbox->new = 1;
+      mailbox->msgcount++;
+      mailbox->msg_unread++;
+    }
+  }
+
+  closedir (dirp);
+  snprintf (path, sizeof (path), "%s/cur", mailbox->path);
+        
+  if ((dirp = opendir (path)) == NULL)
+  {   
+    mailbox->magic = 0;
+    return;
+  } 
+      
+  while ((de = readdir (dirp)) != NULL)
+  {
+    if (*de->d_name == '.')
+      continue;
+
+    if (!(p = strstr (de->d_name, ":2,")) || !strchr (p + 3, 'T')) {
+      mailbox->msgcount++;
+      if ((p = strstr (de->d_name, ":2,"))) {
+        if (!strchr (p + 3, 'T')) {
+          if (!strchr (p + 3, 'S'))
+            mailbox->msg_unread++;
+          if (strchr(p + 3, 'F'))
+            mailbox->msg_flagged++;
+        }
+      }
+    }
+  }
+
+  closedir (dirp);
+}
+
 /* returns 1 if mailbox has new mail */ 
 static int buffy_mbox_hasnew (BUFFY* mailbox, struct stat *sb)
 {
@@ -371,6 +433,20 @@ static int buffy_mbox_hasnew (BUFFY* mai
   return rc;
 }
 
+/* update message counts for the sidebar */
+void buffy_mbox_update (BUFFY* mailbox)
+{
+  CONTEXT *ctx = NULL;
+
+  ctx = mx_open_mailbox(mailbox->path, M_READONLY | M_QUIET | M_NOSORT | M_PEEK, NULL);
+  if(ctx)
+  {
+    mailbox->msgcount = ctx->msgcount;
+    mailbox->msg_unread = ctx->unread;
+    mx_close_mailbox(ctx, 0);
+  }
+}
+
 int mutt_buffy_check (int force)
 {
   BUFFY *tmp;
@@ -444,16 +520,19 @@ int mutt_buffy_check (int force)
       {
       case M_MBOX:
       case M_MMDF:
+	buffy_mbox_update (tmp);
 	if (buffy_mbox_hasnew (tmp, &sb) > 0)
 	  BuffyCount++;
 	break;
 
       case M_MAILDIR:
+	buffy_maildir_update (tmp);
 	if (buffy_maildir_hasnew (tmp) > 0)
 	  BuffyCount++;
 	break;
 
       case M_MH:
+	mh_buffy_update (tmp->path, &tmp->msgcount, &tmp->msg_unread, &tmp->msg_flagged);
 	if ((tmp->new = mh_buffy (tmp->path)) > 0)
 	  BuffyCount++;
 	break;
diff -udprP mutt-1.5.21/complete.c mutt-nntp-sidebar/complete.c
--- mutt-1.5.21/complete.c	2009-01-05 12:20:53.000000000 -0700
+++ mutt-nntp-sidebar/complete.c	2011-06-03 07:05:58.929622666 -0700
@@ -25,6 +25,9 @@
 #include "mailbox.h"
 #include "imap.h"
 #endif
+#ifdef USE_NNTP
+#include "nntp.h"
+#endif
 
 #include <dirent.h>
 #include <string.h>
@@ -48,9 +51,71 @@ int mutt_complete (char *s, size_t slen)
   char filepart[_POSIX_PATH_MAX];
 #ifdef USE_IMAP
   char imap_path[LONG_STRING];
+#endif
 
   dprint (2, (debugfile, "mutt_complete: completing %s\n", s));
 
+#ifdef USE_NNTP
+  if (option (OPTNEWS))
+  {
+    LIST *l = CurrentNewsSrv->list;
+
+    strfcpy (filepart, s, sizeof (filepart));
+
+    /*
+     * special case to handle when there is no filepart yet.
+     * find the first subscribed newsgroup
+     */
+    if ((len = mutt_strlen (filepart)) == 0)
+    {
+      for (; l; l = l->next)
+      {
+	NNTP_DATA *data = (NNTP_DATA *)l->data;
+
+	if (data && data->subscribed)
+	{
+	  strfcpy (filepart, data->group, sizeof (filepart));
+	  init++;
+	  l = l->next;
+	  break;
+	}
+      }
+    }
+
+    for (; l; l = l->next)
+    {
+      NNTP_DATA *data = (NNTP_DATA *)l->data;
+
+      if (data && data->subscribed &&
+	  mutt_strncmp (data->group, filepart, len) == 0)
+      {
+	if (init)
+	{
+	  for (i = 0; filepart[i] && data->group[i]; i++)
+	  {
+	    if (filepart[i] != data->group[i])
+	    {
+	      filepart[i] = 0;
+	      break;
+	    }
+	  }
+	  filepart[i] = 0;
+	}
+	else
+	{
+	  strfcpy (filepart, data->group, sizeof (filepart));
+	  init = 1;
+	}
+      }
+    }
+
+    strcpy (s, filepart);
+
+    return (init ? 0 : -1);
+  }
+#endif
+
+#ifdef USE_IMAP
   /* we can use '/' as a delimiter, imap_complete rewrites it */
   if (*s == '=' || *s == '+' || *s == '!')
   {
diff -udprP mutt-1.5.21/compose.c mutt-nntp-sidebar/compose.c
--- mutt-1.5.21/compose.c	2011-06-03 07:06:32.516288483 -0700
+++ mutt-nntp-sidebar/compose.c	2011-06-03 07:05:58.909622665 -0700
@@ -32,10 +32,15 @@
 #include "mailbox.h"
 #include "sort.h"
 #include "charset.h"
+#include "mx.h"
 
 #ifdef MIXMASTER
 #include "remailer.h"
 #endif
+  
+#ifdef USE_NNTP
+#include "nntp.h"
+#endif
 
 #include <errno.h>
 #include <string.h>
@@ -60,18 +65,20 @@ enum
   HDR_REPLYTO,
   HDR_FCC,
 
-#ifdef MIXMASTER
-  HDR_MIX,
-#endif
-
   HDR_CRYPT,
   HDR_CRYPTINFO,
 
+#ifdef USE_NNTP
+  HDR_NEWSGROUPS,
+  HDR_FOLLOWUPTO,
+  HDR_XCOMMENTTO,
+#endif
+
   HDR_ATTACH  = (HDR_FCC + 5) /* where to start printing the attachments */
 };
 
-#define HDR_XOFFSET 10
-#define TITLE_FMT "%10s" /* Used for Prompts, which are ASCII */
+#define HDR_XOFFSET 14
+#define TITLE_FMT "%14s" /* Used for Prompts, which are ASCII */
 #define W (COLS - HDR_XOFFSET - SidebarWidth)
 
 static char *Prompts[] =
@@ -83,6 +90,16 @@ static char *Prompts[] =
   "Subject: ",
   "Reply-To: ",
   "Fcc: "
+#ifdef USE_NNTP
+#ifdef MIXMASTER
+  ,""
+#endif
+  ,""
+  ,""
+  ,"Newsgroups: "
+  ,"Followup-To: "
+  ,"X-Comment-To: "
+#endif
 };
 
 static struct mapping_t ComposeHelp[] = {
@@ -97,6 +114,19 @@ static struct mapping_t ComposeHelp[] =
   { NULL,	0 }
 };
 
+#ifdef USE_NNTP
+static struct mapping_t ComposeNewsHelp[] = {
+  { N_("Send"),    OP_COMPOSE_SEND_MESSAGE },
+  { N_("Abort"),   OP_EXIT },
+  { "Newsgroups",  OP_COMPOSE_EDIT_NEWSGROUPS },
+  { "Subj",        OP_COMPOSE_EDIT_SUBJECT },
+  { N_("Attach file"),  OP_COMPOSE_ATTACH_FILE },
+  { N_("Descrip"), OP_COMPOSE_EDIT_DESCRIPTION },
+  { N_("Help"),    OP_HELP },
+  { NULL }
+};
+#endif
+
 static void snd_entry (char *b, size_t blen, MUTTMENU *menu, int num)
 {
     mutt_FormatString (b, blen, 0, NONULL (AttachFormat), mutt_attach_fmt,
@@ -112,7 +142,7 @@ static void redraw_crypt_lines (HEADER *
 {
   int off = 0;
 
-  mvaddstr (HDR_CRYPT, SidebarWidth, "Security: ");
+  mvprintw (HDR_CRYPT, SidebarWidth, TITLE_FMT, "Security: ");
 
   if ((WithCrypto & (APPLICATION_PGP | APPLICATION_SMIME)) == 0)
   {
@@ -148,12 +178,15 @@ static void redraw_crypt_lines (HEADER *
   clrtoeol ();
 
   if ((WithCrypto & APPLICATION_PGP)
-      && msg->security & APPLICATION_PGP  && msg->security & SIGN)
-    printw ("%s%s", _(" sign as: "), PgpSignAs ? PgpSignAs : _("<default>"));
+      && msg->security & APPLICATION_PGP  && msg->security & SIGN) {
+    printw (TITLE_FMT, _(" sign as: "));
+    printw ("%s", PgpSignAs ? PgpSignAs : _("<default>"));
+  }
 
   if ((WithCrypto & APPLICATION_SMIME)
       && msg->security & APPLICATION_SMIME  && msg->security & SIGN) {
-      printw ("%s%s", _(" sign as: "), SmimeDefaultKey ? SmimeDefaultKey : _("<default>"));
+    printw (TITLE_FMT, _(" sign as: "));
+    printw ("%s", SmimeDefaultKey ? SmimeDefaultKey : _("<default>"));
   }
 
   if ((WithCrypto & APPLICATION_SMIME)
@@ -175,7 +208,7 @@ static void redraw_mix_line (LIST *chain
   int c;
   char *t;
 
-  mvaddstr (HDR_MIX, SidebarWidth,     "     Mix: ");
+  mvprintw (HDR_MIX, SidebarWidth, TITLE_FMT, "Mix: ");
 
   if (!chain)
   {
@@ -249,9 +282,28 @@ static void draw_envelope_addr (int line
 static void draw_envelope (HEADER *msg, char *fcc)
 {
   draw_envelope_addr (HDR_FROM, msg->env->from);
+#ifdef USE_NNTP
+  if (!option (OPTNEWSSEND))
+  {
+#endif
   draw_envelope_addr (HDR_TO, msg->env->to);
   draw_envelope_addr (HDR_CC, msg->env->cc);
   draw_envelope_addr (HDR_BCC, msg->env->bcc);
+#ifdef USE_NNTP
+  }
+  else
+  {
+    mvprintw (HDR_TO, SidebarWidth, TITLE_FMT , Prompts[HDR_NEWSGROUPS - 1]);
+    mutt_paddstr (W, NONULL (msg->env->newsgroups));
+    mvprintw (HDR_CC, SidebarWidth, TITLE_FMT , Prompts[HDR_FOLLOWUPTO - 1]);
+    mutt_paddstr (W, NONULL (msg->env->followup_to));
+    if (option (OPTXCOMMENTTO))
+    {
+      mvprintw (HDR_BCC, SidebarWidth, TITLE_FMT , Prompts[HDR_XCOMMENTTO - 1]);
+      mutt_paddstr (W, NONULL (msg->env->x_comment_to));
+    }
+  }
+#endif
   mvprintw (HDR_SUBJECT, SidebarWidth, TITLE_FMT, Prompts[HDR_SUBJECT - 1]);
   mutt_paddstr (W, NONULL (msg->env->subject));
   draw_envelope_addr (HDR_REPLYTO, msg->env->reply_to);
@@ -504,6 +556,12 @@ int mutt_compose_menu (HEADER *msg,   /*
   /* Sort, SortAux could be changed in mutt_index_menu() */
   int oldSort, oldSortAux;
   struct stat st;
+#ifdef USE_NNTP
+  int news = 0;               /* is it a news article ? */
+
+  if (option (OPTNEWSSEND))
+    news++;
+#endif
 
   mutt_attach_init (msg->content);
   idx = mutt_gen_attach_list (msg->content, -1, idx, &idxlen, &idxmax, 0, 1);
@@ -514,10 +572,18 @@ int mutt_compose_menu (HEADER *msg,   /*
   menu->make_entry = snd_entry;
   menu->tag = mutt_tag_attach;
   menu->data = idx;
+#ifdef USE_NNTP
+  if (news)
+  menu->help = mutt_compile_help (helpstr, sizeof (helpstr), MENU_COMPOSE, ComposeNewsHelp);
+  else
+#endif
   menu->help = mutt_compile_help (helpstr, sizeof (helpstr), MENU_COMPOSE, ComposeHelp);
   
   while (loop)
   {
+#ifdef USE_NNTP
+    unset_option (OPTNEWS);	/* for any case */
+#endif
     switch (op = mutt_menuLoop (menu))
     {
       case OP_REDRAW:
@@ -530,17 +596,87 @@ int mutt_compose_menu (HEADER *msg,   /*
         mutt_message_hook (NULL, msg, M_SEND2HOOK);
 	break;
       case OP_COMPOSE_EDIT_TO:
+#ifdef USE_NNTP
+	if (news)
+	  break;
+#endif
 	menu->redraw = edit_address_list (HDR_TO, &msg->env->to);
         mutt_message_hook (NULL, msg, M_SEND2HOOK);
         break;
       case OP_COMPOSE_EDIT_BCC:
+#ifdef USE_NNTP
+	if (news)
+	  break;
+#endif
 	menu->redraw = edit_address_list (HDR_BCC, &msg->env->bcc);
         mutt_message_hook (NULL, msg, M_SEND2HOOK);
 	break;
       case OP_COMPOSE_EDIT_CC:
+#ifdef USE_NNTP
+	if (news)
+	  break;
+#endif
 	menu->redraw = edit_address_list (HDR_CC, &msg->env->cc);
         mutt_message_hook (NULL, msg, M_SEND2HOOK);	
         break;
+#ifdef USE_NNTP
+      case OP_COMPOSE_EDIT_NEWSGROUPS:
+	if (news)
+	{
+	  if (msg->env->newsgroups)
+	    strfcpy (buf, msg->env->newsgroups, sizeof (buf));
+	  else
+	    buf[0] = 0;
+	  if (mutt_get_field ("Newsgroups: ", buf, sizeof (buf), 0) == 0 && buf[0])
+	  {
+	    FREE (&msg->env->newsgroups);
+	    mutt_remove_trailing_ws (buf);
+	    msg->env->newsgroups = safe_strdup (mutt_skip_whitespace (buf));
+	    move (HDR_TO, HDR_XOFFSET);
+	    clrtoeol ();
+	    if (msg->env->newsgroups)
+	      printw ("%-*.*s", W, W, msg->env->newsgroups);
+	  }
+	}
+	break;
+
+      case OP_COMPOSE_EDIT_FOLLOWUP_TO:
+	if (news)
+	{
+	  buf[0] = 0;
+	  if (msg->env->followup_to)
+	    strfcpy (buf, msg->env->followup_to, sizeof (buf));
+	  if (mutt_get_field ("Followup-To: ", buf, sizeof (buf), 0) == 0 && buf[0])
+	  {
+	    FREE (&msg->env->followup_to);
+	    mutt_remove_trailing_ws (buf);
+	    msg->env->followup_to = safe_strdup (mutt_skip_whitespace (buf));
+	    move (HDR_CC, HDR_XOFFSET);
+	    clrtoeol();
+	    if (msg->env->followup_to)
+	      printw ("%-*.*s", W, W, msg->env->followup_to);
+	  }
+	}
+  	break;
+
+      case OP_COMPOSE_EDIT_X_COMMENT_TO:
+	if (news && option (OPTXCOMMENTTO))
+	{
+	  buf[0] = 0;
+	  if (msg->env->x_comment_to)
+	    strfcpy (buf, msg->env->x_comment_to, sizeof (buf));
+	  if (mutt_get_field ("X-Comment-To: ", buf, sizeof (buf), 0) == 0 && buf[0])
+	  {
+	    FREE (&msg->env->x_comment_to);
+	    msg->env->x_comment_to = safe_strdup (buf);
+	    move (HDR_BCC, HDR_XOFFSET);
+	    clrtoeol();
+	    if (msg->env->x_comment_to)
+	      printw ("%-*.*s", W, W, msg->env->x_comment_to);
+	  }
+	}
+	break;
+#endif
       case OP_COMPOSE_EDIT_SUBJECT:
 	if (msg->env->subject)
 	  strfcpy (buf, msg->env->subject, sizeof (buf));
@@ -703,6 +839,9 @@ int mutt_compose_menu (HEADER *msg,   /*
         break;
 
       case OP_COMPOSE_ATTACH_MESSAGE:
+#ifdef USE_NNTP
+      case OP_COMPOSE_ATTACH_NEWS_MESSAGE:
+#endif
 	{
 	  char *prompt;
 	  HEADER *h;
@@ -710,7 +849,22 @@ int mutt_compose_menu (HEADER *msg,   /*
 	  fname[0] = 0;
 	  prompt = _("Open mailbox to attach message from");
 
+#ifdef USE_NNTP
+	  unset_option (OPTNEWS);
+	  if (op == OP_COMPOSE_ATTACH_NEWS_MESSAGE)
+	  {
+	    if (!(CurrentNewsSrv = mutt_select_newsserver (NewsServer)))
+	      break;
+
+	    prompt = _("Open newsgroup to attach message from");
+	    set_option (OPTNEWS);
+	  }
+#endif
+
 	  if (Context)
+#ifdef USE_NNTP
+	  if ((op == OP_COMPOSE_ATTACH_MESSAGE) ^ (Context->magic == M_NNTP))
+#endif
 	  {
 	    strfcpy (fname, NONULL (Context->path), sizeof (fname));
 	    mutt_pretty_mailbox (fname, sizeof (fname));
@@ -719,6 +873,11 @@ int mutt_compose_menu (HEADER *msg,   /*
 	  if (mutt_enter_fname (prompt, fname, sizeof (fname), &menu->redraw, 1) == -1 || !fname[0])
 	    break;
 
+#ifdef USE_NNTP
+	  if (option (OPTNEWS))
+	    nntp_expand_path (fname, sizeof (fname), &CurrentNewsSrv->conn->account);
+	  else
+#endif
 	  mutt_expand_path (fname, sizeof (fname));
 #ifdef USE_IMAP
           if (!mx_is_imap (fname))
@@ -726,6 +885,9 @@ int mutt_compose_menu (HEADER *msg,   /*
 #ifdef USE_POP
           if (!mx_is_pop (fname))
 #endif
+#ifdef USE_NNTP
+          if (!mx_is_nntp (fname) && !option (OPTNEWS))
+#endif
 	  /* check to make sure the file exists and is readable */
 	  if (access (fname, R_OK) == -1)
 	  {
diff -udprP mutt-1.5.21/compose.c.orig mutt-nntp-sidebar/compose.c.orig
--- mutt-1.5.21/compose.c.orig	1969-12-31 17:00:00.000000000 -0700
+++ mutt-nntp-sidebar/compose.c.orig	2011-06-03 07:05:58.942955998 -0700
@@ -0,0 +1,1303 @@
+/*
+ * Copyright (C) 1996-2000,2002,2007 Michael R. Elkins <me@mutt.org>
+ * Copyright (C) 2004 g10 Code GmbH
+ * 
+ *     This program is free software; you can redistribute it and/or modify
+ *     it under the terms of the GNU General Public License as published by
+ *     the Free Software Foundation; either version 2 of the License, or
+ *     (at your option) any later version.
+ * 
+ *     This program is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ * 
+ *     You should have received a copy of the GNU General Public License
+ *     along with this program; if not, write to the Free Software
+ *     Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */ 
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include "mutt.h"
+#include "mutt_curses.h"
+#include "mutt_idna.h"
+#include "mutt_menu.h"
+#include "rfc1524.h"
+#include "mime.h"
+#include "attach.h"
+#include "mapping.h"
+#include "mailbox.h"
+#include "sort.h"
+#include "charset.h"
+
+#ifdef MIXMASTER
+#include "remailer.h"
+#endif
+
+#include <errno.h>
+#include <string.h>
+#include <sys/stat.h>
+#include <sys/wait.h>
+#include <unistd.h>
+#include <stdlib.h>
+
+static const char* There_are_no_attachments = N_("There are no attachments.");
+
+#define CHECK_COUNT if (idxlen == 0) { mutt_error _(There_are_no_attachments); break; }
+
+
+
+enum
+{
+  HDR_FROM  = 1,
+  HDR_TO,
+  HDR_CC,
+  HDR_BCC,
+  HDR_SUBJECT,
+  HDR_REPLYTO,
+  HDR_FCC,
+
+#ifdef MIXMASTER
+  HDR_MIX,
+#endif
+
+  HDR_CRYPT,
+  HDR_CRYPTINFO,
+
+  HDR_ATTACH  = (HDR_FCC + 5) /* where to start printing the attachments */
+};
+
+#define HDR_XOFFSET 10
+#define TITLE_FMT "%10s" /* Used for Prompts, which are ASCII */
+#define W (COLS - HDR_XOFFSET - SidebarWidth)
+
+static char *Prompts[] =
+{
+  "From: ",
+  "To: ",
+  "Cc: ",
+  "Bcc: ",
+  "Subject: ",
+  "Reply-To: ",
+  "Fcc: "
+};
+
+static struct mapping_t ComposeHelp[] = {
+  { N_("Send"),    OP_COMPOSE_SEND_MESSAGE },
+  { N_("Abort"),   OP_EXIT },
+  { "To",      OP_COMPOSE_EDIT_TO },
+  { "CC",      OP_COMPOSE_EDIT_CC },
+  { "Subj",    OP_COMPOSE_EDIT_SUBJECT },
+  { N_("Attach file"),  OP_COMPOSE_ATTACH_FILE },
+  { N_("Descrip"), OP_COMPOSE_EDIT_DESCRIPTION },
+  { N_("Help"),    OP_HELP },
+  { NULL,	0 }
+};
+
+static void snd_entry (char *b, size_t blen, MUTTMENU *menu, int num)
+{
+    mutt_FormatString (b, blen, 0, NONULL (AttachFormat), mutt_attach_fmt,
+	    (unsigned long)(((ATTACHPTR **) menu->data)[num]),
+	    M_FORMAT_STAT_FILE | M_FORMAT_ARROWCURSOR);
+}
+
+
+
+#include "mutt_crypt.h"
+
+static void redraw_crypt_lines (HEADER *msg)
+{
+  int off = 0;
+
+  mvaddstr (HDR_CRYPT, SidebarWidth, "Security: ");
+
+  if ((WithCrypto & (APPLICATION_PGP | APPLICATION_SMIME)) == 0)
+  {
+    addstr(_("Not supported"));
+    return;
+  }
+
+  if ((msg->security & (ENCRYPT | SIGN)) == (ENCRYPT | SIGN))
+    addstr (_("Sign, Encrypt"));
+  else if (msg->security & ENCRYPT)
+    addstr (_("Encrypt"));
+  else if (msg->security & SIGN)
+    addstr (_("Sign"));
+  else
+    addstr (_("None"));
+
+  if ((msg->security & (ENCRYPT | SIGN)))
+  {
+    if ((WithCrypto & APPLICATION_PGP) && (msg->security & APPLICATION_PGP))
+    {
+      if ((msg->security & INLINE))
+        addstr (_(" (inline PGP)"));
+      else
+        addstr (_(" (PGP/MIME)"));
+    }
+    else if ((WithCrypto & APPLICATION_SMIME) &&
+             (msg->security & APPLICATION_SMIME))
+      addstr (_(" (S/MIME)"));
+  }
+
+  clrtoeol ();
+  move (HDR_CRYPTINFO, SidebarWidth);
+  clrtoeol ();
+
+  if ((WithCrypto & APPLICATION_PGP)
+      && msg->security & APPLICATION_PGP  && msg->security & SIGN)
+    printw ("%s%s", _(" sign as: "), PgpSignAs ? PgpSignAs : _("<default>"));
+
+  if ((WithCrypto & APPLICATION_SMIME)
+      && msg->security & APPLICATION_SMIME  && msg->security & SIGN) {
+      printw ("%s%s", _(" sign as: "), SmimeDefaultKey ? SmimeDefaultKey : _("<default>"));
+  }
+
+  if ((WithCrypto & APPLICATION_SMIME)
+      && (msg->security & APPLICATION_SMIME)
+      && (msg->security & ENCRYPT)
+      && SmimeCryptAlg
+      && *SmimeCryptAlg) {
+      mvprintw (HDR_CRYPTINFO, SidebarWidth + 40, "%s%s", _("Encrypt with: "),
+		NONULL(SmimeCryptAlg));
+      off = 20;
+  }
+}
+
+
+#ifdef MIXMASTER
+
+static void redraw_mix_line (LIST *chain)
+{
+  int c;
+  char *t;
+
+  mvaddstr (HDR_MIX, SidebarWidth,     "     Mix: ");
+
+  if (!chain)
+  {
+    addstr ("<no chain defined>");
+    clrtoeol ();
+    return;
+  }
+  
+  for (c = 12; chain; chain = chain->next)
+  {
+    t = chain->data;
+    if (t && t[0] == '0' && t[1] == '\0')
+      t = "<random>";
+    
+    if (c + mutt_strlen (t) + 2 >= COLS - SidebarWidth)
+      break;
+
+    addstr (NONULL(t));
+    if (chain->next)
+      addstr (", ");
+
+    c += mutt_strlen (t) + 2;
+  }
+}
+#endif /* MIXMASTER */
+
+static int
+check_attachments(ATTACHPTR **idx, short idxlen)
+{
+  int i, r;
+  struct stat st;
+  char pretty[_POSIX_PATH_MAX], msg[_POSIX_PATH_MAX + SHORT_STRING];
+
+  for (i = 0; i < idxlen; i++)
+  {
+    strfcpy(pretty, idx[i]->content->filename, sizeof(pretty));
+    if(stat(idx[i]->content->filename, &st) != 0)
+    {
+      mutt_pretty_mailbox(pretty, sizeof (pretty));
+      mutt_error(_("%s [#%d] no longer exists!"),
+		 pretty, i+1);
+      return -1;
+    }
+    
+    if(idx[i]->content->stamp < st.st_mtime)
+    {
+      mutt_pretty_mailbox(pretty, sizeof (pretty));
+      snprintf(msg, sizeof(msg), _("%s [#%d] modified. Update encoding?"),
+	       pretty, i+1);
+      
+      if((r = mutt_yesorno(msg, M_YES)) == M_YES)
+	mutt_update_encoding(idx[i]->content);
+      else if(r == -1)
+	return -1;
+    }
+  }
+
+  return 0;
+}
+
+static void draw_envelope_addr (int line, ADDRESS *addr)
+{
+  char buf[LONG_STRING];
+
+  buf[0] = 0;
+  rfc822_write_address (buf, sizeof (buf), addr, 1);
+  mvprintw (line, SidebarWidth, TITLE_FMT, Prompts[line - 1]);
+  mutt_paddstr (W, buf);
+}
+
+static void draw_envelope (HEADER *msg, char *fcc)
+{
+  draw_envelope_addr (HDR_FROM, msg->env->from);
+  draw_envelope_addr (HDR_TO, msg->env->to);
+  draw_envelope_addr (HDR_CC, msg->env->cc);
+  draw_envelope_addr (HDR_BCC, msg->env->bcc);
+  mvprintw (HDR_SUBJECT, SidebarWidth, TITLE_FMT, Prompts[HDR_SUBJECT - 1]);
+  mutt_paddstr (W, NONULL (msg->env->subject));
+  draw_envelope_addr (HDR_REPLYTO, msg->env->reply_to);
+  mvprintw (HDR_FCC, SidebarWidth, TITLE_FMT, Prompts[HDR_FCC - 1]);
+  mutt_paddstr (W, fcc);
+
+  if (WithCrypto)
+    redraw_crypt_lines (msg);
+
+#ifdef MIXMASTER
+  redraw_mix_line (msg->chain);
+#endif
+
+  SETCOLOR (MT_COLOR_STATUS);
+  mvaddstr (HDR_ATTACH - 1, SidebarWidth, _("-- Attachments"));
+  BKGDSET (MT_COLOR_STATUS);
+  clrtoeol ();
+
+  BKGDSET (MT_COLOR_NORMAL);
+  SETCOLOR (MT_COLOR_NORMAL);
+}
+
+static int edit_address_list (int line, ADDRESS **addr)
+{
+  char buf[HUGE_STRING] = ""; /* needs to be large for alias expansion */
+  char *err = NULL;
+  
+  mutt_addrlist_to_local (*addr);
+  rfc822_write_address (buf, sizeof (buf), *addr, 0);
+  if (mutt_get_field (Prompts[line - 1], buf, sizeof (buf), M_ALIAS) == 0)
+  {
+    rfc822_free_address (addr);
+    *addr = mutt_parse_adrlist (*addr, buf);
+    *addr = mutt_expand_aliases (*addr);
+  }
+
+  if (option (OPTNEEDREDRAW))
+  {
+    unset_option (OPTNEEDREDRAW);
+    return (REDRAW_FULL);
+  }
+
+  if (mutt_addrlist_to_idna (*addr, &err) != 0)
+  {
+    mutt_error (_("Warning: '%s' is a bad IDN."), err);
+    mutt_refresh();
+    FREE (&err);
+  }
+
+  /* redraw the expanded list so the user can see the result */
+  buf[0] = 0;
+  rfc822_write_address (buf, sizeof (buf), *addr, 1);
+  move (line, HDR_XOFFSET+SidebarWidth);
+  mutt_paddstr (W, buf);
+  
+  return 0;
+}
+
+static int delete_attachment (MUTTMENU *menu, short *idxlen, int x)
+{
+  ATTACHPTR **idx = (ATTACHPTR **) menu->data;
+  int y;
+
+  menu->redraw = REDRAW_INDEX | REDRAW_STATUS;
+
+  if (x == 0 && menu->max == 1)
+  {
+    mutt_error _("You may not delete the only attachment.");
+    idx[x]->content->tagged = 0;
+    return (-1);
+  }
+
+  for (y = 0; y < *idxlen; y++)
+  {
+    if (idx[y]->content->next == idx[x]->content)
+    {
+      idx[y]->content->next = idx[x]->content->next;
+      break;
+    }
+  }
+
+  idx[x]->content->next = NULL;
+  idx[x]->content->parts = NULL;
+  mutt_free_body (&(idx[x]->content));
+  FREE (&idx[x]->tree);
+  FREE (&idx[x]);
+  for (; x < *idxlen - 1; x++)
+    idx[x] = idx[x+1];
+  menu->max = --(*idxlen);
+  
+  return (0);
+}
+
+static void update_idx (MUTTMENU *menu, ATTACHPTR **idx, short idxlen)
+{
+  idx[idxlen]->level = (idxlen > 0) ? idx[idxlen-1]->level : 0;
+  if (idxlen)
+    idx[idxlen - 1]->content->next = idx[idxlen]->content;
+  idx[idxlen]->content->aptr = idx[idxlen];
+  menu->current = idxlen++;
+  mutt_update_tree (idx, idxlen);
+  menu->max = idxlen;
+  return;
+}
+
+
+/* 
+ * cum_attachs_size: Cumulative Attachments Size
+ *
+ * Returns the total number of bytes used by the attachments in the
+ * attachment list _after_ content-transfer-encodings have been
+ * applied.
+ * 
+ */
+
+static unsigned long cum_attachs_size (MUTTMENU *menu)
+{
+  size_t s;
+  unsigned short i;
+  ATTACHPTR **idx = menu->data;
+  CONTENT *info;
+  BODY *b;
+  
+  for (i = 0, s = 0; i < menu->max; i++)
+  {
+    b = idx[i]->content;
+
+    if (!b->content)
+      b->content = mutt_get_content_info (b->filename, b);
+
+    if ((info = b->content))
+    {
+      switch (b->encoding)
+      {
+	case ENCQUOTEDPRINTABLE:
+	  s += 3 * (info->lobin + info->hibin) + info->ascii + info->crlf;
+	  break;
+	case ENCBASE64:
+	  s += (4 * (info->lobin + info->hibin + info->ascii + info->crlf)) / 3;
+	  break;
+	default:
+	  s += info->lobin + info->hibin + info->ascii + info->crlf;
+	  break;
+      }
+    }
+  }
+
+  return s;
+}
+
+/* prototype for use below */
+static void compose_status_line (char *buf, size_t buflen, size_t col, MUTTMENU *menu, 
+      const char *p);
+
+/*
+ * compose_format_str()
+ *
+ * %a = total number of attachments 
+ * %h = hostname  [option]
+ * %l = approx. length of current message (in bytes) 
+ * %v = Mutt version 
+ *
+ * This function is similar to status_format_str().  Look at that function for
+ * help when modifying this function.
+ */
+
+static const char *
+compose_format_str (char *buf, size_t buflen, size_t col, char op, const char *src,
+		   const char *prefix, const char *ifstring,
+		   const char *elsestring,
+		   unsigned long data, format_flag flags)
+{
+  char fmt[SHORT_STRING], tmp[SHORT_STRING];
+  int optional = (flags & M_FORMAT_OPTIONAL);
+  MUTTMENU *menu = (MUTTMENU *) data;
+
+  *buf = 0;
+  switch (op)
+  {
+    case 'a': /* total number of attachments */
+	snprintf (fmt, sizeof (fmt), "%%%sd", prefix);
+	snprintf (buf, buflen, fmt, menu->max);
+      break;
+
+    case 'h':  /* hostname */
+      snprintf (fmt, sizeof (fmt), "%%%ss", prefix);
+      snprintf (buf, buflen, fmt, NONULL(Hostname));
+      break;
+
+    case 'l': /* approx length of current message in bytes */
+	snprintf (fmt, sizeof (fmt), "%%%ss", prefix);
+	mutt_pretty_size (tmp, sizeof (tmp), menu ? cum_attachs_size(menu) : 0);
+	snprintf (buf, buflen, fmt, tmp);
+      break;
+
+    case 'v':
+      snprintf (fmt, sizeof (fmt), "Mutt %%s");
+      snprintf (buf, buflen, fmt, MUTT_VERSION);
+      break;
+
+    case 0:
+      *buf = 0;
+      return (src);
+
+    default:
+      snprintf (buf, buflen, "%%%s%c", prefix, op);
+      break;
+  }
+
+  if (optional)
+    compose_status_line (buf, buflen, col, menu, ifstring);
+  else if (flags & M_FORMAT_OPTIONAL)
+    compose_status_line (buf, buflen, col, menu, elsestring);
+
+  return (src);
+}
+
+static void compose_status_line (char *buf, size_t buflen, size_t col, MUTTMENU *menu, 
+      const char *p)
+{
+  mutt_FormatString (buf, buflen, col, p, compose_format_str, 
+        (unsigned long) menu, 0);
+}
+
+
+/* return values:
+ *
+ * 1	message should be postponed
+ * 0	normal exit
+ * -1	abort message
+ */
+int mutt_compose_menu (HEADER *msg,   /* structure for new message */
+		    char *fcc,     /* where to save a copy of the message */
+		    size_t fcclen,
+		    HEADER *cur)   /* current message */
+{
+  char helpstr[LONG_STRING];
+  char buf[LONG_STRING];
+  char fname[_POSIX_PATH_MAX];
+  MUTTMENU *menu;
+  ATTACHPTR **idx = NULL;
+  short idxlen = 0;
+  short idxmax = 0;
+  int i, close = 0;
+  int r = -1;		/* return value */
+  int op = 0;
+  int loop = 1;
+  int fccSet = 0;	/* has the user edited the Fcc: field ? */
+  CONTEXT *ctx = NULL, *this = NULL;
+  /* Sort, SortAux could be changed in mutt_index_menu() */
+  int oldSort, oldSortAux;
+  struct stat st;
+
+  mutt_attach_init (msg->content);
+  idx = mutt_gen_attach_list (msg->content, -1, idx, &idxlen, &idxmax, 0, 1);
+
+  menu = mutt_new_menu (MENU_COMPOSE);
+  menu->offset = HDR_ATTACH;
+  menu->max = idxlen;
+  menu->make_entry = snd_entry;
+  menu->tag = mutt_tag_attach;
+  menu->data = idx;
+  menu->help = mutt_compile_help (helpstr, sizeof (helpstr), MENU_COMPOSE, ComposeHelp);
+  
+  while (loop)
+  {
+    switch (op = mutt_menuLoop (menu))
+    {
+      case OP_REDRAW:
+	draw_envelope (msg, fcc);
+	menu->offset = HDR_ATTACH;
+	menu->pagelen = LINES - HDR_ATTACH - 2;
+	break;
+      case OP_COMPOSE_EDIT_FROM:
+	menu->redraw = edit_address_list (HDR_FROM, &msg->env->from);
+        mutt_message_hook (NULL, msg, M_SEND2HOOK);
+	break;
+      case OP_COMPOSE_EDIT_TO:
+	menu->redraw = edit_address_list (HDR_TO, &msg->env->to);
+        mutt_message_hook (NULL, msg, M_SEND2HOOK);
+        break;
+      case OP_COMPOSE_EDIT_BCC:
+	menu->redraw = edit_address_list (HDR_BCC, &msg->env->bcc);
+        mutt_message_hook (NULL, msg, M_SEND2HOOK);
+	break;
+      case OP_COMPOSE_EDIT_CC:
+	menu->redraw = edit_address_list (HDR_CC, &msg->env->cc);
+        mutt_message_hook (NULL, msg, M_SEND2HOOK);	
+        break;
+      case OP_COMPOSE_EDIT_SUBJECT:
+	if (msg->env->subject)
+	  strfcpy (buf, msg->env->subject, sizeof (buf));
+	else
+	  buf[0] = 0;
+	if (mutt_get_field ("Subject: ", buf, sizeof (buf), 0) == 0)
+	{
+	  mutt_str_replace (&msg->env->subject, buf);
+	  move (HDR_SUBJECT, HDR_XOFFSET + SidebarWidth);
+	  clrtoeol ();
+	  if (msg->env->subject)
+	    mutt_paddstr (W, msg->env->subject);
+	}
+        mutt_message_hook (NULL, msg, M_SEND2HOOK);
+        break;
+      case OP_COMPOSE_EDIT_REPLY_TO:
+	menu->redraw = edit_address_list (HDR_REPLYTO, &msg->env->reply_to);
+        mutt_message_hook (NULL, msg, M_SEND2HOOK);
+	break;
+      case OP_COMPOSE_EDIT_FCC:
+	strfcpy (buf, fcc, sizeof (buf));
+	if (mutt_get_field ("Fcc: ", buf, sizeof (buf), M_FILE | M_CLEAR) == 0)
+	{
+	  strfcpy (fcc, buf, fcclen);
+	  mutt_pretty_mailbox (fcc, fcclen);
+	  move (HDR_FCC, HDR_XOFFSET + SidebarWidth);
+	  mutt_paddstr (W, fcc);
+	  fccSet = 1;
+	}
+	MAYBE_REDRAW (menu->redraw);
+        mutt_message_hook (NULL, msg, M_SEND2HOOK);
+        break;
+      case OP_COMPOSE_EDIT_MESSAGE:
+	if (Editor && (mutt_strcmp ("builtin", Editor) != 0) && !option (OPTEDITHDRS))
+	{
+	  mutt_edit_file (Editor, msg->content->filename);
+	  mutt_update_encoding (msg->content);
+	  menu->redraw = REDRAW_FULL;
+	  mutt_message_hook (NULL, msg, M_SEND2HOOK);
+	  break;
+	}
+	/* fall through */
+      case OP_COMPOSE_EDIT_HEADERS:
+	if (mutt_strcmp ("builtin", Editor) != 0 &&
+	    (op == OP_COMPOSE_EDIT_HEADERS ||
+	    (op == OP_COMPOSE_EDIT_MESSAGE && option (OPTEDITHDRS))))
+	{
+	  char *tag = NULL, *err = NULL;
+	  mutt_env_to_local (msg->env);
+	  mutt_edit_headers (NONULL (Editor), msg->content->filename, msg,
+			     fcc, fcclen);
+	  if (mutt_env_to_idna (msg->env, &tag, &err))
+	  {
+	    mutt_error (_("Bad IDN in \"%s\": '%s'"), tag, err);
+	    FREE (&err);
+	  }
+	}
+	else
+	{
+	  /* this is grouped with OP_COMPOSE_EDIT_HEADERS because the
+	     attachment list could change if the user invokes ~v to edit
+	     the message with headers, in which we need to execute the
+	     code below to regenerate the index array */
+	  mutt_builtin_editor (msg->content->filename, msg, cur);
+	}
+	mutt_update_encoding (msg->content);
+
+	/* attachments may have been added */
+	if (idxlen && idx[idxlen - 1]->content->next)
+	{
+	  for (i = 0; i < idxlen; i++)
+	    FREE (&idx[i]);
+	  idxlen = 0;
+	  idx = mutt_gen_attach_list (msg->content, -1, idx, &idxlen, &idxmax, 0, 1);
+	  menu->data = idx;
+	  menu->max = idxlen;
+	}
+
+        menu->redraw = REDRAW_FULL;
+        mutt_message_hook (NULL, msg, M_SEND2HOOK);
+	break;
+
+
+
+      case OP_COMPOSE_ATTACH_KEY:
+        if (!(WithCrypto & APPLICATION_PGP))
+          break;       
+	if (idxlen == idxmax)
+        {
+	  safe_realloc (&idx, sizeof (ATTACHPTR *) * (idxmax += 5));
+	  menu->data = idx;
+	}
+	
+	idx[idxlen] = (ATTACHPTR *) safe_calloc (1, sizeof (ATTACHPTR));
+	if ((idx[idxlen]->content = crypt_pgp_make_key_attachment(NULL)) != NULL)
+	{
+	  update_idx (menu, idx, idxlen++);
+	  menu->redraw |= REDRAW_INDEX;
+	}
+	else
+	  FREE (&idx[idxlen]);
+
+	menu->redraw |= REDRAW_STATUS;
+
+	if (option(OPTNEEDREDRAW))
+	{
+	  menu->redraw = REDRAW_FULL;
+	  unset_option(OPTNEEDREDRAW);
+	}
+	
+        mutt_message_hook (NULL, msg, M_SEND2HOOK);
+        break;
+
+
+      case OP_COMPOSE_ATTACH_FILE:
+	{
+	  char *prompt, **files;
+	  int error, numfiles;
+
+	  fname[0] = 0;
+	  prompt = _("Attach file");
+	  numfiles = 0;
+	  files = NULL;
+
+	  if (_mutt_enter_fname (prompt, fname, sizeof (fname), &menu->redraw, 0, 1, &files, &numfiles) == -1 ||
+	      *fname == '\0')
+	    break;
+
+	  if (idxlen + numfiles >= idxmax)
+	  {
+	    safe_realloc (&idx, sizeof (ATTACHPTR *) * (idxmax += 5 + numfiles));
+	    menu->data = idx;
+	  }
+
+	  error = 0;
+	  if (numfiles > 1)
+	    mutt_message _("Attaching selected files...");
+	  for (i = 0; i < numfiles; i++)
+	  {
+	    char *att = files[i];
+	    idx[idxlen] = (ATTACHPTR *) safe_calloc (1, sizeof (ATTACHPTR));
+            idx[idxlen]->unowned = 1;
+	    idx[idxlen]->content = mutt_make_file_attach (att);
+	    if (idx[idxlen]->content != NULL)
+	      update_idx (menu, idx, idxlen++);
+	    else
+	    {
+	      error = 1;
+	      mutt_error (_("Unable to attach %s!"), att);
+	      FREE (&idx[idxlen]);
+	    }
+	  }
+	  
+	  FREE (&files);
+	  if (!error) mutt_clear_error ();
+
+	  menu->redraw |= REDRAW_INDEX | REDRAW_STATUS;
+	}
+        mutt_message_hook (NULL, msg, M_SEND2HOOK);
+        break;
+
+      case OP_COMPOSE_ATTACH_MESSAGE:
+	{
+	  char *prompt;
+	  HEADER *h;
+
+	  fname[0] = 0;
+	  prompt = _("Open mailbox to attach message from");
+
+	  if (Context)
+	  {
+	    strfcpy (fname, NONULL (Context->path), sizeof (fname));
+	    mutt_pretty_mailbox (fname, sizeof (fname));
+	  }
+
+	  if (mutt_enter_fname (prompt, fname, sizeof (fname), &menu->redraw, 1) == -1 || !fname[0])
+	    break;
+
+	  mutt_expand_path (fname, sizeof (fname));
+#ifdef USE_IMAP
+          if (!mx_is_imap (fname))
+#endif
+#ifdef USE_POP
+          if (!mx_is_pop (fname))
+#endif
+	  /* check to make sure the file exists and is readable */
+	  if (access (fname, R_OK) == -1)
+	  {
+	    mutt_perror (fname);
+	    break;
+	  }
+
+	  menu->redraw = REDRAW_FULL;
+
+	  ctx = mx_open_mailbox (fname, M_READONLY, NULL);
+	  if (ctx == NULL)
+	  {
+	    mutt_perror (fname);
+	    break;
+	  }
+
+	  if (!ctx->msgcount)
+	  {
+	    mx_close_mailbox (ctx, NULL);
+	    FREE (&ctx);
+	    mutt_error _("No messages in that folder.");
+	    break;
+	  }
+
+	  this = Context; /* remember current folder and sort methods*/
+	  oldSort = Sort; oldSortAux = SortAux;
+	  
+	  Context = ctx;
+	  set_option(OPTATTACHMSG);
+	  mutt_message _("Tag the messages you want to attach!");
+	  close = mutt_index_menu ();
+	  unset_option(OPTATTACHMSG);
+
+	  if (!Context)
+	  {
+	    /* go back to the folder we started from */
+	    Context = this;
+	    /* Restore old $sort and $sort_aux */
+	    Sort = oldSort;
+	    SortAux = oldSortAux;
+	    menu->redraw |= REDRAW_INDEX | REDRAW_STATUS;
+	    break;
+	  }
+
+	  if (idxlen + Context->tagged >= idxmax)
+	  {
+	    safe_realloc (&idx, sizeof (ATTACHPTR *) * (idxmax += 5 + Context->tagged));
+	    menu->data = idx;
+	  }
+
+	  for (i = 0; i < Context->msgcount; i++)
+	  {
+	    h = Context->hdrs[i];
+	    if (h->tagged)
+	    {
+	      idx[idxlen] = (ATTACHPTR *) safe_calloc (1, sizeof (ATTACHPTR));
+	      idx[idxlen]->content = mutt_make_message_attach (Context, h, 1);
+	      if (idx[idxlen]->content != NULL)
+		update_idx (menu, idx, idxlen++);
+	      else
+	      {
+		mutt_error _("Unable to attach!");
+		FREE (&idx[idxlen]);
+	      }
+	    }
+	  }
+	  menu->redraw |= REDRAW_FULL;
+
+	  if (close == OP_QUIT) 
+	    mx_close_mailbox (Context, NULL);
+	  else
+	    mx_fastclose_mailbox (Context);
+	  FREE (&Context);
+
+	  /* go back to the folder we started from */
+	  Context = this;
+	  /* Restore old $sort and $sort_aux */
+	  Sort = oldSort;
+	  SortAux = oldSortAux;
+	}
+        mutt_message_hook (NULL, msg, M_SEND2HOOK);
+        break;
+
+      case OP_DELETE:
+	CHECK_COUNT;
+        if (idx[menu->current]->unowned)
+          idx[menu->current]->content->unlink = 0;
+	if (delete_attachment (menu, &idxlen, menu->current) == -1)
+	  break;
+	mutt_update_tree (idx, idxlen);
+	if (idxlen)
+	{
+	  if (menu->current > idxlen - 1)
+	    menu->current = idxlen - 1;
+	}
+	else
+	  menu->current = 0;
+
+	if (menu->current == 0)
+	  msg->content = idx[0]->content;
+
+        menu->redraw |= REDRAW_STATUS;
+        mutt_message_hook (NULL, msg, M_SEND2HOOK);
+        break;
+
+#define CURRENT idx[menu->current]->content
+      
+      case OP_COMPOSE_TOGGLE_RECODE:
+      {      
+        CHECK_COUNT;
+        if (!mutt_is_text_part (CURRENT))
+        {
+	  mutt_error (_("Recoding only affects text attachments."));
+	  break;
+	}
+        CURRENT->noconv = !CURRENT->noconv;
+        if (CURRENT->noconv)
+	  mutt_message (_("The current attachment won't be converted."));
+        else
+	  mutt_message (_("The current attachment will be converted."));
+	menu->redraw = REDRAW_CURRENT;
+        mutt_message_hook (NULL, msg, M_SEND2HOOK);
+        break;
+      }
+#undef CURRENT
+
+      case OP_COMPOSE_EDIT_DESCRIPTION:
+	CHECK_COUNT;
+	strfcpy (buf,
+		 idx[menu->current]->content->description ?
+		 idx[menu->current]->content->description : "",
+		 sizeof (buf));
+	/* header names should not be translated */
+	if (mutt_get_field ("Description: ", buf, sizeof (buf), 0) == 0)
+	{
+	  mutt_str_replace (&idx[menu->current]->content->description, buf);
+	  menu->redraw = REDRAW_CURRENT;
+	}
+        mutt_message_hook (NULL, msg, M_SEND2HOOK);
+        break;
+
+      case OP_COMPOSE_UPDATE_ENCODING:
+        CHECK_COUNT;
+        if (menu->tagprefix)
+        {
+	  BODY *top;
+	  for (top = msg->content; top; top = top->next)
+	  {
+	    if (top->tagged)
+	      mutt_update_encoding (top);
+	  }
+	  menu->redraw = REDRAW_FULL;
+	}
+        else
+        {
+          mutt_update_encoding(idx[menu->current]->content);
+	  menu->redraw = REDRAW_CURRENT | REDRAW_STATUS;
+	}
+        mutt_message_hook (NULL, msg, M_SEND2HOOK);
+        break;
+      
+      case OP_COMPOSE_TOGGLE_DISPOSITION:
+	/* toggle the content-disposition between inline/attachment */
+	idx[menu->current]->content->disposition = (idx[menu->current]->content->disposition == DISPINLINE) ? DISPATTACH : DISPINLINE;
+	menu->redraw = REDRAW_CURRENT;
+	break;
+
+      case OP_EDIT_TYPE:
+	CHECK_COUNT;
+        {
+	  mutt_edit_content_type (NULL, idx[menu->current]->content, NULL);
+
+	  /* this may have been a change to text/something */
+	  mutt_update_encoding (idx[menu->current]->content);
+
+	  menu->redraw = REDRAW_CURRENT;
+	}
+        mutt_message_hook (NULL, msg, M_SEND2HOOK);
+        break;
+
+      case OP_COMPOSE_EDIT_ENCODING:
+	CHECK_COUNT;
+	strfcpy (buf, ENCODING (idx[menu->current]->content->encoding),
+							      sizeof (buf));
+	if (mutt_get_field ("Content-Transfer-Encoding: ", buf,
+					    sizeof (buf), 0) == 0 && buf[0])
+	{
+	  if ((i = mutt_check_encoding (buf)) != ENCOTHER && i != ENCUUENCODED)
+	  {
+	    idx[menu->current]->content->encoding = i;
+	    menu->redraw = REDRAW_CURRENT | REDRAW_STATUS;
+	    mutt_clear_error();
+	  }
+	  else
+	    mutt_error _("Invalid encoding.");
+	}
+        mutt_message_hook (NULL, msg, M_SEND2HOOK);
+        break;
+
+      case OP_COMPOSE_SEND_MESSAGE:
+
+        /* Note: We don't invoke send2-hook here, since we want to leave
+	 * users an opportunity to change settings from the ":" prompt.
+	 */
+      
+        if(check_attachments(idx, idxlen) != 0)
+        {
+	  menu->redraw = REDRAW_FULL;
+	  break;
+	}
+
+      
+#ifdef MIXMASTER
+        if (msg->chain && mix_check_message (msg) != 0)
+	  break;
+#endif
+      
+	if (!fccSet && *fcc)
+	{
+	  if ((i = query_quadoption (OPT_COPY,
+				_("Save a copy of this message?"))) == -1)
+	    break;
+	  else if (i == M_NO)
+	    *fcc = 0;
+	}
+
+	loop = 0;
+	r = 0;
+	break;
+
+      case OP_COMPOSE_EDIT_FILE:
+	CHECK_COUNT;
+	mutt_edit_file (NONULL(Editor), idx[menu->current]->content->filename);
+	mutt_update_encoding (idx[menu->current]->content);
+	menu->redraw = REDRAW_CURRENT | REDRAW_STATUS;
+        mutt_message_hook (NULL, msg, M_SEND2HOOK);
+	break;
+
+      case OP_COMPOSE_TOGGLE_UNLINK:
+	CHECK_COUNT;
+	idx[menu->current]->content->unlink = !idx[menu->current]->content->unlink;
+
+#if 0
+        /* OPTRESOLVE is otherwise ignored on this menu.
+	 * Where's the bug?
+	 */
+
+        if (option (OPTRESOLVE) && menu->current + 1 < menu->max)
+	  menu->current++;
+# endif
+	menu->redraw = REDRAW_INDEX;
+        /* No send2hook since this doesn't change the message. */
+	break;
+
+      case OP_COMPOSE_GET_ATTACHMENT:
+        CHECK_COUNT;
+        if(menu->tagprefix)
+        {
+	  BODY *top;
+	  for(top = msg->content; top; top = top->next)
+	  {
+	    if(top->tagged)
+	      mutt_get_tmp_attachment(top);
+	  }
+	  menu->redraw = REDRAW_FULL;
+	}
+        else if (mutt_get_tmp_attachment(idx[menu->current]->content) == 0)
+	  menu->redraw = REDRAW_CURRENT;
+
+        /* No send2hook since this doesn't change the message. */
+        break;
+      
+      case OP_COMPOSE_RENAME_FILE:
+	CHECK_COUNT;
+	strfcpy (fname, idx[menu->current]->content->filename, sizeof (fname));
+	mutt_pretty_mailbox (fname, sizeof (fname));
+	if (mutt_get_field (_("Rename to: "), fname, sizeof (fname), M_FILE)
+							== 0 && fname[0])
+	{
+	  if (stat(idx[menu->current]->content->filename, &st) == -1)
+	  {
+	    mutt_error (_("Can't stat %s: %s"), fname, strerror (errno));
+	    break;
+	  }
+
+	  mutt_expand_path (fname, sizeof (fname));
+	  if(mutt_rename_file (idx[menu->current]->content->filename, fname))
+	    break;
+	  
+	  mutt_str_replace (&idx[menu->current]->content->filename, fname);
+	  menu->redraw = REDRAW_CURRENT;
+
+	  if(idx[menu->current]->content->stamp >= st.st_mtime)
+	    mutt_stamp_attachment(idx[menu->current]->content);
+	  
+	}
+        mutt_message_hook (NULL, msg, M_SEND2HOOK);
+        break;
+
+      case OP_COMPOSE_NEW_MIME:
+	{
+	  char type[STRING];
+	  char *p;
+	  int itype;
+	  FILE *fp;
+
+	  CLEARLINE (LINES-1);
+	  fname[0] = 0;
+	  if (mutt_get_field (_("New file: "), fname, sizeof (fname), M_FILE)
+	      != 0 || !fname[0])
+	    continue;
+	  mutt_expand_path (fname, sizeof (fname));
+
+	  /* Call to lookup_mime_type () ?  maybe later */
+	  type[0] = 0;
+	  if (mutt_get_field ("Content-Type: ", type, sizeof (type), 0) != 0 
+	      || !type[0])
+	    continue;
+
+	  if (!(p = strchr (type, '/')))
+	  {
+	    mutt_error _("Content-Type is of the form base/sub");
+	    continue;
+	  }
+	  *p++ = 0;
+	  if ((itype = mutt_check_mime_type (type)) == TYPEOTHER)
+	  {
+	    mutt_error (_("Unknown Content-Type %s"), type);
+	    continue;
+	  }
+	  if (idxlen == idxmax)
+	  {
+	    safe_realloc (&idx, sizeof (ATTACHPTR *) * (idxmax += 5));
+	    menu->data = idx;
+	  }
+
+	  idx[idxlen] = (ATTACHPTR *) safe_calloc (1, sizeof (ATTACHPTR));
+	  /* Touch the file */
+	  if (!(fp = safe_fopen (fname, "w")))
+	  {
+	    mutt_error (_("Can't create file %s"), fname);
+	    FREE (&idx[idxlen]);
+	    continue;
+	  }
+	  safe_fclose (&fp);
+
+	  if ((idx[idxlen]->content = mutt_make_file_attach (fname)) == NULL)
+	  {
+	    mutt_error _("What we have here is a failure to make an attachment");
+	    continue;
+	  }
+	  update_idx (menu, idx, idxlen++);
+
+	  idx[menu->current]->content->type = itype;
+	  mutt_str_replace (&idx[menu->current]->content->subtype, p);
+	  idx[menu->current]->content->unlink = 1;
+	  menu->redraw |= REDRAW_INDEX | REDRAW_STATUS;
+
+	  if (mutt_compose_attachment (idx[menu->current]->content))
+	  {
+	    mutt_update_encoding (idx[menu->current]->content);
+	    menu->redraw = REDRAW_FULL;
+	  }
+	}
+        mutt_message_hook (NULL, msg, M_SEND2HOOK);    
+        break;
+
+      case OP_COMPOSE_EDIT_MIME:
+	CHECK_COUNT;
+	if (mutt_edit_attachment (idx[menu->current]->content))
+	{
+	  mutt_update_encoding (idx[menu->current]->content);
+	  menu->redraw = REDRAW_FULL;
+	}
+        mutt_message_hook (NULL, msg, M_SEND2HOOK);
+        break;
+
+      case OP_VIEW_ATTACH:
+      case OP_DISPLAY_HEADERS:
+	CHECK_COUNT;
+	mutt_attach_display_loop (menu, op, NULL, NULL, NULL, &idx, &idxlen, NULL, 0);
+	menu->redraw = REDRAW_FULL;
+        /* no send2hook, since this doesn't modify the message */
+	break;
+
+      case OP_SAVE:
+	CHECK_COUNT;
+	mutt_save_attachment_list (NULL, menu->tagprefix, menu->tagprefix ?  msg->content : idx[menu->current]->content, NULL, menu);
+	MAYBE_REDRAW (menu->redraw);
+        /* no send2hook, since this doesn't modify the message */
+	break;
+
+      case OP_PRINT:
+	CHECK_COUNT;
+	mutt_print_attachment_list (NULL, menu->tagprefix, menu->tagprefix ? msg->content : idx[menu->current]->content);
+        /* no send2hook, since this doesn't modify the message */
+	break;
+
+      case OP_PIPE:
+      case OP_FILTER:
+        CHECK_COUNT;
+	mutt_pipe_attachment_list (NULL, menu->tagprefix, menu->tagprefix ? msg->content : idx[menu->current]->content, op == OP_FILTER);
+	if (op == OP_FILTER) /* cte might have changed */
+	  menu->redraw = menu->tagprefix ? REDRAW_FULL : REDRAW_CURRENT;
+        menu->redraw |= REDRAW_STATUS;
+        mutt_message_hook (NULL, msg, M_SEND2HOOK);
+	break;
+
+      case OP_EXIT:
+	if ((i = query_quadoption (OPT_POSTPONE, _("Postpone this message?"))) == M_NO)
+	{
+	  while (idxlen-- > 0)
+	  {
+	    /* avoid freeing other attachments */
+	    idx[idxlen]->content->next = NULL;
+	    idx[idxlen]->content->parts = NULL;
+            if (idx[idxlen]->unowned)
+              idx[idxlen]->content->unlink = 0;
+	    mutt_free_body (&idx[idxlen]->content);
+	    FREE (&idx[idxlen]->tree);
+	    FREE (&idx[idxlen]);
+	  }
+	  FREE (&idx);
+	  idxlen = 0;
+	  idxmax = 0;
+	  r = -1;
+	  loop = 0;
+	  break;
+	}
+	else if (i == -1)
+	  break; /* abort */
+
+	/* fall through to postpone! */
+
+      case OP_COMPOSE_POSTPONE_MESSAGE:
+
+        if(check_attachments(idx, idxlen) != 0)
+        {
+	  menu->redraw = REDRAW_FULL;
+	  break;
+	}
+      
+	loop = 0;
+	r = 1;
+	break;
+
+      case OP_COMPOSE_ISPELL:
+	endwin ();
+	snprintf (buf, sizeof (buf), "%s -x %s", NONULL(Ispell), msg->content->filename);
+	if (mutt_system (buf) == -1)
+	  mutt_error (_("Error running \"%s\"!"), buf);
+	else
+        {
+	  mutt_update_encoding (msg->content);
+	  menu->redraw |= REDRAW_STATUS;
+	}
+	break;
+
+      case OP_COMPOSE_WRITE_MESSAGE:
+
+       fname[0] = '\0';
+       if (Context)
+       {
+	 strfcpy (fname, NONULL (Context->path), sizeof (fname));
+	 mutt_pretty_mailbox (fname, sizeof (fname));
+       }
+       if (idxlen)
+         msg->content = idx[0]->content;
+       if (mutt_enter_fname (_("Write message to mailbox"), fname, sizeof (fname),
+                             &menu->redraw, 1) != -1 && fname[0])
+       {
+         mutt_message (_("Writing message to %s ..."), fname);
+         mutt_expand_path (fname, sizeof (fname));
+
+         if (msg->content->next)
+           msg->content = mutt_make_multipart (msg->content);
+
+         if (mutt_write_fcc (fname, msg, NULL, 0, NULL) < 0)
+           msg->content = mutt_remove_multipart (msg->content);
+         else
+           mutt_message _("Message written.");
+       }
+       break;
+
+
+
+      case OP_COMPOSE_PGP_MENU:
+        if (!(WithCrypto & APPLICATION_PGP))
+          break;
+	if ((WithCrypto & APPLICATION_SMIME)
+            && msg->security & APPLICATION_SMIME)
+	{
+	  if (mutt_yesorno (_("S/MIME already selected. Clear & continue ? "),
+			     M_YES) != M_YES)
+	  {
+	    mutt_clear_error ();
+	    break;
+	  }
+	  msg->security = 0;
+	}
+	msg->security = crypt_pgp_send_menu (msg, &menu->redraw);
+	redraw_crypt_lines (msg);
+        mutt_message_hook (NULL, msg, M_SEND2HOOK);
+        break;
+
+
+      case OP_FORGET_PASSPHRASE:
+	crypt_forget_passphrase ();
+	break;
+
+
+      case OP_COMPOSE_SMIME_MENU:
+        if (!(WithCrypto & APPLICATION_SMIME))
+          break;
+
+	if ((WithCrypto & APPLICATION_PGP)
+            && msg->security & APPLICATION_PGP)
+	{
+	  if (mutt_yesorno (_("PGP already selected. Clear & continue ? "),
+			      M_YES) != M_YES)
+	  {
+	     mutt_clear_error ();
+	     break;
+	  }
+	  msg->security = 0;
+	}
+	msg->security = crypt_smime_send_menu(msg, &menu->redraw);
+	redraw_crypt_lines (msg);
+        mutt_message_hook (NULL, msg, M_SEND2HOOK);
+        break;
+
+
+#ifdef MIXMASTER
+      case OP_COMPOSE_MIX:
+      
+      	mix_make_chain (&msg->chain, &menu->redraw);
+        mutt_message_hook (NULL, msg, M_SEND2HOOK);
+        break;
+#endif
+
+    }
+
+    /* Draw formated compose status line */
+    if (menu->redraw & REDRAW_STATUS) 
+    {
+	compose_status_line (buf, sizeof (buf), 0, menu, NONULL(ComposeFormat));
+	CLEARLINE (option (OPTSTATUSONTOP) ? 0 : LINES-2);
+	SETCOLOR (MT_COLOR_STATUS);
+	BKGDSET (MT_COLOR_STATUS);
+	mutt_paddstr (COLS, buf);
+	SETCOLOR (MT_COLOR_NORMAL);
+	BKGDSET (MT_COLOR_NORMAL);
+	menu->redraw &= ~REDRAW_STATUS;
+    }
+  }
+
+  mutt_menuDestroy (&menu);
+
+  if (idxlen)
+  {
+    msg->content = idx[0]->content;
+    for (i = 0; i < idxlen; i++)
+    {
+      idx[i]->content->aptr = NULL;
+      FREE (&idx[i]);
+    }
+  }
+  else
+    msg->content = NULL;
+
+  FREE (&idx);
+
+  return (r);
+}
+
diff -udprP mutt-1.5.21/config.h.in mutt-nntp-sidebar/config.h.in
--- mutt-1.5.21/config.h.in	2010-08-25 09:32:03.000000000 -0700
+++ mutt-nntp-sidebar/config.h.in	2011-06-03 07:05:58.932955999 -0700
@@ -37,6 +37,9 @@
    significant more memory when defined. */
 #undef EXACT_ADDRESS
 
+/* Compiling with newsreading support with NNTP */
+#undef USE_NNTP
+
 /* program to use for shell commands */
 #undef EXECSHELL
 
diff -udprP mutt-1.5.21/configure mutt-nntp-sidebar/configure
--- mutt-1.5.21/configure	2010-08-25 09:31:47.000000000 -0700
+++ mutt-nntp-sidebar/configure	2011-06-03 07:05:58.929622666 -0700
@@ -1427,6 +1427,7 @@ Optional Features:
                           Force use of an external dotlock program
   --enable-pop            Enable POP3 support
   --enable-imap           Enable IMAP support
+  --enable-nntp           Enable NNTP support
   --enable-smtp           include internal SMTP relay support
   --enable-debug          Enable debugging support
   --enable-flock          Use flock() to lock files
@@ -10823,6 +10824,20 @@ _ACEOF
 fi
 done
 
+# Check whether --enable-nntp or --disable-nntp was given.
+if test "${enable_nntp+set}" = set; then
+  enableval="$enable_nntp"
+  	if test x$enableval = xyes ; then
+		cat >>confdefs.h <<\_ACEOF
+#define USE_NNTP 1
+_ACEOF
+
+		MUTT_LIB_OBJECTS="$MUTT_LIB_OBJECTS nntp.o newsrc.o"
+		need_socket="yes"
+	fi
+
+fi;
+
 
 
 
diff -udprP mutt-1.5.21/configure.ac mutt-nntp-sidebar/configure.ac
--- mutt-1.5.21/configure.ac	2010-08-24 09:34:21.000000000 -0700
+++ mutt-nntp-sidebar/configure.ac	2011-06-03 07:05:58.916289332 -0700
@@ -602,6 +602,14 @@ if test x"$need_imap" = xyes -o x"$need_
   MUTT_LIB_OBJECTS="$MUTT_LIB_OBJECTS bcache.o"
 fi
 
+AC_ARG_ENABLE(nntp, [  --enable-nntp              Enable NNTP support],
+[	if test x$enableval = xyes ; then
+		AC_DEFINE(USE_NNTP,1,[ Define if you want support for the NNTP protocol. ])
+		MUTT_LIB_OBJECTS="$MUTT_LIB_OBJECTS nntp.o newsrc.o"
+		need_socket="yes"
+	fi
+])
+
 dnl -- end socket dependencies --
 
 if test "$need_socket" = "yes"
diff -udprP mutt-1.5.21/curs_main.c mutt-nntp-sidebar/curs_main.c
--- mutt-1.5.21/curs_main.c	2011-06-03 07:06:32.516288483 -0700
+++ mutt-nntp-sidebar/curs_main.c	2011-06-03 07:05:58.942955998 -0700
@@ -22,6 +22,7 @@
 
 #include "mutt.h"
 #include "mutt_curses.h"
+#include "mx.h"
 #include "mutt_menu.h"
 #include "mailbox.h"
 #include "mapping.h"
@@ -40,6 +41,10 @@
 
 #include "mutt_crypt.h"
 
+#ifdef USE_NNTP
+#include "nntp.h"
+#endif
+
 
 #include <ctype.h>
 #include <stdlib.h>
@@ -415,12 +420,27 @@ static struct mapping_t IndexHelp[] = {
   { NULL,	 0 }
 };
 
+#ifdef USE_NNTP
+struct mapping_t IndexNewsHelp[] = {
+  { N_("Quit"),     OP_QUIT },
+  { N_("Del"),      OP_DELETE },
+  { N_("Undel"),    OP_UNDELETE },
+  { N_("Save"),     OP_SAVE },
+  { N_("Post"),     OP_POST },
+  { N_("Followup"), OP_FOLLOWUP },
+  { N_("Catchup"),  OP_CATCHUP },
+  { N_("Help"),     OP_HELP },
+  { NULL }
+};
+#endif
+
 /* This function handles the message index window as well as commands returned
  * from the pager (MENU_PAGER).
  */
 int mutt_index_menu (void)
 {
   char buf[LONG_STRING], helpstr[LONG_STRING];
+  int flags;
   int op = OP_NULL;
   int done = 0;                /* controls when to exit the "event" loop */
   int i = 0, j;
@@ -441,7 +461,11 @@ int mutt_index_menu (void)
   menu->make_entry = index_make_entry;
   menu->color = index_color;
   menu->current = ci_first_message ();
-  menu->help = mutt_compile_help (helpstr, sizeof (helpstr), MENU_MAIN, IndexHelp);
+  menu->help = mutt_compile_help (helpstr, sizeof (helpstr), MENU_MAIN,
+#ifdef USE_NNTP
+	(Context && (Context->magic == M_NNTP)) ? IndexNewsHelp :
+#endif
+	IndexHelp);
 
   if (!attach_msg)
     mutt_buffy_check(1); /* force the buffy check after we enter the folder */
@@ -692,6 +716,9 @@ int mutt_index_menu (void)
       mutt_curs_set (1);	/* fallback from the pager */
     }
 
+#ifdef USE_NNTP
+    unset_option (OPTNEWS);	/* for any case */
+#endif
     switch (op)
     {
 
@@ -742,6 +769,120 @@ int mutt_index_menu (void)
 	menu_current_bottom (menu);
 	break;
 
+#ifdef USE_NNTP
+      case OP_GET_MESSAGE:
+      case OP_GET_PARENT:
+	CHECK_MSGCOUNT;
+	if (Context->magic == M_NNTP)
+	{
+	  HEADER *h;
+
+	  if (op == OP_GET_MESSAGE)
+	  {
+	    buf[0] = 0;
+	    if (mutt_get_field (_("Enter Message-Id: "), buf, sizeof (buf), 0) != 0
+		  || !buf[0])
+	      break;
+	  }
+	  else
+	  {
+	    LIST *ref = CURHDR->env->references;
+	    if (!ref)
+	    {
+	      mutt_error _("Article has no parent reference!");
+	      break;
+	    }
+	    strfcpy (buf, ref->data, sizeof (buf));
+	  }
+	  if (!Context->id_hash)
+	    Context->id_hash = mutt_make_id_hash (Context);
+	  if ((h = hash_find (Context->id_hash, buf)))
+	  {
+	    if (h->virtual != -1)
+	    {
+	      menu->current = h->virtual;
+	      menu->redraw = REDRAW_MOTION_RESYNCH;
+	    }
+	    else if (h->collapsed)
+	    {
+	      mutt_uncollapse_thread (Context, h);
+	      mutt_set_virtual (Context);
+	      menu->current = h->virtual;
+	      menu->redraw = REDRAW_MOTION_RESYNCH;
+	    }
+	    else
+	      mutt_error _("Message not visible in limited view.");
+	  }
+	  else
+	  {
+	    if (nntp_check_msgid (Context, buf) == 0)
+	    {
+	      h = Context->hdrs[Context->msgcount-1];
+	      mutt_sort_headers (Context, 0);
+	      menu->current = h->virtual;
+	      menu->redraw = REDRAW_FULL;
+	    }
+	    else
+	      mutt_error (_("Article %s not found on server"), buf); 
+	  }
+	}
+	break;
+
+      case OP_GET_CHILDREN:
+      case OP_RECONSTRUCT_THREAD:
+	CHECK_MSGCOUNT;
+	if (Context->magic == M_NNTP)
+	{
+	  HEADER *h;
+	  int old = CURHDR->index, i;
+
+	  if (!CURHDR->env->message_id)
+	  {
+	    mutt_error _("No Message-Id. Unable to perform operation");
+	    break;
+	  }
+
+	  if (!Context->id_hash)
+	    Context->id_hash = mutt_make_id_hash (Context);
+	  strfcpy (buf, CURHDR->env->message_id, sizeof (buf));
+
+	  if (op == OP_RECONSTRUCT_THREAD)
+	  {
+	    LIST *ref = CURHDR->env->references;
+	    while (ref)
+	    {
+	      nntp_check_msgid (Context, ref->data);
+	      /* the last msgid in References is the root message */
+	      if (!ref->next)
+		strfcpy (buf, ref->data, sizeof (buf));
+	      ref = ref->next;
+	    }
+	  }
+	  mutt_message _("Check for children of message...");
+	  if (nntp_check_children (Context, buf) == 0)
+	  {
+	    mutt_sort_headers (Context, (op == OP_RECONSTRUCT_THREAD));
+	    h = hash_find (Context->id_hash, buf);
+	    /* if the root message was retrieved, move to it */
+	    if (h)
+	      menu->current = h->virtual;
+	    else /* try to restore old position */
+	      for (i = 0; i < Context->msgcount; i++)
+		if (Context->hdrs[i]->index == old)
+		{
+		  menu->current = Context->hdrs[i]->virtual;
+		  /* As an added courtesy, recenter the menu
+		   * with the current entry at the middle of the screen */
+		  menu_check_recenter (menu);
+		  menu_current_middle (menu);
+		}
+	  }
+	  menu->redraw = REDRAW_FULL;
+	  mutt_clear_error ();
+	}
+	break;
+#endif
+
       case OP_JUMP:
 
 	CHECK_MSGCOUNT;
@@ -838,11 +979,33 @@ int mutt_index_menu (void)
         break;
 
       case OP_MAIN_LIMIT:
+      case OP_TOGGLE_READ:
 
 	CHECK_IN_MAILBOX;
 	menu->oldcurrent = (Context->vcount && menu->current >= 0 && menu->current < Context->vcount) ?
 		CURHDR->index : -1;
-	if (mutt_pattern_func (M_LIMIT, _("Limit to messages matching: ")) == 0)
+	if (op == OP_TOGGLE_READ)
+	{
+	  char buf[LONG_STRING];
+
+	  if (!Context->pattern || strncmp (Context->pattern, "!~R!~D~s", 8) != 0)
+	  {
+	    snprintf (buf, sizeof (buf), "!~R!~D~s%s",
+		      Context->pattern ? Context->pattern : ".*");
+	    set_option (OPTHIDEREAD);
+	  }
+	  else
+	  {
+	    strfcpy (buf, Context->pattern + 8, sizeof(buf));
+	    if (!*buf || strncmp (buf, ".*", 2) == 0)
+	      snprintf (buf, sizeof(buf), "~A");
+	    unset_option (OPTHIDEREAD);
+	  }
+	  FREE (&Context->pattern);
+	  Context->pattern = safe_strdup (buf);
+	}
+	if ((op == OP_TOGGLE_READ && mutt_pattern_func (M_LIMIT, NULL) == 0) ||
+	    mutt_pattern_func (M_LIMIT, _("Limit to messages matching: ")) == 0)
 	{
 	  if (menu->oldcurrent >= 0)
 	  {
@@ -1082,15 +1245,22 @@ int mutt_index_menu (void)
       case OP_SIDEBAR_OPEN:
       case OP_MAIN_CHANGE_FOLDER:
       case OP_MAIN_NEXT_UNREAD_MAILBOX:
-
-	if (attach_msg)
-	  op = OP_MAIN_CHANGE_FOLDER_READONLY;
-
-	/* fallback to the readonly case */
-
       case OP_MAIN_CHANGE_FOLDER_READONLY:
+#ifdef USE_NNTP
+      case OP_MAIN_CHANGE_GROUP:
+      case OP_MAIN_CHANGE_GROUP_READONLY:
+	unset_option (OPTNEWS);
+#endif
+	if (attach_msg || option (OPTREADONLY) ||
+#ifdef USE_NNTP
+	    op == OP_MAIN_CHANGE_GROUP_READONLY ||
+#endif
+	    op == OP_MAIN_CHANGE_FOLDER_READONLY)
+	  flags = M_READONLY;
+	else
+	  flags = 0;
 
-        if ((op == OP_MAIN_CHANGE_FOLDER_READONLY) || option (OPTREADONLY))
+	if (flags)
           cp = _("Open mailbox in read-only mode");
         else
           cp = _("Open mailbox");
@@ -1109,6 +1279,21 @@ int mutt_index_menu (void)
 	}
 	else
 	{
+#ifdef USE_NNTP
+	  if (op == OP_MAIN_CHANGE_GROUP ||
+	      op == OP_MAIN_CHANGE_GROUP_READONLY)
+	  {
+	    set_option (OPTNEWS);
+	    if (!(CurrentNewsSrv = mutt_select_newsserver (NewsServer)))
+	      break;
+	    if (flags)
+	      cp = _("Open newsgroup in read-only mode");
+	    else
+	      cp = _("Open newsgroup");
+	    nntp_buffy (buf);
+	  }
+	  else
+#endif
 	  mutt_buffy (buf, sizeof (buf));
 
           if ( op == OP_SIDEBAR_OPEN ) {
@@ -1132,6 +1317,14 @@ int mutt_index_menu (void)
 	  }
 	}
 
+#ifdef USE_NNTP
+	if (option (OPTNEWS))
+	{
+	  unset_option (OPTNEWS);
+	  nntp_expand_path (buf, sizeof (buf), &CurrentNewsSrv->conn->account);
+	}
+	else
+#endif
 	mutt_expand_path (buf, sizeof (buf));
         set_curbuffy(buf);
 	if (mx_get_magic (buf) <= 0)
@@ -1174,15 +1367,18 @@ int mutt_index_menu (void)
 	CurrentMenu = MENU_MAIN;
 	mutt_folder_hook (buf);
 
-	if ((Context = mx_open_mailbox (buf,
-					(option (OPTREADONLY) || op == OP_MAIN_CHANGE_FOLDER_READONLY) ?
-					M_READONLY : 0, NULL)) != NULL)
+	if ((Context = mx_open_mailbox (buf, flags, NULL)) != NULL)
 	{
 	  menu->current = ci_first_message ();
 	}
 	else
 	  menu->current = 0;
 
+#ifdef USE_NNTP
+	/* mutt_buffy_check() must be done with mail-reader mode! */
+	menu->help = mutt_compile_help (helpstr, sizeof (helpstr), MENU_MAIN,
+	  (Context && (Context->magic == M_NNTP)) ? IndexNewsHelp : IndexHelp);
+#endif
 	mutt_clear_error ();
 	mutt_buffy_check(1); /* force the buffy check after we have changed
 			      the folder */
@@ -1555,6 +1751,15 @@ int mutt_index_menu (void)
 	CHECK_READONLY;
 	CHECK_ACL(M_ACL_WRITE, _("flag message"));
 
+#ifdef USE_NNTP
+	if (Context->magic == M_NNTP)
+	{
+	  mutt_flushinp ();
+	  mutt_error _("Can't change 'important' flag on NNTP server.");
+	  break;
+	}
+#endif
+
         if (tag)
         {
 	  for (j = 0; j < Context->vcount; j++)
@@ -1902,6 +2107,17 @@ int mutt_index_menu (void)
 	}
 	break;
 
+#ifdef USE_NNTP
+      case OP_CATCHUP:
+	if (Context && Context->magic == M_NNTP)
+	{
+	  if (mutt_newsgroup_catchup (CurrentNewsSrv,
+		((NNTP_DATA *)Context->data)->group))
+	    menu->redraw = REDRAW_INDEX | REDRAW_STATUS;
+	}
+	break;
+#endif
+
       case OP_DISPLAY_ADDRESS:
 
 	CHECK_MSGCOUNT;
@@ -2029,6 +2245,15 @@ int mutt_index_menu (void)
 	  menu->redraw = (tag ? REDRAW_INDEX : REDRAW_CURRENT) | REDRAW_STATUS;
 	}
 #endif
+  
+#ifdef USE_NNTP
+	if (Context->magic == M_NNTP)
+	{
+	  mutt_flushinp ();
+	  mutt_error _("Can't edit message on newsserver.");
+	  break;
+	}
+#endif
 
 	MAYBE_REDRAW (menu->redraw);
 	break;
@@ -2106,6 +2331,41 @@ int mutt_index_menu (void)
         menu->redraw = REDRAW_FULL;
         break;
 
+#ifdef USE_NNTP
+      case OP_FOLLOWUP:
+      case OP_FORWARD_TO_GROUP:
+
+	CHECK_MSGCOUNT;
+	CHECK_VISIBLE;
+
+      case OP_POST:
+
+	CHECK_ATTACH;
+	if (op != OP_FOLLOWUP || !CURHDR->env->followup_to ||
+	    mutt_strcasecmp (CURHDR->env->followup_to, "poster") ||
+	    query_quadoption (OPT_FOLLOWUPTOPOSTER,_("Reply by mail as poster prefers?")) != M_YES)
+	{
+	  if (Context && Context->magic == M_NNTP &&
+	      !((NNTP_DATA *)Context->data)->allowed &&
+	      query_quadoption (OPT_TOMODERATED, _("Posting to this group not allowed, may be moderated. Continue?")) != M_YES)
+	    break;
+	  if (op == OP_POST)
+	    ci_send_message (SENDNEWS, NULL, NULL, Context, NULL);
+	  else
+	  {
+	    CHECK_MSGCOUNT;
+	    if (op == OP_FOLLOWUP)
+	      ci_send_message (SENDNEWS|SENDREPLY, NULL, NULL, Context,
+			       tag ? NULL : CURHDR);
+	    else
+	      ci_send_message (SENDNEWS|SENDFORWARD, NULL, NULL, Context,
+			       tag ? NULL : CURHDR);
+	  }
+	  menu->redraw = REDRAW_FULL;
+	  break;
+	}
+#endif
+
       case OP_REPLY:
 
 	CHECK_ATTACH;
@@ -2181,6 +2441,12 @@ int mutt_index_menu (void)
 	CHECK_READONLY;
 	CHECK_ACL(M_ACL_DELETE, _("undelete message(s)"));
 
+#ifdef USE_NNTP
+	/* Close all open NNTP connections */
+	if (!attach_msg)
+	  nntp_logout_all ();
+#endif
+
 	rc = mutt_thread_set_flag (CURHDR, M_DELETE, 0,
 				   op == OP_UNDELETE_THREAD ? 0 : 1);
 
diff -udprP mutt-1.5.21/curs_main.c.orig mutt-nntp-sidebar/curs_main.c.orig
--- mutt-1.5.21/curs_main.c.orig	2010-09-13 10:19:55.000000000 -0700
+++ mutt-nntp-sidebar/curs_main.c.orig	2011-06-03 07:05:58.942955998 -0700
@@ -26,7 +26,9 @@
 #include "mailbox.h"
 #include "mapping.h"
 #include "sort.h"
+#include "buffy.h"
 #include "mx.h"
+#include "sidebar.h"
 
 #ifdef USE_POP
 #include "pop.h"
@@ -519,8 +521,12 @@ int mutt_index_menu (void)
        menu->redraw |= REDRAW_STATUS;
      if (do_buffy_notify)
      {
-       if (mutt_buffy_notify () && option (OPTBEEPNEW))
- 	beep ();
+       if (mutt_buffy_notify ())
+       {
+         menu->redraw |= REDRAW_FULL;
+         if (option (OPTBEEPNEW))
+           beep ();
+       }
      }
      else
        do_buffy_notify = 1;
@@ -532,6 +538,7 @@ int mutt_index_menu (void)
     if (menu->redraw & REDRAW_FULL)
     {
       menu_redraw_full (menu);
+      draw_sidebar(menu->menu);
       mutt_show_error ();
     }
 
@@ -554,10 +561,13 @@ int mutt_index_menu (void)
 
       if (menu->redraw & REDRAW_STATUS)
       {
+        DrawFullLine = 1;
 	menu_status_line (buf, sizeof (buf), menu, NONULL (Status));
+        DrawFullLine = 0;
 	CLEARLINE (option (OPTSTATUSONTOP) ? 0 : LINES-2);
 	SETCOLOR (MT_COLOR_STATUS);
         BKGDSET (MT_COLOR_STATUS);
+        set_buffystats(Context);
 	mutt_paddstr (COLS, buf);
 	SETCOLOR (MT_COLOR_NORMAL);
         BKGDSET (MT_COLOR_NORMAL);
@@ -571,7 +581,7 @@ int mutt_index_menu (void)
 	menu->oldcurrent = -1;
 
       if (option (OPTARROWCURSOR))
-	move (menu->current - menu->top + menu->offset, 2);
+	move (menu->current - menu->top + menu->offset, SidebarWidth + 2);
       else if (option (OPTBRAILLEFRIENDLY))
 	move (menu->current - menu->top + menu->offset, 0);
       else
@@ -1069,6 +1079,7 @@ int mutt_index_menu (void)
 	  menu->redraw = REDRAW_FULL;
 	break;
 
+      case OP_SIDEBAR_OPEN:
       case OP_MAIN_CHANGE_FOLDER:
       case OP_MAIN_NEXT_UNREAD_MAILBOX:
 
@@ -1100,7 +1111,11 @@ int mutt_index_menu (void)
 	{
 	  mutt_buffy (buf, sizeof (buf));
 
-	  if (mutt_enter_fname (cp, buf, sizeof (buf), &menu->redraw, 1) == -1)
+          if ( op == OP_SIDEBAR_OPEN ) {
+              if(!CurBuffy)
+                break;
+            strncpy( buf, CurBuffy->path, sizeof(buf) );  
+	    } else if (mutt_enter_fname (cp, buf, sizeof (buf), &menu->redraw, 1) == -1)
 	  {
 	    if (menu->menu == MENU_PAGER)
 	    {
@@ -1118,6 +1133,7 @@ int mutt_index_menu (void)
 	}
 
 	mutt_expand_path (buf, sizeof (buf));
+        set_curbuffy(buf);
 	if (mx_get_magic (buf) <= 0)
 	{
 	  mutt_error (_("%s is not a mailbox."), buf);
@@ -2208,6 +2224,12 @@ int mutt_index_menu (void)
 	mutt_what_key();
 	break;
 
+      case OP_SIDEBAR_SCROLL_UP:
+      case OP_SIDEBAR_SCROLL_DOWN:
+      case OP_SIDEBAR_NEXT:
+      case OP_SIDEBAR_PREV:
+        scroll_sidebar(op, menu->menu);
+        break;
       default:
 	if (menu->menu == MENU_MAIN)
 	  km_error_key (MENU_MAIN);
diff -udprP mutt-1.5.21/doc/Muttrc mutt-nntp-sidebar/doc/Muttrc
--- mutt-1.5.21/doc/Muttrc	2010-09-15 10:07:19.000000000 -0700
+++ mutt-nntp-sidebar/doc/Muttrc	2011-06-03 07:05:58.936289332 -0700
@@ -281,6 +281,28 @@ attachments   -I message/external-body
 # of the value as shown above if included.
 # 
 # 
+# set ask_follow_up=no
+#
+# Name: ask_follow_up
+# Type: boolean
+# Default: no
+# 
+# 
+# If set, Mutt will prompt you for follow-up groups before editing
+# the body of an outgoing message.
+# 
+# 
+# set ask_x_comment_to=no
+#
+# Name: ask_x_comment_to
+# Type: boolean
+# Default: no
+# 
+# 
+# If set, Mutt will prompt you for x-comment-to field before editing
+# the body of an outgoing message.
+# 
+# 
 # set attach_format="%u%D%I %t%4n %T%.40d%> [%.7m/%.10M, %.6e%?C?, %C?, %s] "
 #
 # Name: attach_format
@@ -466,6 +488,17 @@ attachments   -I message/external-body
 # set certificate_file=~/.mutt/certificates
 # 
 # 
+# set catchup_newsgroup=ask-yes
+#
+# Name: catchup_newsgroup
+# Type: quadoption
+# Default: ask-yes
+# 
+# 
+# If this variable is set, Mutt will mark all articles in newsgroup
+# as read when you quit the newsgroup (catchup newsgroup).
+# 
+# 
 # set charset=""
 #
 # Name: charset
@@ -1122,6 +1155,19 @@ attachments   -I message/external-body
 # of the same email for you.
 # 
 # 
+# set followup_to_poster=ask-yes
+#
+# Name: followup_to_poster
+# Type: quadoption
+# Default: ask-yes
+# 
+# 
+# If this variable is set and the keyword "poster" is present in
+# Followup-To header, follow-up to newsgroup function is not
+# permitted.  The message will be mailed to the submitter of the
+# message via mail.
+# 
+# 
 # set force_name=no
 #
 # Name: force_name
@@ -1232,6 +1278,28 @@ attachments   -I message/external-body
 # ``Franklin'' to ``Franklin, Steve''.
 # 
 # 
+# set group_index_format="%4C %M%N %5s  %-45.45f %d"
+#
+# Name: group_index_format
+# Type: string
+# Default: "%4C %M%N %5s  %-45.45f %d"
+# 
+# 
+# This variable allows you to customize the newsgroup browser display to
+# your personal taste.  This string is similar to ``index_format'', but
+# has its own set of printf()-like sequences:
+# 
+# %C      current newsgroup number
+# %d      description of newsgroup (becomes from server)
+# %f      newsgroup name
+# %M      - if newsgroup not allowed for direct post (moderated for example)
+# %N      N if newsgroup is new, u if unsubscribed, blank otherwise
+# %n      number of new articles in newsgroup
+# %s      number of unread articles in newsgroup
+# %>X     right justify the rest of the string and pad with character "X"
+# %|X     pad to the end of the line with character "X"
+# 
+# 
 # set hdrs=yes
 #
 # Name: hdrs
@@ -1780,6 +1848,7 @@ attachments   -I message/external-body
 # %E      number of messages in current thread
 # %f      sender (address + real name), either From: or Return-Path:
 # %F      author name, or recipient name if the message is from you
+# %g      newsgroup name (if compiled with nntp support)
 # %H      spam attribute(s) of this message
 # %i      message-id of the current message
 # %l      number of lines in the message (does not work with maildir,
@@ -1795,12 +1864,14 @@ attachments   -I message/external-body
 #         stashed the message: list name or recipient name
 #         if not sent to a list
 # %P      progress indicator for the built-in pager (how much of the file has been displayed)
+# %R      ``x-comment-to:'' field (if present and compiled with nntp support)
 # %s      subject of the message
 # %S      status of the message (``N''/``D''/``d''/``!''/``r''/*)
 # %t      ``To:'' field (recipients)
 # %T      the appropriate character from the $to_chars string
 # %u      user (login) name of the author
 # %v      first name of the author, or the recipient if the message is from you
+# %W      name of organization of author (``organization:'' field)
 # %X      number of attachments
 #         (please see the ``attachments'' section for possible speed effects)
 # %y      ``X-Label:'' field, if present
@@ -1836,6 +1907,22 @@ attachments   -I message/external-body
 # ``save-hook'', ``fcc-hook'' and ``fcc-save-hook'', too.
 # 
 # 
+# set inews=""
+#
+# Name: inews
+# Type: path
+# Default: ""
+# 
+# 
+# If set, specifies the program and arguments used to deliver news posted
+# by Mutt.  Otherwise, mutt posts article using current connection to
+# news server.  The following printf-style sequence is understood:
+# 
+# %s      newsserver name
+# 
+# Example: set inews="/usr/local/bin/inews -hS"
+# 
+# 
 # set ispell="ispell"
 #
 # Name: ispell
@@ -2205,6 +2292,18 @@ attachments   -I message/external-body
 # be attached to the newly composed message if this option is set.
 # 
 # 
+# set mime_subject=yes
+#
+# Name: mime_subject
+# Type: boolean
+# Default: yes
+# 
+# 
+# If unset, 8-bit ``subject:'' line in article header will not be
+# encoded according to RFC2047 to base64.  This is useful when message
+# is Usenet article, because MIME for news is nonstandard feature.
+# 
+# 
 # set mix_entry_format="%4n %c %-16s %a"
 #
 # Name: mix_entry_format
@@ -2271,6 +2370,118 @@ attachments   -I message/external-body
 # See also $read_inc, $write_inc and $net_inc.
 # 
 # 
+# set news_cache_dir="~/.mutt"
+#
+# Name: news_cache_dir
+# Type: path
+# Default: "~/.mutt"
+# 
+# 
+# This variable pointing to directory where Mutt will save cached news
+# articles headers in. If unset, headers will not be saved at all
+# and will be reloaded each time when you enter to newsgroup.
+# 
+# 
+# set news_server=""
+#
+# Name: news_server
+# Type: string
+# Default: ""
+# 
+# 
+# This variable specifies domain name or address of NNTP server. It
+# defaults to the newsserver specified in the environment variable
+# $NNTPSERVER or contained in the file /etc/nntpserver.  You can also
+# specify username and an alternative port for each newsserver, ie:
+# 
+# [news[s]://][username[:password]@]newsserver[:port]
+# 
+# 
+# set newsrc="~/.newsrc"
+#
+# Name: newsrc
+# Type: path
+# Default: "~/.newsrc"
+# 
+# 
+# The file, containing info about subscribed newsgroups - names and
+# indexes of read articles.  The following printf-style sequence
+# is understood:
+# 
+# %s      newsserver name
+# 
+# 
+# set nntp_context=1000
+#
+# Name: nntp_context
+# Type: number
+# Default: 1000
+# 
+# 
+# This variable defines number of articles which will be in index when
+# newsgroup entered.  If active newsgroup have more articles than this
+# number, oldest articles will be ignored.  Also controls how many
+# articles headers will be saved in cache when you quit newsgroup.
+# 
+# 
+# set nntp_load_description=yes
+#
+# Name: nntp_load_description
+# Type: boolean
+# Default: yes
+# 
+# 
+# This variable controls whether or not descriptions for each newsgroup
+# must be loaded when newsgroup is added to list (first time list
+# loading or new newsgroup adding).
+# 
+# 
+# set nntp_user=""
+#
+# Name: nntp_user
+# Type: string
+# Default: ""
+# 
+# 
+# Your login name on the NNTP server.  If unset and NNTP server requires
+# authentification, Mutt will prompt you for your account name when you
+# connect to newsserver.
+# 
+# 
+# set nntp_pass=""
+#
+# Name: nntp_pass
+# Type: string
+# Default: ""
+# 
+# 
+# Your password for NNTP account.
+# 
+# 
+# set nntp_poll=60
+#
+# Name: nntp_poll
+# Type: number
+# Default: 60
+# 
+# 
+# The time in seconds until any operations on newsgroup except post new
+# article will cause recheck for new news.  If set to 0, Mutt will
+# recheck newsgroup on each operation in index (stepping, read article,
+# etc.).
+# 
+# 
+# set nntp_reconnect=ask-yes
+#
+# Name: nntp_reconnect
+# Type: quadoption
+# Default: ask-yes
+# 
+# 
+# Controls whether or not Mutt will try to reconnect to newsserver when
+# connection lost.
+# 
+# 
 # set pager="builtin"
 #
 # Name: pager
@@ -2986,6 +3197,19 @@ attachments   -I message/external-body
 # string after the inclusion of a message which is being replied to.
 # 
 # 
+# set post_moderated=ask-yes
+#
+# Name: post_moderated
+# Type: quadoption
+# Default: ask-yes
+# 
+# 
+# If set to yes, Mutt will post article to newsgroup that have
+# not permissions to posting (e.g. moderated).  Note: if newsserver
+# does not support posting to that newsgroup or totally read-only, that
+# posting will not have an effect.
+# 
+# 
 # set postpone=ask-yes
 #
 # Name: postpone
@@ -3563,6 +3787,41 @@ attachments   -I message/external-body
 # shell from /etc/passwd is used.
 # 
 # 
+# set save_unsubscribed=no
+#
+# Name: save_unsubscribed
+# Type: boolean
+# Default: no
+# 
+# 
+# When set, info about unsubscribed newsgroups will be saved into
+# ``newsrc'' file and into cache.
+# 
+# 
+# set show_new_news=yes
+#
+# Name: show_new_news
+# Type: boolean
+# Default: yes
+# 
+# 
+# If set, newsserver will be asked for new newsgroups on entering
+# the browser.  Otherwise, it will be done only once for a newsserver.
+# Also controls whether or not number of new articles of subscribed
+# newsgroups will be then checked.
+# 
+# 
+# set show_only_unread=no
+#
+# Name: show_only_unread
+# Type: boolean
+# Default: no
+# 
+# 
+# If set, only subscribed newsgroups that contain unread articles
+# will be displayed in browser.
+# 
+# 
 # set sig_dashes=yes
 #
 # Name: sig_dashes
@@ -4785,3 +5044,14 @@ attachments   -I message/external-body
 # ``tuning'' section of the manual for performance considerations.
 # 
 # 
+# set x_comment_to=no
+#
+# Name: x_comment_to
+# Type: boolean
+# Default: no
+# 
+# 
+# If set, Mutt will add ``X-Comment-To:'' field (that contains full
+# name of original article author) to article that followuped to newsgroup.
+# 
+# 
diff -udprP mutt-1.5.21/doc/manual.xml.head mutt-nntp-sidebar/doc/manual.xml.head
--- mutt-1.5.21/doc/manual.xml.head	2010-08-24 09:34:21.000000000 -0700
+++ mutt-nntp-sidebar/doc/manual.xml.head	2011-06-03 07:05:58.936289332 -0700
@@ -1611,6 +1611,22 @@ fo-table</literal> for details.
 
 </sect2>
 
+<sect2>
+<title>Reading news via NNTP</title>
+
+<para>
+If compiled with <emphasis>--enable-nntp</emphasis> option, Mutt can
+read news from newsserver via NNTP.  You can open a newsgroup with
+function ``change-newsgroup'' (default: ``i'').  Default newsserver
+can be obtained from <emphasis>NNTPSERVER</emphasis> environment
+variable.  Like other news readers, info about subscribed newsgroups
+is saved in file by <link linkend="newsrc">&dollar;newsrc</link>
+variable.  Article headers are cached and can be loaded from file when
+newsgroup entered instead loading from newsserver.
+</para>
+
+</sect2>
+
 </sect1>
 
 <sect1 id="forwarding-mail">
diff -udprP mutt-1.5.21/doc/mutt.man mutt-nntp-sidebar/doc/mutt.man
--- mutt-1.5.21/doc/mutt.man	2010-08-24 09:34:21.000000000 -0700
+++ mutt-nntp-sidebar/doc/mutt.man	2011-06-03 07:05:58.936289332 -0700
@@ -23,8 +23,8 @@ mutt \- The Mutt Mail User Agent
 .SH SYNOPSIS
 .PP
 .B mutt
-[\-nRyzZ]
-[\-e \fIcmd\fP] [\-F \fIfile\fP] [\-m \fItype\fP] [\-f \fIfile\fP]
+[\-GnRyzZ]
+[\-e \fIcmd\fP] [\-F \fIfile\fP] [\-g \fIserver\fP] [\-m \fItype\fP] [\-f \fIfile\fP]
 .PP
 .B mutt 
 [\-nx] 
@@ -101,6 +101,10 @@ files.
 Specify which mailbox to load.
 .IP "-F \fImuttrc\fP"
 Specify an initialization file to read instead of ~/.muttrc
+.IP "-g \fIserver\fP"
+Start Mutt with a listing of subscribed newsgroups at specified newsserver.
+.IP "-G"
+Start Mutt with a listing of subscribed newsgroups.
 .IP "-h"
 Display help.
 .IP "-H \fIdraft\fP"
diff -udprP mutt-1.5.21/functions.h mutt-nntp-sidebar/functions.h
--- mutt-1.5.21/functions.h	2011-06-03 07:06:32.519621817 -0700
+++ mutt-nntp-sidebar/functions.h	2011-06-03 07:05:58.942955998 -0700
@@ -88,6 +88,10 @@ struct binding_t OpMain[] = { /* map: in
   { "break-thread",		OP_MAIN_BREAK_THREAD,		"#" },
   { "change-folder",		OP_MAIN_CHANGE_FOLDER,		"c" },
   { "change-folder-readonly",	OP_MAIN_CHANGE_FOLDER_READONLY,	"\033c" },
+#ifdef USE_NNTP
+  { "change-newsgroup",		OP_MAIN_CHANGE_GROUP,		"i" },
+  { "change-newsgroup-readonly",OP_MAIN_CHANGE_GROUP_READONLY,	"\033i" },
+#endif
   { "next-unread-mailbox",	OP_MAIN_NEXT_UNREAD_MAILBOX,    NULL },
   { "collapse-thread",		OP_MAIN_COLLAPSE_THREAD,	"\033v" },
   { "collapse-all",		OP_MAIN_COLLAPSE_ALL,		"\033V" },
@@ -101,7 +105,15 @@ struct binding_t OpMain[] = { /* map: in
   { "edit",			OP_EDIT_MESSAGE,		"e" },
   { "edit-type",		OP_EDIT_TYPE,			"\005" },
   { "forward-message",		OP_FORWARD_MESSAGE,		"f" },
-  { "flag-message",		OP_FLAG_MESSAGE,		"F" },
+#ifdef USE_NNTP
+  { "forward-to-group",		OP_FORWARD_TO_GROUP,		"\033F" },
+  { "followup-message",		OP_FOLLOWUP,			"F" },
+  { "get-children",		OP_GET_CHILDREN,		NULL },
+  { "get-message",		OP_GET_MESSAGE,			"\007" },
+  { "get-parent",		OP_GET_PARENT,			"\033G" },
+  { "reconstruct-thread",	OP_RECONSTRUCT_THREAD,		NULL },
+#endif
+  { "flag-message",		OP_FLAG_MESSAGE,		"\033f" },
   { "group-reply",		OP_GROUP_REPLY,			"g" },
 #ifdef USE_POP
   { "fetch-mail",		OP_MAIN_FETCH_MAIL,		"G" },
@@ -128,6 +140,9 @@ struct binding_t OpMain[] = { /* map: in
   { "sort-mailbox",		OP_SORT,			"o" },
   { "sort-reverse",		OP_SORT_REVERSE,		"O" },
   { "print-message",		OP_PRINT,			"p" },
+#ifdef USE_NNTP
+  { "post-message",		OP_POST,			"P" },
+#endif
   { "previous-thread",		OP_MAIN_PREV_THREAD,		"\020" },
   { "previous-subthread",	OP_MAIN_PREV_SUBTHREAD,		"\033p" },
   { "recall-message",		OP_RECALL_MESSAGE,		"R" },
@@ -147,6 +162,10 @@ struct binding_t OpMain[] = { /* map: in
   { "show-version",		OP_VERSION,			"V" },
   { "set-flag",			OP_MAIN_SET_FLAG,		"w" },
   { "clear-flag",		OP_MAIN_CLEAR_FLAG,		"W" },
+  { "toggle-read",		OP_TOGGLE_READ,			"X" },
+#ifdef USE_NNTP
+  { "catchup",			OP_CATCHUP,			"y" },
+#endif
   { "display-message",		OP_DISPLAY_MESSAGE,		M_ENTER_S },
   { "buffy-list",		OP_BUFFY_LIST,			"." },
   { "sync-mailbox",		OP_MAIN_SYNC_FOLDER,		"$" },
@@ -158,7 +177,7 @@ struct binding_t OpMain[] = { /* map: in
   { "previous-new-then-unread",	OP_MAIN_PREV_NEW_THEN_UNREAD,	"\033\t" },
   { "next-unread",		OP_MAIN_NEXT_UNREAD,		NULL },
   { "previous-unread",		OP_MAIN_PREV_UNREAD,		NULL },
-  { "parent-message",		OP_MAIN_PARENT_MESSAGE,		"P" },
+  { "parent-message",		OP_MAIN_PARENT_MESSAGE,		NULL },
 
 
   { "extract-keys",		OP_EXTRACT_KEYS,		"\013" },
@@ -183,6 +202,10 @@ struct binding_t OpPager[] = { /* map: p
   { "bounce-message",	OP_BOUNCE_MESSAGE,		"b" },
   { "change-folder",	OP_MAIN_CHANGE_FOLDER,		"c" },
   { "change-folder-readonly",	OP_MAIN_CHANGE_FOLDER_READONLY,	"\033c" },
+#ifdef USE_NNTP
+  { "change-newsgroup",		OP_MAIN_CHANGE_GROUP,		"i" },
+  { "change-newsgroup-readonly",OP_MAIN_CHANGE_GROUP_READONLY,	"\033i" },
+#endif
   { "next-unread-mailbox",	OP_MAIN_NEXT_UNREAD_MAILBOX, NULL },
   { "copy-message",	OP_COPY_MESSAGE,		"C" },
   { "decode-copy",	OP_DECODE_COPY,			"\033C" },
@@ -193,8 +216,12 @@ struct binding_t OpPager[] = { /* map: p
   { "clear-flag",       OP_MAIN_CLEAR_FLAG,		"W" },
   { "edit",		OP_EDIT_MESSAGE,		"e" },
   { "edit-type",	OP_EDIT_TYPE,			"\005" },
+#ifdef USE_NNTP
+  { "followup-message",	OP_FOLLOWUP,			"F" },
+  { "forward-to-group",	OP_FORWARD_TO_GROUP,		"\033F" },
+#endif
   { "forward-message",	OP_FORWARD_MESSAGE,		"f" },
-  { "flag-message",	OP_FLAG_MESSAGE,		"F" },
+  { "flag-message",	OP_FLAG_MESSAGE,		"\033f" },
   { "group-reply",	OP_GROUP_REPLY,			"g" },
 #ifdef USE_IMAP
   { "imap-fetch-mail",  OP_MAIN_IMAP_FETCH,		NULL },
@@ -216,6 +243,9 @@ struct binding_t OpPager[] = { /* map: p
   { "sort-mailbox",	OP_SORT,			"o" },
   { "sort-reverse",	OP_SORT_REVERSE,		"O" },
   { "print-message",	OP_PRINT,			"p" },
+#ifdef USE_NNTP
+  { "post-message",	OP_POST,			"P" },
+#endif
   { "previous-thread",	OP_MAIN_PREV_THREAD,		"\020" },
   { "previous-subthread",OP_MAIN_PREV_SUBTHREAD,	"\033p" },
   { "quit",		OP_QUIT,			"Q" },
@@ -263,7 +293,7 @@ struct binding_t OpPager[] = { /* map: p
   { "half-down",	OP_HALF_DOWN,			NULL },
   { "previous-line",	OP_PREV_LINE,			NULL },
   { "bottom",		OP_PAGER_BOTTOM,		NULL },
-  { "parent-message",	OP_MAIN_PARENT_MESSAGE,		"P" },
+  { "parent-message",	OP_MAIN_PARENT_MESSAGE,		NULL },
 
 
 
@@ -289,6 +319,10 @@ struct binding_t OpAttach[] = { /* map:
   { "bounce-message",	OP_BOUNCE_MESSAGE,		"b" },
   { "display-toggle-weed",	OP_DISPLAY_HEADERS,	"h" },
   { "edit-type",	OP_EDIT_TYPE,			"\005" },
+#ifdef USE_NNTP
+  { "followup-message",	OP_FOLLOWUP,			"F" },
+  { "forward-to-group",	OP_FORWARD_TO_GROUP,		"\033F" },
+#endif
   { "print-entry",	OP_PRINT,			"p" },
   { "save-entry",	OP_SAVE,			"s" },
   { "pipe-entry",	OP_PIPE,			"|" },
@@ -314,6 +348,7 @@ struct binding_t OpAttach[] = { /* map:
 struct binding_t OpCompose[] = { /* map: compose */
   { "attach-file",	OP_COMPOSE_ATTACH_FILE,		"a" },
   { "attach-message",	OP_COMPOSE_ATTACH_MESSAGE,	"A" },
+  { "attach-news-message",OP_COMPOSE_ATTACH_NEWS_MESSAGE,"\033a" },
   { "edit-bcc",		OP_COMPOSE_EDIT_BCC,		"b" },
   { "edit-cc",		OP_COMPOSE_EDIT_CC,		"c" },
   { "copy-file",	OP_SAVE,			"C" },
@@ -333,6 +368,11 @@ struct binding_t OpCompose[] = { /* map:
   { "print-entry",	OP_PRINT,			"l" },
   { "edit-mime",	OP_COMPOSE_EDIT_MIME,		"m" },
   { "new-mime",		OP_COMPOSE_NEW_MIME,		"n" },
+#ifdef USE_NNTP
+  { "edit-newsgroups",	OP_COMPOSE_EDIT_NEWSGROUPS,	"N" },
+  { "edit-followup-to",	OP_COMPOSE_EDIT_FOLLOWUP_TO,	"o" },
+  { "edit-x-comment-to",OP_COMPOSE_EDIT_X_COMMENT_TO,	"x" },
+#endif
   { "postpone-message",	OP_COMPOSE_POSTPONE_MESSAGE,	"P" },
   { "edit-reply-to",	OP_COMPOSE_EDIT_REPLY_TO,	"r" },
   { "rename-file",	OP_COMPOSE_RENAME_FILE,		"R" },
@@ -384,14 +424,25 @@ struct binding_t OpBrowser[] = { /* map:
   { "select-new",	OP_BROWSER_NEW_FILE,	"N" },
   { "check-new",	OP_CHECK_NEW,		NULL },
   { "toggle-mailboxes", OP_TOGGLE_MAILBOXES, 	"\t" },
+#ifdef USE_NNTP
+  { "reload-active",	OP_LOAD_ACTIVE,		"g" },
+  { "subscribe-pattern", OP_SUBSCRIBE_PATTERN,	"S" },
+  { "unsubscribe-pattern", OP_UNSUBSCRIBE_PATTERN, "U" },
+  { "catchup",		OP_CATCHUP,		"y" },
+  { "uncatchup",	OP_UNCATCHUP,		"Y" },
+#endif
   { "view-file",	OP_BROWSER_VIEW_FILE,	" " },
   { "buffy-list",	OP_BUFFY_LIST,		"." },
 #ifdef USE_IMAP
   { "create-mailbox",   OP_CREATE_MAILBOX,      "C" },
   { "delete-mailbox",   OP_DELETE_MAILBOX,      "d" },
   { "rename-mailbox",   OP_RENAME_MAILBOX,      "r" },
+#endif
+#if defined USE_IMAP || defined USE_NNTP
   { "subscribe",	OP_BROWSER_SUBSCRIBE,	"s" },
   { "unsubscribe",	OP_BROWSER_UNSUBSCRIBE,	"u" },
+#endif
+#ifdef USE_IMAP
   { "toggle-subscribed", OP_BROWSER_TOGGLE_LSUB, "T" },
 #endif
   { NULL,		0,			NULL }
diff -udprP mutt-1.5.21/functions.h.orig mutt-nntp-sidebar/functions.h.orig
--- mutt-1.5.21/functions.h.orig	1969-12-31 17:00:00.000000000 -0700
+++ mutt-nntp-sidebar/functions.h.orig	2011-06-03 07:05:58.912955998 -0700
@@ -0,0 +1,467 @@
+/*
+ * Copyright (C) 1996-2000,2002 Michael R. Elkins <me@mutt.org>
+ * 
+ *     This program is free software; you can redistribute it and/or modify
+ *     it under the terms of the GNU General Public License as published by
+ *     the Free Software Foundation; either version 2 of the License, or
+ *     (at your option) any later version.
+ * 
+ *     This program is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ * 
+ *     You should have received a copy of the GNU General Public License
+ *     along with this program; if not, write to the Free Software
+ *     Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */ 
+
+/*
+ * This file contains the structures needed to parse ``bind'' commands, as
+ * well as the default bindings for each menu.
+ *
+ * Notes:
+ *
+ * - If you want to bind \n or \r, use M_ENTER_S so that it will work
+ * correctly under both ncurses and S-Lang
+ *
+ * - If you need to bind a control char, use the octal value because the \cX
+ * construct does not work at this level.
+ *
+ * - The magic "map:" comments define how the map will be called in the
+ * manual. Lines starting with "**" will be included in the manual.
+ *
+ */
+
+#ifdef _MAKEDOC
+# include "config.h"
+# include "doc/makedoc-defs.h"
+#endif
+
+struct binding_t OpGeneric[] = { /* map: generic */
+  /*
+  ** <para>
+  ** The <emphasis>generic</emphasis> menu is not a real menu, but specifies common functions
+  ** (such as movement) available in all menus except for <emphasis>pager</emphasis> and
+  ** <emphasis>editor</emphasis>.  Changing settings for this menu will affect the default
+  ** bindings for all menus (except as noted).
+  ** </para>
+  */
+  { "top-page",		OP_TOP_PAGE,		"H" },
+  { "next-entry",	OP_NEXT_ENTRY,		"j" },
+  { "previous-entry",	OP_PREV_ENTRY,		"k" },
+  { "bottom-page",	OP_BOTTOM_PAGE,		"L" },
+  { "refresh",		OP_REDRAW,		"\014" },
+  { "middle-page",	OP_MIDDLE_PAGE,		"M" },
+  { "search-next",	OP_SEARCH_NEXT,		"n" },
+  { "exit",		OP_EXIT,		"q" },
+  { "tag-entry",	OP_TAG,			"t" },
+  { "next-page",	OP_NEXT_PAGE,		"z" },
+  { "previous-page",	OP_PREV_PAGE,		"Z" },
+  { "last-entry",	OP_LAST_ENTRY,		"*" },
+  { "first-entry",	OP_FIRST_ENTRY,		"=" },
+  { "enter-command",	OP_ENTER_COMMAND,	":" },
+  { "next-line",	OP_NEXT_LINE,		">" },
+  { "previous-line",	OP_PREV_LINE,		"<" },
+  { "half-up",		OP_HALF_UP,		"[" },
+  { "half-down", 	OP_HALF_DOWN,		"]" },
+  { "help",		OP_HELP,		"?" },
+  { "tag-prefix",	OP_TAG_PREFIX,		";" },
+  { "tag-prefix-cond",	OP_TAG_PREFIX_COND,	NULL },
+  { "end-cond",		OP_END_COND,		NULL },
+  { "shell-escape",	OP_SHELL_ESCAPE,	"!" },
+  { "select-entry",	OP_GENERIC_SELECT_ENTRY,M_ENTER_S },
+  { "search",		OP_SEARCH,		"/" },
+  { "search-reverse",	OP_SEARCH_REVERSE,	"\033/" },
+  { "search-opposite",	OP_SEARCH_OPPOSITE,	NULL },
+  { "jump",		OP_JUMP,		NULL },
+  { "current-top",      OP_CURRENT_TOP,		NULL },
+  { "current-middle",   OP_CURRENT_MIDDLE,	NULL },
+  { "current-bottom",   OP_CURRENT_BOTTOM,	NULL },
+  { "what-key",		OP_WHAT_KEY,		NULL },
+  { NULL,		0,			NULL }
+};
+
+struct binding_t OpMain[] = { /* map: index */
+  { "create-alias",		OP_CREATE_ALIAS,		"a" },
+  { "bounce-message",		OP_BOUNCE_MESSAGE,		"b" },
+  { "break-thread",		OP_MAIN_BREAK_THREAD,		"#" },
+  { "change-folder",		OP_MAIN_CHANGE_FOLDER,		"c" },
+  { "change-folder-readonly",	OP_MAIN_CHANGE_FOLDER_READONLY,	"\033c" },
+  { "next-unread-mailbox",	OP_MAIN_NEXT_UNREAD_MAILBOX,    NULL },
+  { "collapse-thread",		OP_MAIN_COLLAPSE_THREAD,	"\033v" },
+  { "collapse-all",		OP_MAIN_COLLAPSE_ALL,		"\033V" },
+  { "copy-message",		OP_COPY_MESSAGE,		"C" },
+  { "decode-copy",		OP_DECODE_COPY,			"\033C" },
+  { "decode-save",		OP_DECODE_SAVE,			"\033s" },
+  { "delete-message",		OP_DELETE,			"d" },
+  { "delete-pattern",		OP_MAIN_DELETE_PATTERN,		"D" },
+  { "delete-thread",		OP_DELETE_THREAD,		"\004" },
+  { "delete-subthread",		OP_DELETE_SUBTHREAD,		"\033d" },
+  { "edit",			OP_EDIT_MESSAGE,		"e" },
+  { "edit-type",		OP_EDIT_TYPE,			"\005" },
+  { "forward-message",		OP_FORWARD_MESSAGE,		"f" },
+  { "flag-message",		OP_FLAG_MESSAGE,		"F" },
+  { "group-reply",		OP_GROUP_REPLY,			"g" },
+#ifdef USE_POP
+  { "fetch-mail",		OP_MAIN_FETCH_MAIL,		"G" },
+#endif
+#ifdef USE_IMAP
+  { "imap-fetch-mail",		OP_MAIN_IMAP_FETCH,		NULL },
+  { "imap-logout-all",		OP_MAIN_IMAP_LOGOUT_ALL,	NULL },
+#endif
+  { "display-toggle-weed",		OP_DISPLAY_HEADERS,		"h" },
+  { "next-undeleted",		OP_MAIN_NEXT_UNDELETED,		"j" },
+  { "previous-undeleted",	OP_MAIN_PREV_UNDELETED,		"k" },
+  { "limit",			OP_MAIN_LIMIT,			"l" },
+  { "link-threads",		OP_MAIN_LINK_THREADS,		"&" },
+  { "list-reply",		OP_LIST_REPLY,			"L" },
+  { "mail",			OP_MAIL,			"m" },
+  { "toggle-new",		OP_TOGGLE_NEW,			"N" },
+  { "toggle-write",		OP_TOGGLE_WRITE,		"%" },
+  { "next-thread",		OP_MAIN_NEXT_THREAD,		"\016" },
+  { "next-subthread",		OP_MAIN_NEXT_SUBTHREAD,		"\033n" },
+  { "query",			OP_QUERY,			"Q" },
+  { "quit",			OP_QUIT,			"q" },
+  { "reply",			OP_REPLY,			"r" },
+  { "show-limit",		OP_MAIN_SHOW_LIMIT,		"\033l" },
+  { "sort-mailbox",		OP_SORT,			"o" },
+  { "sort-reverse",		OP_SORT_REVERSE,		"O" },
+  { "print-message",		OP_PRINT,			"p" },
+  { "previous-thread",		OP_MAIN_PREV_THREAD,		"\020" },
+  { "previous-subthread",	OP_MAIN_PREV_SUBTHREAD,		"\033p" },
+  { "recall-message",		OP_RECALL_MESSAGE,		"R" },
+  { "read-thread",		OP_MAIN_READ_THREAD,		"\022" },
+  { "read-subthread",		OP_MAIN_READ_SUBTHREAD,		"\033r" },
+  { "resend-message",		OP_RESEND,			"\033e" },
+  { "save-message",		OP_SAVE,			"s" },
+  { "tag-pattern",		OP_MAIN_TAG_PATTERN,		"T" },
+  { "tag-subthread",		OP_TAG_SUBTHREAD,		NULL },
+  { "tag-thread",		OP_TAG_THREAD,			"\033t" },
+  { "untag-pattern",		OP_MAIN_UNTAG_PATTERN,		"\024" },
+  { "undelete-message",		OP_UNDELETE,			"u" },
+  { "undelete-pattern",		OP_MAIN_UNDELETE_PATTERN,	"U"},
+  { "undelete-subthread",	OP_UNDELETE_SUBTHREAD,		"\033u" },
+  { "undelete-thread",		OP_UNDELETE_THREAD,		"\025" },
+  { "view-attachments",		OP_VIEW_ATTACHMENTS,		"v" },
+  { "show-version",		OP_VERSION,			"V" },
+  { "set-flag",			OP_MAIN_SET_FLAG,		"w" },
+  { "clear-flag",		OP_MAIN_CLEAR_FLAG,		"W" },
+  { "display-message",		OP_DISPLAY_MESSAGE,		M_ENTER_S },
+  { "buffy-list",		OP_BUFFY_LIST,			"." },
+  { "sync-mailbox",		OP_MAIN_SYNC_FOLDER,		"$" },
+  { "display-address",		OP_DISPLAY_ADDRESS,		"@" },
+  { "pipe-message",		OP_PIPE,			"|" },
+  { "next-new",			OP_MAIN_NEXT_NEW,		NULL },
+  { "next-new-then-unread",	OP_MAIN_NEXT_NEW_THEN_UNREAD,	"\t" },
+  { "previous-new",		OP_MAIN_PREV_NEW,		NULL },
+  { "previous-new-then-unread",	OP_MAIN_PREV_NEW_THEN_UNREAD,	"\033\t" },
+  { "next-unread",		OP_MAIN_NEXT_UNREAD,		NULL },
+  { "previous-unread",		OP_MAIN_PREV_UNREAD,		NULL },
+  { "parent-message",		OP_MAIN_PARENT_MESSAGE,		"P" },
+
+
+  { "extract-keys",		OP_EXTRACT_KEYS,		"\013" },
+  { "forget-passphrase",	OP_FORGET_PASSPHRASE,		"\006" },
+  { "check-traditional-pgp",	OP_CHECK_TRADITIONAL,		"\033P" },
+  { "mail-key",			OP_MAIL_KEY,			"\033k" },
+  { "decrypt-copy",		OP_DECRYPT_COPY,		NULL },
+  { "decrypt-save",		OP_DECRYPT_SAVE,		NULL },
+
+
+ { "sidebar-scroll-up",	OP_SIDEBAR_SCROLL_UP, NULL },
+ { "sidebar-scroll-down",	OP_SIDEBAR_SCROLL_DOWN, NULL },
+ { "sidebar-next",		OP_SIDEBAR_NEXT, NULL },
+ { "sidebar-prev",		OP_SIDEBAR_PREV, NULL },
+ { "sidebar-open",		OP_SIDEBAR_OPEN, NULL },
+  { NULL,			0,				NULL }
+};
+
+struct binding_t OpPager[] = { /* map: pager */
+  { "break-thread",	OP_MAIN_BREAK_THREAD,		"#" },
+  { "create-alias",	OP_CREATE_ALIAS,		"a" },
+  { "bounce-message",	OP_BOUNCE_MESSAGE,		"b" },
+  { "change-folder",	OP_MAIN_CHANGE_FOLDER,		"c" },
+  { "change-folder-readonly",	OP_MAIN_CHANGE_FOLDER_READONLY,	"\033c" },
+  { "next-unread-mailbox",	OP_MAIN_NEXT_UNREAD_MAILBOX, NULL },
+  { "copy-message",	OP_COPY_MESSAGE,		"C" },
+  { "decode-copy",	OP_DECODE_COPY,			"\033C" },
+  { "delete-message",	OP_DELETE,			"d" },
+  { "delete-thread",	OP_DELETE_THREAD,		"\004" },
+  { "delete-subthread",	OP_DELETE_SUBTHREAD,		"\033d" },
+  { "set-flag",  	OP_MAIN_SET_FLAG,		"w" },
+  { "clear-flag",       OP_MAIN_CLEAR_FLAG,		"W" },
+  { "edit",		OP_EDIT_MESSAGE,		"e" },
+  { "edit-type",	OP_EDIT_TYPE,			"\005" },
+  { "forward-message",	OP_FORWARD_MESSAGE,		"f" },
+  { "flag-message",	OP_FLAG_MESSAGE,		"F" },
+  { "group-reply",	OP_GROUP_REPLY,			"g" },
+#ifdef USE_IMAP
+  { "imap-fetch-mail",  OP_MAIN_IMAP_FETCH,		NULL },
+  { "imap-logout-all",  OP_MAIN_IMAP_LOGOUT_ALL,	NULL },
+#endif
+  { "display-toggle-weed",	OP_DISPLAY_HEADERS,		"h" },
+  { "next-undeleted",	OP_MAIN_NEXT_UNDELETED,		"j" },
+  { "next-entry",	OP_NEXT_ENTRY,			"J" },
+  { "previous-undeleted",OP_MAIN_PREV_UNDELETED,	"k" },
+  { "previous-entry",	OP_PREV_ENTRY,			"K" },
+  { "link-threads",	OP_MAIN_LINK_THREADS,		"&" },
+  { "list-reply",	OP_LIST_REPLY,			"L" },
+  { "redraw-screen",	OP_REDRAW,			"\014" },
+  { "mail",		OP_MAIL,			"m" },
+  { "mark-as-new",	OP_TOGGLE_NEW,			"N" },
+  { "search-next",	OP_SEARCH_NEXT,			"n" },
+  { "next-thread",	OP_MAIN_NEXT_THREAD,		"\016" },
+  { "next-subthread",	OP_MAIN_NEXT_SUBTHREAD,		"\033n" },
+  { "sort-mailbox",	OP_SORT,			"o" },
+  { "sort-reverse",	OP_SORT_REVERSE,		"O" },
+  { "print-message",	OP_PRINT,			"p" },
+  { "previous-thread",	OP_MAIN_PREV_THREAD,		"\020" },
+  { "previous-subthread",OP_MAIN_PREV_SUBTHREAD,	"\033p" },
+  { "quit",		OP_QUIT,			"Q" },
+  { "exit",		OP_EXIT,			"q" },
+  { "reply",		OP_REPLY,			"r" },
+  { "recall-message",	OP_RECALL_MESSAGE,		"R" },
+  { "read-thread",	OP_MAIN_READ_THREAD,		"\022" },
+  { "read-subthread",	OP_MAIN_READ_SUBTHREAD,		"\033r" },
+  { "resend-message",	OP_RESEND,			"\033e" },
+  { "save-message",	OP_SAVE,			"s" },
+  { "skip-quoted",	OP_PAGER_SKIP_QUOTED,		"S" },
+  { "decode-save",	OP_DECODE_SAVE,			"\033s" },
+  { "tag-message",	OP_TAG,				"t" },
+  { "toggle-quoted",	OP_PAGER_HIDE_QUOTED,		"T" },
+  { "undelete-message",	OP_UNDELETE,			"u" },
+  { "undelete-subthread",OP_UNDELETE_SUBTHREAD,		"\033u" },
+  { "undelete-thread",	OP_UNDELETE_THREAD,		"\025" },
+  { "view-attachments",	OP_VIEW_ATTACHMENTS,		"v" },
+  { "show-version",	OP_VERSION,			"V" },
+  { "search-toggle",	OP_SEARCH_TOGGLE,		"\\" },
+  { "display-address",	OP_DISPLAY_ADDRESS,		"@" },
+  { "next-new",		OP_MAIN_NEXT_NEW,		NULL },
+  { "next-new-then-unread", 
+                        OP_MAIN_NEXT_NEW_THEN_UNREAD,   "\t" },
+  { "pipe-message",	OP_PIPE,			"|" },
+  { "help",		OP_HELP,			"?" },
+  { "next-page",	OP_NEXT_PAGE,			" " },
+  { "previous-page",	OP_PREV_PAGE,			"-" },
+  { "top",		OP_PAGER_TOP,			"^" },
+  { "sync-mailbox",	OP_MAIN_SYNC_FOLDER,            "$" },
+  { "shell-escape",	OP_SHELL_ESCAPE,		"!" },
+  { "enter-command",	OP_ENTER_COMMAND,		":" },
+  { "buffy-list",	OP_BUFFY_LIST,			"." },
+  { "search",		OP_SEARCH,			"/" },
+  { "search-reverse",	OP_SEARCH_REVERSE,		"\033/" },
+  { "search-opposite",	OP_SEARCH_OPPOSITE,		NULL },
+  { "next-line",	OP_NEXT_LINE,			M_ENTER_S },
+  { "jump",		OP_JUMP,			NULL },
+  { "next-unread",	OP_MAIN_NEXT_UNREAD,		NULL },
+  { "previous-new",	OP_MAIN_PREV_NEW,		NULL },
+  { "previous-new-then-unread",
+      			OP_MAIN_PREV_NEW_THEN_UNREAD,   NULL },
+  { "previous-unread",	OP_MAIN_PREV_UNREAD,		NULL },
+  { "half-up",		OP_HALF_UP,			NULL },
+  { "half-down",	OP_HALF_DOWN,			NULL },
+  { "previous-line",	OP_PREV_LINE,			NULL },
+  { "bottom",		OP_PAGER_BOTTOM,		NULL },
+  { "parent-message",	OP_MAIN_PARENT_MESSAGE,		"P" },
+
+
+
+
+  { "check-traditional-pgp",	OP_CHECK_TRADITIONAL,	"\033P"   },
+  { "mail-key",		OP_MAIL_KEY,			"\033k" },
+  { "extract-keys",	OP_EXTRACT_KEYS,		"\013" },
+  { "forget-passphrase",OP_FORGET_PASSPHRASE,		"\006" },
+  { "decrypt-copy",	OP_DECRYPT_COPY,		NULL },
+  { "decrypt-save",    	OP_DECRYPT_SAVE,		NULL },
+
+  { "what-key",		OP_WHAT_KEY,		NULL },
+
+  { "sidebar-scroll-up",	OP_SIDEBAR_SCROLL_UP, NULL },
+  { "sidebar-scroll-down",	OP_SIDEBAR_SCROLL_DOWN, NULL },
+  { "sidebar-next",	OP_SIDEBAR_NEXT, NULL },
+  { "sidebar-prev",	OP_SIDEBAR_PREV, NULL },
+  { "sidebar-open", OP_SIDEBAR_OPEN, NULL },
+  { NULL,		0,				NULL }
+};
+
+struct binding_t OpAttach[] = { /* map: attachment */
+  { "bounce-message",	OP_BOUNCE_MESSAGE,		"b" },
+  { "display-toggle-weed",	OP_DISPLAY_HEADERS,	"h" },
+  { "edit-type",	OP_EDIT_TYPE,			"\005" },
+  { "print-entry",	OP_PRINT,			"p" },
+  { "save-entry",	OP_SAVE,			"s" },
+  { "pipe-entry",	OP_PIPE,			"|" },
+  { "view-mailcap",	OP_ATTACH_VIEW_MAILCAP,		"m" },
+  { "reply",		OP_REPLY,			"r" },
+  { "resend-message",	OP_RESEND,			"\033e" },
+  { "group-reply",	OP_GROUP_REPLY,			"g" },
+  { "list-reply",	OP_LIST_REPLY,			"L" },
+  { "forward-message",	OP_FORWARD_MESSAGE,		"f" },
+  { "view-text",	OP_ATTACH_VIEW_TEXT,		"T" },
+  { "view-attach",	OP_VIEW_ATTACH,			M_ENTER_S },
+  { "delete-entry",	OP_DELETE,			"d" },
+  { "undelete-entry",	OP_UNDELETE,			"u" },
+  { "collapse-parts",	OP_ATTACH_COLLAPSE,		"v" },
+
+  { "check-traditional-pgp",	OP_CHECK_TRADITIONAL,		"\033P"   },
+  { "extract-keys",		OP_EXTRACT_KEYS,		"\013" },
+  { "forget-passphrase",	OP_FORGET_PASSPHRASE,		"\006" },
+
+  { NULL,		0,				NULL }
+};
+
+struct binding_t OpCompose[] = { /* map: compose */
+  { "attach-file",	OP_COMPOSE_ATTACH_FILE,		"a" },
+  { "attach-message",	OP_COMPOSE_ATTACH_MESSAGE,	"A" },
+  { "edit-bcc",		OP_COMPOSE_EDIT_BCC,		"b" },
+  { "edit-cc",		OP_COMPOSE_EDIT_CC,		"c" },
+  { "copy-file",	OP_SAVE,			"C" },
+  { "detach-file",	OP_DELETE,			"D" },
+  { "toggle-disposition",OP_COMPOSE_TOGGLE_DISPOSITION,	"\004" },
+  { "edit-description",	OP_COMPOSE_EDIT_DESCRIPTION,	"d" },
+  { "edit-message",	OP_COMPOSE_EDIT_MESSAGE,	"e" },
+  { "edit-headers",	OP_COMPOSE_EDIT_HEADERS,	"E" },
+  { "edit-file",	OP_COMPOSE_EDIT_FILE,		"\030e" },
+  { "edit-encoding",	OP_COMPOSE_EDIT_ENCODING,	"\005" },
+  { "edit-from",	OP_COMPOSE_EDIT_FROM,		"\033f" },
+  { "edit-fcc",		OP_COMPOSE_EDIT_FCC,		"f" },
+  { "filter-entry",	OP_FILTER,			"F" },
+  { "get-attachment",	OP_COMPOSE_GET_ATTACHMENT,	"G" },
+  { "display-toggle-weed",	OP_DISPLAY_HEADERS,		"h" },
+  { "ispell",		OP_COMPOSE_ISPELL,		"i" },
+  { "print-entry",	OP_PRINT,			"l" },
+  { "edit-mime",	OP_COMPOSE_EDIT_MIME,		"m" },
+  { "new-mime",		OP_COMPOSE_NEW_MIME,		"n" },
+  { "postpone-message",	OP_COMPOSE_POSTPONE_MESSAGE,	"P" },
+  { "edit-reply-to",	OP_COMPOSE_EDIT_REPLY_TO,	"r" },
+  { "rename-file",	OP_COMPOSE_RENAME_FILE,		"R" },
+  { "edit-subject",	OP_COMPOSE_EDIT_SUBJECT,	"s" },
+  { "edit-to",		OP_COMPOSE_EDIT_TO,		"t" },
+  { "edit-type",	OP_EDIT_TYPE,			"\024" },
+  { "write-fcc",	OP_COMPOSE_WRITE_MESSAGE,	"w" },
+  { "toggle-unlink",	OP_COMPOSE_TOGGLE_UNLINK,	"u" },
+  { "toggle-recode",    OP_COMPOSE_TOGGLE_RECODE,	NULL },
+  { "update-encoding",	OP_COMPOSE_UPDATE_ENCODING,	"U" },
+  { "view-attach",	OP_VIEW_ATTACH,			M_ENTER_S },
+  { "send-message",	OP_COMPOSE_SEND_MESSAGE,	"y" },
+  { "pipe-entry",	OP_PIPE,			"|" },
+
+  { "attach-key",	OP_COMPOSE_ATTACH_KEY,		"\033k" },
+  { "pgp-menu",		OP_COMPOSE_PGP_MENU,		"p" 	},
+
+  { "forget-passphrase",OP_FORGET_PASSPHRASE,		"\006"  },
+
+  { "smime-menu",	OP_COMPOSE_SMIME_MENU,		"S" 	},
+
+#ifdef MIXMASTER
+  { "mix",		OP_COMPOSE_MIX,			"M" },
+#endif
+  
+  { NULL,		0,				NULL }
+};
+
+struct binding_t OpPost[] = { /* map: postpone */
+  { "delete-entry",	OP_DELETE,	"d" },
+  { "undelete-entry",	OP_UNDELETE,	"u" },
+  { NULL,		0,		NULL }
+};
+
+struct binding_t OpAlias[] = { /* map: alias */
+  { "delete-entry",	OP_DELETE,	"d" },
+  { "undelete-entry",	OP_UNDELETE,	"u" },
+  { NULL,		0,		NULL }
+};
+  
+
+/* The file browser */
+struct binding_t OpBrowser[] = { /* map: browser */
+  { "change-dir",	OP_CHANGE_DIRECTORY,	"c" },
+  { "display-filename",	OP_BROWSER_TELL,	"@" },
+  { "enter-mask",	OP_ENTER_MASK,		"m" },
+  { "sort",		OP_SORT,		"o" },
+  { "sort-reverse",	OP_SORT_REVERSE,	"O" },
+  { "select-new",	OP_BROWSER_NEW_FILE,	"N" },
+  { "check-new",	OP_CHECK_NEW,		NULL },
+  { "toggle-mailboxes", OP_TOGGLE_MAILBOXES, 	"\t" },
+  { "view-file",	OP_BROWSER_VIEW_FILE,	" " },
+  { "buffy-list",	OP_BUFFY_LIST,		"." },
+#ifdef USE_IMAP
+  { "create-mailbox",   OP_CREATE_MAILBOX,      "C" },
+  { "delete-mailbox",   OP_DELETE_MAILBOX,      "d" },
+  { "rename-mailbox",   OP_RENAME_MAILBOX,      "r" },
+  { "subscribe",	OP_BROWSER_SUBSCRIBE,	"s" },
+  { "unsubscribe",	OP_BROWSER_UNSUBSCRIBE,	"u" },
+  { "toggle-subscribed", OP_BROWSER_TOGGLE_LSUB, "T" },
+#endif
+  { NULL,		0,			NULL }
+};
+
+/* External Query Menu */
+struct binding_t OpQuery[] = { /* map: query */
+  { "create-alias",	OP_CREATE_ALIAS,	"a" },
+  { "mail",		OP_MAIL,		"m" },
+  { "query",		OP_QUERY,		"Q" },
+  { "query-append",	OP_QUERY_APPEND,	"A" },
+  { NULL,		0,			NULL }
+};
+
+struct binding_t OpEditor[] = { /* map: editor */
+  { "bol",		OP_EDITOR_BOL,			"\001" },
+  { "backward-char",	OP_EDITOR_BACKWARD_CHAR,	"\002" },
+  { "backward-word",	OP_EDITOR_BACKWARD_WORD,	"\033b"},
+  { "capitalize-word",	OP_EDITOR_CAPITALIZE_WORD,	"\033c"},
+  { "downcase-word",	OP_EDITOR_DOWNCASE_WORD,	"\033l"},
+  { "upcase-word",	OP_EDITOR_UPCASE_WORD,		"\033u"},
+  { "delete-char",	OP_EDITOR_DELETE_CHAR,		"\004" },
+  { "eol",		OP_EDITOR_EOL,			"\005" },
+  { "forward-char",	OP_EDITOR_FORWARD_CHAR,		"\006" },
+  { "forward-word",	OP_EDITOR_FORWARD_WORD,		"\033f"},
+  { "backspace",	OP_EDITOR_BACKSPACE,		"\010" },
+  { "kill-eol",		OP_EDITOR_KILL_EOL,		"\013" },
+  { "kill-eow",		OP_EDITOR_KILL_EOW,		"\033d"},
+  { "kill-line",	OP_EDITOR_KILL_LINE,		"\025" },
+  { "quote-char",	OP_EDITOR_QUOTE_CHAR,		"\026" },
+  { "kill-word",	OP_EDITOR_KILL_WORD,		"\027" },
+  { "complete",		OP_EDITOR_COMPLETE,		"\t"   },
+  { "complete-query",	OP_EDITOR_COMPLETE_QUERY,	"\024" },
+  { "buffy-cycle",	OP_EDITOR_BUFFY_CYCLE,		" "    },
+  { "history-up",	OP_EDITOR_HISTORY_UP,		NULL   },
+  { "history-down",	OP_EDITOR_HISTORY_DOWN,		NULL   },
+  { "transpose-chars",	OP_EDITOR_TRANSPOSE_CHARS,	NULL   },
+  { NULL,		0,				NULL   }
+};
+
+
+
+struct binding_t OpPgp[] = { /* map: pgp */
+  { "verify-key",	OP_VERIFY_KEY,		"c" },
+  { "view-name",	OP_VIEW_ID,		"%" },
+  { NULL,		0,				NULL }
+};
+
+
+
+/* When using the GPGME based backend we have some useful functions
+   for the SMIME menu.  */
+struct binding_t OpSmime[] = { /* map: smime */
+#ifdef CRYPT_BACKEND_GPGME
+  { "verify-key",    OP_VERIFY_KEY,             "c" },
+  { "view-name",     OP_VIEW_ID,	        "%" },
+#endif
+  { NULL,	0,	NULL }
+};
+
+
+
+#ifdef MIXMASTER
+struct binding_t OpMix[] = { /* map: mixmaster */
+  { "accept",		OP_MIX_USE,	M_ENTER_S },
+  { "append",		OP_MIX_APPEND,	"a"       },
+  { "insert",		OP_MIX_INSERT,	"i"       },
+  { "delete",		OP_MIX_DELETE,  "d"	  },
+  { "chain-prev",	OP_MIX_CHAIN_PREV, "<left>" },
+  { "chain-next",	OP_MIX_CHAIN_NEXT, "<right>" },
+  { NULL, 		0, 		NULL }
+};
+#endif /* MIXMASTER */
diff -udprP mutt-1.5.21/globals.h mutt-nntp-sidebar/globals.h
--- mutt-1.5.21/globals.h	2011-06-03 07:06:32.519621817 -0700
+++ mutt-nntp-sidebar/globals.h	2011-06-03 07:05:58.942955998 -0700
@@ -95,6 +95,15 @@ WHERE char *MixEntryFormat;
 #endif
 
 WHERE char *Muttrc INITVAL (NULL);
+#ifdef USE_NNTP
+WHERE char *NewsCacheDir;
+WHERE char *GroupFormat;
+WHERE char *Inews;
+WHERE char *NewsServer;
+WHERE char *NntpUser;
+WHERE char *NntpPass;
+WHERE char *NewsRc;
+#endif
 WHERE char *Outbox;
 WHERE char *Pager;
 WHERE char *PagerFmt;
@@ -189,6 +198,11 @@ extern unsigned char QuadOptions[];
 
 WHERE unsigned short Counter INITVAL (0);
 
+#ifdef USE_NNTP
+WHERE short NewsPollTimeout;
+WHERE short NntpContext;
+#endif
+
 WHERE short ConnectTimeout;
 WHERE short HistSize;
 WHERE short MenuContext;
diff -udprP mutt-1.5.21/globals.h.orig mutt-nntp-sidebar/globals.h.orig
--- mutt-1.5.21/globals.h.orig	1969-12-31 17:00:00.000000000 -0700
+++ mutt-nntp-sidebar/globals.h.orig	2011-06-03 07:05:58.916289332 -0700
@@ -0,0 +1,290 @@
+/*
+ * Copyright (C) 1996-2002 Michael R. Elkins <me@mutt.org>
+ * 
+ *     This program is free software; you can redistribute it and/or modify
+ *     it under the terms of the GNU General Public License as published by
+ *     the Free Software Foundation; either version 2 of the License, or
+ *     (at your option) any later version.
+ * 
+ *     This program is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ * 
+ *     You should have received a copy of the GNU General Public License
+ *     along with this program; if not, write to the Free Software
+ *     Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */ 
+
+WHERE void (*mutt_error) (const char *, ...);
+WHERE void (*mutt_message) (const char *, ...);
+
+WHERE CONTEXT *Context;
+
+WHERE char Errorbuf[STRING];
+WHERE char AttachmentMarker[STRING];
+
+#if defined(DL_STANDALONE) && defined(USE_DOTLOCK)
+WHERE char *MuttDotlock;
+#endif
+
+WHERE ADDRESS *EnvFrom;
+WHERE ADDRESS *From;
+
+WHERE char *AliasFile;
+WHERE char *AliasFmt;
+WHERE char *AssumedCharset;
+WHERE char *AttachSep;
+WHERE char *Attribution;
+WHERE char *AttachCharset;
+WHERE char *AttachFormat;
+WHERE char *Charset;
+WHERE char *ComposeFormat;
+WHERE char *ConfigCharset;
+WHERE char *ContentType;
+WHERE char *DefaultHook;
+WHERE char *DateFmt;
+WHERE char *DisplayFilter;
+WHERE char *DsnNotify;
+WHERE char *DsnReturn;
+WHERE char *Editor;
+WHERE char *EscChar;
+WHERE char *FolderFormat;
+WHERE char *ForwFmt;
+WHERE char *Fqdn;
+WHERE char *HdrFmt;
+WHERE char *HistFile;
+WHERE char *Homedir;
+WHERE char *Hostname;
+#ifdef USE_IMAP
+WHERE char *ImapAuthenticators INITVAL (NULL);
+WHERE char *ImapDelimChars INITVAL (NULL);
+WHERE char *ImapHeaders;
+WHERE char *ImapLogin INITVAL (NULL);
+WHERE char *ImapPass INITVAL (NULL);
+WHERE char *ImapUser INITVAL (NULL);
+#endif
+WHERE char *Inbox;
+WHERE char *Ispell;
+WHERE char *Locale;
+WHERE char *MailcapPath;
+WHERE char *Maildir;
+#if defined(USE_IMAP) || defined(USE_POP)
+WHERE char *MessageCachedir;
+#endif
+#if USE_HCACHE
+WHERE char *HeaderCache;
+#if HAVE_GDBM || HAVE_DB4
+WHERE char *HeaderCachePageSize;
+#endif /* HAVE_GDBM || HAVE_DB4 */
+#endif /* USE_HCACHE */
+WHERE char *MhFlagged;
+WHERE char *MhReplied;
+WHERE char *MhUnseen;
+WHERE char *MsgFmt;
+
+#ifdef USE_SOCKET
+WHERE char *Preconnect INITVAL (NULL);
+WHERE char *Tunnel INITVAL (NULL);
+WHERE short NetInc;
+#endif /* USE_SOCKET */
+
+#ifdef MIXMASTER
+WHERE char *Mixmaster;
+WHERE char *MixEntryFormat;
+#endif
+
+WHERE char *Muttrc INITVAL (NULL);
+WHERE char *Outbox;
+WHERE char *Pager;
+WHERE char *PagerFmt;
+WHERE char *PipeSep;
+#ifdef USE_POP
+WHERE char *PopAuthenticators INITVAL (NULL);
+WHERE short PopCheckTimeout;
+WHERE char *PopHost;
+WHERE char *PopPass INITVAL (NULL);
+WHERE char *PopUser INITVAL (NULL);
+#endif
+WHERE char *PostIndentString;
+WHERE char *Postponed;
+WHERE char *Prefix;
+WHERE char *PrintCmd;
+WHERE char *QueryCmd;
+WHERE char *QueryFormat;
+WHERE char *Realname;
+WHERE short SearchContext;
+WHERE char *SendCharset;
+WHERE char *Sendmail;
+WHERE char *Shell;
+WHERE char *SidebarDelim;
+WHERE char *Signature;
+WHERE char *SimpleSearch;
+#if USE_SMTP
+WHERE char *SmtpAuthenticators INITVAL (NULL);
+WHERE char *SmtpPass INITVAL (NULL);
+WHERE char *SmtpUrl INITVAL (NULL);
+#endif /* USE_SMTP */
+WHERE char *Spoolfile;
+WHERE char *SpamSep;
+#if defined(USE_SSL)
+WHERE char *SslCertFile INITVAL (NULL);
+WHERE char *SslClientCert INITVAL (NULL);
+WHERE char *SslEntropyFile INITVAL (NULL);
+#ifdef USE_SSL_GNUTLS
+WHERE short SslDHPrimeBits;
+WHERE char *SslCACertFile INITVAL (NULL);
+#endif
+#endif
+WHERE char *StChars;
+WHERE char *Status;
+WHERE char *Tempdir;
+WHERE char *Tochars;
+WHERE char *Username;
+WHERE char *Visual;
+
+WHERE char *CurrentFolder;
+WHERE char *LastFolder;
+
+
+WHERE const char *ReleaseDate;
+
+WHERE HASH *Groups;
+WHERE HASH *ReverseAlias;
+
+WHERE LIST *AutoViewList INITVAL(0);
+WHERE LIST *AlternativeOrderList INITVAL(0);
+WHERE LIST *AttachAllow INITVAL(0);
+WHERE LIST *AttachExclude INITVAL(0);
+WHERE LIST *InlineAllow INITVAL(0);
+WHERE LIST *InlineExclude INITVAL(0);
+WHERE LIST *HeaderOrderList INITVAL(0);
+WHERE LIST *Ignore INITVAL(0);
+WHERE LIST *MimeLookupList INITVAL(0);
+WHERE LIST *UnIgnore INITVAL(0);
+
+WHERE RX_LIST *Alternates INITVAL(0);
+WHERE RX_LIST *UnAlternates INITVAL(0);
+WHERE RX_LIST *MailLists INITVAL(0);
+WHERE RX_LIST *UnMailLists INITVAL(0);
+WHERE RX_LIST *SubscribedLists INITVAL(0);
+WHERE RX_LIST *UnSubscribedLists INITVAL(0);
+WHERE SPAM_LIST *SpamList INITVAL(0);
+WHERE RX_LIST *NoSpamList INITVAL(0);
+
+
+/* bit vector for boolean variables */
+#ifdef MAIN_C
+unsigned char Options[(OPTMAX + 7)/8];
+#else
+extern unsigned char Options[];
+#endif
+
+/* bit vector for the yes/no/ask variable type */
+#ifdef MAIN_C
+unsigned char QuadOptions[(OPT_MAX*2 + 7) / 8];
+#else
+extern unsigned char QuadOptions[];
+#endif
+
+WHERE unsigned short Counter INITVAL (0);
+
+WHERE short ConnectTimeout;
+WHERE short HistSize;
+WHERE short MenuContext;
+WHERE short PagerContext;
+WHERE short PagerIndexLines;
+WHERE short ReadInc;
+WHERE short SaveHist;
+WHERE short SendmailWait;
+WHERE short SleepTime INITVAL (1);
+WHERE short TimeInc;
+WHERE short Timeout;
+WHERE short Wrap;
+WHERE short WrapHeaders;
+WHERE short WriteInc;
+
+WHERE short ScoreThresholdDelete;
+WHERE short ScoreThresholdRead;
+WHERE short ScoreThresholdFlag;
+
+WHERE struct buffy_t *CurBuffy INITVAL(0);
+WHERE short DrawFullLine INITVAL(0);
+WHERE short SidebarWidth;
+#ifdef USE_IMAP
+WHERE short ImapKeepalive;
+WHERE short ImapPipelineDepth;
+#endif
+
+/* flags for received signals */
+WHERE SIG_ATOMIC_VOLATILE_T SigAlrm INITVAL (0);
+WHERE SIG_ATOMIC_VOLATILE_T SigInt INITVAL (0);
+WHERE SIG_ATOMIC_VOLATILE_T SigWinch INITVAL (0);
+
+WHERE int CurrentMenu;
+
+WHERE ALIAS *Aliases INITVAL (0);
+WHERE LIST *UserHeader INITVAL (0);
+
+/*-- formerly in pgp.h --*/
+WHERE REGEXP PgpGoodSign;
+WHERE char *PgpSignAs;
+WHERE short PgpTimeout;
+WHERE char *PgpEntryFormat;
+WHERE char *PgpClearSignCommand;
+WHERE char *PgpDecodeCommand;
+WHERE char *PgpVerifyCommand;
+WHERE char *PgpDecryptCommand;
+WHERE char *PgpSignCommand;
+WHERE char *PgpEncryptSignCommand;
+WHERE char *PgpEncryptOnlyCommand;
+WHERE char *PgpImportCommand;
+WHERE char *PgpExportCommand;
+WHERE char *PgpVerifyKeyCommand;
+WHERE char *PgpListSecringCommand;
+WHERE char *PgpListPubringCommand;
+WHERE char *PgpGetkeysCommand;
+
+/*-- formerly in smime.h --*/
+WHERE char *SmimeDefaultKey;
+WHERE char *SmimeCryptAlg;
+WHERE short SmimeTimeout;
+WHERE char *SmimeCertificates;
+WHERE char *SmimeKeys;
+WHERE char *SmimeCryptAlg;
+WHERE char *SmimeCALocation;
+WHERE char *SmimeVerifyCommand;
+WHERE char *SmimeVerifyOpaqueCommand;
+WHERE char *SmimeDecryptCommand;
+WHERE char *SmimeSignCommand;
+WHERE char *SmimeSignOpaqueCommand;
+WHERE char *SmimeEncryptCommand;
+WHERE char *SmimeGetSignerCertCommand;
+WHERE char *SmimePk7outCommand;
+WHERE char *SmimeGetCertCommand;
+WHERE char *SmimeImportCertCommand;
+WHERE char *SmimeGetCertEmailCommand;
+
+
+
+
+#ifdef MAIN_C
+const char *Weekdays[] = { "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" };
+const char *Months[] = { "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec", "ERR" };
+
+const char *BodyTypes[] = { "x-unknown", "audio", "application", "image", "message", "model", "multipart", "text", "video" };
+const char *BodyEncodings[] = { "x-unknown", "7bit", "8bit", "quoted-printable", "base64", "binary", "x-uuencoded" };
+#else
+extern const char *Weekdays[];
+extern const char *Months[];
+#endif
+
+#ifdef MAIN_C
+/* so that global vars get included */ 
+#include "mx.h"
+#include "mutt_regex.h"
+#include "buffy.h"
+#include "sort.h"
+#include "mutt_crypt.h"
+#include "reldate.h"
+#endif /* MAIN_C */
diff -udprP mutt-1.5.21/hash.c mutt-nntp-sidebar/hash.c
--- mutt-1.5.21/hash.c	2009-03-19 12:41:18.000000000 -0700
+++ mutt-nntp-sidebar/hash.c	2011-06-03 07:05:58.939622665 -0700
@@ -57,6 +57,7 @@ HASH *hash_create (int nelem, int lower)
   if (nelem == 0)
     nelem = 2;
   table->nelem = nelem;
+  table->curnelem = 0;
   table->table = safe_calloc (nelem, sizeof (struct hash_elem *));
   if (lower)
   {
@@ -71,6 +72,29 @@ HASH *hash_create (int nelem, int lower)
   return table;
 }
 
+HASH *hash_resize (HASH *ptr, int nelem, int lower)
+{
+  HASH *table;
+  struct hash_elem *elem, *tmp;
+  int i;
+
+  table = hash_create (nelem, lower);
+
+  for (i = 0; i < ptr->nelem; i++)
+  {
+    for (elem = ptr->table[i]; elem; )
+    {
+      tmp = elem;
+      elem = elem->next;
+      hash_insert (table, tmp->key, tmp->data, 1);
+      FREE (&tmp);
+    }
+  }
+  FREE (&ptr->table);
+  FREE (&ptr);
+  return table;
+}
+
 /* table        hash table to update
  * key          key to hash on
  * data         data to associate with `key'
@@ -90,6 +114,7 @@ int hash_insert (HASH * table, const cha
   {
     ptr->next = table->table[h];
     table->table[h] = ptr;
+    table->curnelem++;
   }
   else
   {
@@ -112,6 +137,7 @@ int hash_insert (HASH * table, const cha
     else
       table->table[h] = ptr;
     ptr->next = tmp;
+    table->curnelem++;
   }
   return h;
 }
@@ -142,6 +168,7 @@ void hash_delete_hash (HASH * table, int
       if (destroy)
 	destroy (ptr->data);
       FREE (&ptr);
+      table->curnelem--;
       
       ptr = *last;
     }
diff -udprP mutt-1.5.21/hash.h mutt-nntp-sidebar/hash.h
--- mutt-1.5.21/hash.h	2009-03-19 12:41:18.000000000 -0700
+++ mutt-nntp-sidebar/hash.h	2011-06-03 07:05:58.939622665 -0700
@@ -28,7 +28,7 @@ struct hash_elem
 
 typedef struct
 {
-  int nelem;
+  int nelem, curnelem;
   struct hash_elem **table;
   unsigned int (*hash_string)(const unsigned char *, unsigned int);
   int (*cmp_string)(const char *, const char *);
@@ -41,6 +41,7 @@ HASH;
 
 HASH *hash_create (int nelem, int lower);
 int hash_insert (HASH * table, const char *key, void *data, int allow_dup);
+HASH *hash_resize (HASH * table, int nelem, int lower);
 void *hash_find_hash (const HASH * table, int hash, const char *key);
 void hash_delete_hash (HASH * table, int hash, const char *key, const void *data,
 		       void (*destroy) (void *));
diff -udprP mutt-1.5.21/hdrline.c mutt-nntp-sidebar/hdrline.c
--- mutt-1.5.21/hdrline.c	2009-04-10 16:45:19.000000000 -0700
+++ mutt-nntp-sidebar/hdrline.c	2011-06-03 07:05:58.939622665 -0700
@@ -211,6 +211,7 @@ int mutt_user_is_recipient (HEADER *h)
  * %E = number of messages in current thread
  * %f = entire from line
  * %F = like %n, unless from self
+ * %g = newsgroup name (if compiled with nntp support)
  * %i = message-id
  * %l = number of lines in the message
  * %L = like %F, except `lists' are displayed first
@@ -219,12 +220,14 @@ int mutt_user_is_recipient (HEADER *h)
  * %N = score
  * %O = like %L, except using address instead of name
  * %P = progress indicator for builtin pager
+ * %R = `x-comment-to:' field (if present and compiled with nntp support)
  * %s = subject
  * %S = short message status (e.g., N/O/D/!/r/-)
  * %t = `to:' field (recipients)
  * %T = $to_chars
  * %u = user (login) name of author
  * %v = first name of author, unless from self
+ * %W = where user is (organization)
  * %X = number of MIME attachments
  * %y = `x-label:' field (if present)
  * %Y = `x-label:' field (if present, tree unfolded, and != parent's x-label)
@@ -457,6 +460,12 @@ hdr_format_str (char *dest,
 
       break;
 
+#ifdef USE_NNTP
+    case 'g':
+      mutt_format_s (dest, destlen, prefix, hdr->env->newsgroups ? hdr->env->newsgroups : "");
+      break;
+#endif
+
     case 'i':
       mutt_format_s (dest, destlen, prefix, hdr->env->message_id ? hdr->env->message_id : "<no.id>");
       break;
@@ -548,6 +557,15 @@ hdr_format_str (char *dest,
       strfcpy(dest, NONULL(hfi->pager_progress), destlen);
       break;
 
+#ifdef USE_NNTP
+    case 'R':
+      if (!optional)
+	mutt_format_s (dest, destlen, prefix, hdr->env->x_comment_to ? hdr->env->x_comment_to : "");
+      else if (!hdr->env->x_comment_to)
+	optional = 0;
+      break;
+#endif
+
     case 's':
       
       if (flags & M_FORMAT_TREE && !hdr->collapsed)
@@ -637,6 +655,13 @@ hdr_format_str (char *dest,
       mutt_format_s (dest, destlen, prefix, buf2);
       break;
 
+    case 'W':
+      if (!optional)
+	mutt_format_s (dest, destlen, prefix, hdr->env->organization ? hdr->env->organization : "");
+      else if (!hdr->env->organization)
+	optional = 0;
+      break;
+
     case 'Z':
     
       ch = ' ';
diff -udprP mutt-1.5.21/headers.c mutt-nntp-sidebar/headers.c
--- mutt-1.5.21/headers.c	2009-08-25 12:08:52.000000000 -0700
+++ mutt-nntp-sidebar/headers.c	2011-06-03 07:05:58.916289332 -0700
@@ -114,6 +114,9 @@ void mutt_edit_headers (const char *edit
      $edit_headers set, we remove References: as they're likely invalid;
      we can simply compare strings as we don't generate References for
      multiple Message-Ids in IRT anyways */
+#ifdef USE_NNTP
+  if (!option (OPTNEWSSEND))
+#endif
   if (!n->in_reply_to || (msg->env->in_reply_to &&
 			  mutt_strcmp (n->in_reply_to->data,
 				       msg->env->in_reply_to->data) != 0))
diff -udprP mutt-1.5.21/init.c mutt-nntp-sidebar/init.c
--- mutt-1.5.21/init.c	2010-08-25 09:31:40.000000000 -0700
+++ mutt-nntp-sidebar/init.c	2011-06-03 07:05:58.929622666 -0700
@@ -2966,6 +2966,28 @@ void mutt_init (int skip_sys_rc, LIST *c
   else
     Fqdn = safe_strdup(NONULL(Hostname));
 
+#ifdef USE_NNTP
+  {
+    FILE *f;
+    char *i;
+
+    if ((f = safe_fopen (SYSCONFDIR "/nntpserver", "r")))
+    {
+      buffer[0] = '\0';
+      fgets (buffer, sizeof (buffer), f);
+      p = &buffer;
+      SKIPWS (p);
+      i = p;
+      while (*i && (*i != ' ') && (*i != '\t') && (*i != '\r') && (*i != '\n')) i++;
+      *i = '\0';
+      NewsServer = safe_strdup (p);
+      fclose (f);
+    }
+  }
+  if ((p = getenv ("NNTPSERVER")))
+    NewsServer = safe_strdup (p);
+#endif
+
   if ((p = getenv ("MAIL")))
     Spoolfile = safe_strdup (p);
   else if ((p = getenv ("MAILDIR")))
diff -udprP mutt-1.5.21/init.h mutt-nntp-sidebar/init.h
--- mutt-1.5.21/init.h	2011-06-03 07:06:32.522955151 -0700
+++ mutt-nntp-sidebar/init.h	2011-06-03 07:05:58.942955998 -0700
@@ -176,6 +176,20 @@ struct option_t MuttVars[] = {
   ** If \fIset\fP, Mutt will prompt you for carbon-copy (Cc) recipients before
   ** editing the body of an outgoing message.
   */
+#ifdef USE_NNTP
+  { "ask_follow_up",	DT_BOOL, R_NONE, OPTASKFOLLOWUP, 0 },
+  /*
+  ** .pp
+  ** If set, Mutt will prompt you for follow-up groups before editing
+  ** the body of an outgoing message.
+  */
+  { "ask_x_comment_to",	DT_BOOL, R_NONE, OPTASKXCOMMENTTO, 0 },
+  /*
+  ** .pp
+  ** If set, Mutt will prompt you for x-comment-to field before editing
+  ** the body of an outgoing message.
+  */
+#endif
   { "assumed_charset", DT_STR, R_NONE, UL &AssumedCharset, UL 0},
   /*
   ** .pp
@@ -322,6 +336,14 @@ struct option_t MuttVars[] = {
   ** follow these menus.  The option is \fIunset\fP by default because many
   ** visual terminals don't permit making the cursor invisible.
   */
+#ifdef USE_NNTP
+  { "catchup_newsgroup", DT_QUAD, R_NONE, OPT_CATCHUP, M_ASKYES },
+  /*
+  ** .pp
+  ** If this variable is \fIset\fP, Mutt will mark all articles in newsgroup
+  ** as read when you quit the newsgroup (catchup newsgroup).
+  */
+#endif
 #if defined(USE_SSL)
   { "certificate_file",	DT_PATH, R_NONE, UL &SslCertFile, UL "~/.mutt_certificates" },
   /*
@@ -798,6 +820,16 @@ struct option_t MuttVars[] = {
   ** sent to both the list and your address, resulting in two copies
   ** of the same email for you.
   */
+#ifdef USE_NNTP
+  { "followup_to_poster", DT_QUAD, R_NONE, OPT_FOLLOWUPTOPOSTER, M_ASKYES },
+  /*
+  ** .pp
+  ** If this variable is \fIset\fP and the keyword "poster" is present in
+  ** \fIFollowup-To\fP header, follow-up to newsgroup function is not
+  ** permitted.  The message will be mailed to the submitter of the
+  ** message via mail.
+  */
+#endif
   { "force_name",	DT_BOOL, R_NONE, OPTFORCENAME, 0 },
   /*
   ** .pp
@@ -880,6 +912,27 @@ struct option_t MuttVars[] = {
   ** a regular expression that will match the whole name so mutt will expand
   ** ``Franklin'' to ``Franklin, Steve''.
   */
+#ifdef USE_NNTP
+  { "group_index_format", DT_STR, R_BOTH, UL &GroupFormat, UL "%4C %M%N %5s  %-45.45f %d" },
+  /*
+  ** .pp
+  ** This variable allows you to customize the newsgroup browser display to
+  ** your personal taste.  This string is similar to ``$index_format'', but
+  ** has its own set of printf()-like sequences:
+  ** .pp
+  ** .ts
+  ** %C      current newsgroup number
+  ** %d      description of newsgroup (becomes from server)
+  ** %f      newsgroup name
+  ** %M      - if newsgroup not allowed for direct post (moderated for example)
+  ** %N      N if newsgroup is new, u if unsubscribed, blank otherwise
+  ** %n      number of new articles in newsgroup
+  ** %s      number of unread articles in newsgroup
+  ** %>X     right justify the rest of the string and pad with character "X"
+  ** %|X     pad to the end of the line with character "X"
+  ** .te
+  */
+#endif
   { "hdr_format",	DT_SYN,  R_NONE, UL "index_format", 0 },
   /*
   */
@@ -1256,6 +1309,7 @@ struct option_t MuttVars[] = {
   ** .dt %E .dd number of messages in current thread
   ** .dt %f .dd sender (address + real name), either From: or Return-Path:
   ** .dt %F .dd author name, or recipient name if the message is from you
+  ** .dt %g .dd newsgroup name (if compiled with nntp support)
   ** .dt %H .dd spam attribute(s) of this message
   ** .dt %i .dd message-id of the current message
   ** .dt %l .dd number of lines in the message (does not work with maildir,
@@ -1271,12 +1325,14 @@ struct option_t MuttVars[] = {
   **            stashed the message: list name or recipient name
   **            if not sent to a list
   ** .dt %P .dd progress indicator for the built-in pager (how much of the file has been displayed)
+  ** .dt %R .dd ``x-comment-to:'' field (if present and compiled with nntp support)
   ** .dt %s .dd subject of the message
   ** .dt %S .dd status of the message (``N''/``D''/``d''/``!''/``r''/\(as)
   ** .dt %t .dd ``To:'' field (recipients)
   ** .dt %T .dd the appropriate character from the $$to_chars string
   ** .dt %u .dd user (login) name of the author
   ** .dt %v .dd first name of the author, or the recipient if the message is from you
+  ** .dt %W .dd name of organization of author (``organization:'' field)
   ** .dt %X .dd number of attachments
   **            (please see the ``$attachments'' section for possible speed effects)
   ** .dt %y .dd ``X-Label:'' field, if present
@@ -1311,6 +1367,21 @@ struct option_t MuttVars[] = {
   ** Note that these expandos are supported in
   ** ``$save-hook'', ``$fcc-hook'' and ``$fcc-save-hook'', too.
   */
+#ifdef USE_NNTP
+  { "inews",          DT_PATH, R_NONE, UL &Inews, UL "" },
+  /*
+  ** .pp
+  ** If set, specifies the program and arguments used to deliver news posted
+  ** by Mutt.  Otherwise, mutt posts article using current connection to
+  ** news server.  The following printf-style sequence is understood:
+  ** .pp
+  ** .ts
+  ** %s      newsserver name
+  ** .te
+  ** .pp
+  ** Example: set inews="/usr/local/bin/inews -hS"
+  */
+#endif
   { "ispell",		DT_PATH, R_NONE, UL &Ispell, UL ISPELL },
   /*
   ** .pp
@@ -1545,6 +1616,15 @@ struct option_t MuttVars[] = {
   ** menu, attachments which cannot be decoded in a reasonable manner will
   ** be attached to the newly composed message if this option is \fIset\fP.
   */
+#ifdef USE_NNTP
+  { "mime_subject",   DT_BOOL, R_NONE, OPTMIMESUBJECT, 1 },
+  /*
+  ** .pp
+  ** If \fIunset\fP, 8-bit ``subject:'' line in article header will not be
+  ** encoded according to RFC2047 to base64.  This is useful when message
+  ** is Usenet article, because MIME for news is nonstandard feature.
+  */
+#endif
 #ifdef MIXMASTER
   { "mix_entry_format", DT_STR,  R_NONE, UL &MixEntryFormat, UL "%4n %c %-16s %a" },
   /*
@@ -1592,6 +1672,77 @@ struct option_t MuttVars[] = {
    ** See also $$read_inc, $$write_inc and $$net_inc.
    */
 #endif
+#ifdef USE_NNTP
+  { "news_cache_dir", DT_PATH, R_NONE, UL &NewsCacheDir, UL "~/.mutt" },
+  /*
+  ** .pp
+  ** This variable pointing to directory where Mutt will save cached news
+  ** articles headers in. If \fIunset\fP, headers will not be saved at all
+  ** and will be reloaded each time when you enter to newsgroup.
+  */
+  { "news_server",    DT_STR,  R_NONE, UL &NewsServer, 0 },
+  /*
+  ** .pp
+  ** This variable specifies domain name or address of NNTP server. It
+  ** defaults to the newsserver specified in the environment variable
+  ** $$$NNTPSERVER or contained in the file /etc/nntpserver.  You can also
+  ** specify username and an alternative port for each newsserver, ie:
+  ** .pp
+  ** [news[s]://][username[:password]@]newsserver[:port]
+  */
+  { "newsrc",         DT_PATH, R_NONE, UL &NewsRc, UL "~/.newsrc" },
+  /*
+  ** .pp
+  ** The file, containing info about subscribed newsgroups - names and
+  ** indexes of read articles.  The following printf-style sequence
+  ** is understood:
+  ** .pp
+  ** .ts
+  ** %s      newsserver name
+  ** .te
+  */
+  { "nntp_context",   DT_NUM,  R_NONE, UL &NntpContext, 1000 },
+  /*
+  ** .pp
+  ** This variable defines number of articles which will be in index when
+  ** newsgroup entered.  If active newsgroup have more articles than this
+  ** number, oldest articles will be ignored.  Also controls how many
+  ** articles headers will be saved in cache when you quit newsgroup.
+  */
+  { "nntp_load_description", DT_BOOL, R_NONE, OPTLOADDESC, 1 },
+  /*
+  ** .pp
+  ** This variable controls whether or not descriptions for each newsgroup
+  ** must be loaded when newsgroup is added to list (first time list
+  ** loading or new newsgroup adding).
+  */
+  { "nntp_user",      DT_STR,  R_NONE, UL &NntpUser, UL "" },
+  /*
+  ** .pp
+  ** Your login name on the NNTP server.  If \fIunset\fP and NNTP server requires
+  ** authentification, Mutt will prompt you for your account name when you
+  ** connect to newsserver.
+  */
+  { "nntp_pass",      DT_STR,  R_NONE, UL &NntpPass, UL "" },
+  /*
+  ** .pp
+  ** Your password for NNTP account.
+  */
+  { "nntp_poll",      DT_NUM,  R_NONE, UL &NewsPollTimeout, 60 },
+  /*
+  ** .pp
+  ** The time in seconds until any operations on newsgroup except post new
+  ** article will cause recheck for new news.  If set to 0, Mutt will
+  ** recheck newsgroup on each operation in index (stepping, read article,
+  ** etc.).
+  */
+  { "nntp_reconnect", DT_QUAD, R_NONE, OPT_NNTPRECONNECT, M_ASKYES },
+  /*
+  ** .pp
+  ** Controls whether or not Mutt will try to reconnect to newsserver when
+  ** connection lost.
+  */
+#endif
   { "pager",		DT_PATH, R_NONE, UL &Pager, UL "builtin" },
   /*
   ** .pp
@@ -2107,6 +2258,16 @@ struct option_t MuttVars[] = {
   { "post_indent_str",  DT_SYN,  R_NONE, UL "post_indent_string", 0 },
   /*
   */
+#ifdef USE_NNTP
+  { "post_moderated", DT_QUAD, R_NONE, OPT_TOMODERATED, M_ASKYES },
+  /*
+  ** .pp
+  ** If set to \fIyes\fP, Mutt will post article to newsgroup that have
+  ** not permissions to posting (e.g. moderated).  \fBNote:\fP if newsserver
+  ** does not support posting to that newsgroup or totally read-only, that
+  ** posting will not have an effect.
+  */
+#endif
   { "postpone",		DT_QUAD, R_NONE, OPT_POSTPONE, M_ASKYES },
   /*
   ** .pp
@@ -2510,6 +2671,28 @@ struct option_t MuttVars[] = {
   ** Command to use when spawning a subshell.  By default, the user's login
   ** shell from \fC/etc/passwd\fP is used.
   */
+#ifdef USE_NNTP
+  { "save_unsubscribed",DT_BOOL, R_NONE, OPTSAVEUNSUB, 0 },
+  /*
+  ** .pp
+  ** When \fIset\fP, info about unsubscribed newsgroups will be saved into
+  ** ``newsrc'' file and into cache.
+  */
+  { "show_new_news",  DT_BOOL, R_NONE, OPTSHOWNEWNEWS, 1 },
+  /*
+  ** .pp
+  ** If \fIset\fP, newsserver will be asked for new newsgroups on entering
+  ** the browser.  Otherwise, it will be done only once for a newsserver.
+  ** Also controls whether or not number of new articles of subscribed
+  ** newsgroups will be then checked.
+  */
+  { "show_only_unread",  DT_BOOL, R_NONE, OPTSHOWONLYUNREAD, 0 },
+  /*
+  ** .pp
+  ** If \fIset\fP, only subscribed newsgroups that contain unread articles
+  ** will be displayed in browser.
+  */
+#endif
   { "sig_dashes",	DT_BOOL, R_NONE, OPTSIGDASHES, 1 },
   /*
   ** .pp
@@ -3380,6 +3563,14 @@ struct option_t MuttVars[] = {
   ** Also see the $$read_inc, $$net_inc and $$time_inc variables and the
   ** ``$tuning'' section of the manual for performance considerations.
   */
+#ifdef USE_NNTP
+  { "x_comment_to",   DT_BOOL, R_NONE, OPTXCOMMENTTO, 0 },
+  /*
+  ** .pp
+  ** If \fIset\fP, Mutt will add ``X-Comment-To:'' field (that contains full
+  ** name of original article author) to article that followuped to newsgroup.
+  */
+#endif
   /*--*/
   { NULL, 0, 0, 0, 0 }
 };
diff -udprP mutt-1.5.21/init.h.orig mutt-nntp-sidebar/init.h.orig
--- mutt-1.5.21/init.h.orig	2010-09-15 08:39:31.000000000 -0700
+++ mutt-nntp-sidebar/init.h.orig	2011-06-03 07:05:58.939622665 -0700
@@ -1953,6 +1953,22 @@ struct option_t MuttVars[] = {
   ** not used.
   ** (PGP only)
   */
+  {"sidebar_delim", DT_STR, R_BOTH, UL &SidebarDelim, "|"},
+  /*
+  ** .pp
+  ** This specifies the delimiter between the sidebar (if visible) and 
+  ** other screens.
+  */
+  { "sidebar_visible", DT_BOOL, R_BOTH, OPTSIDEBAR, 0 },
+  /*
+  ** .pp
+  ** This specifies whether or not to show sidebar (left-side list of folders).
+  */
+  { "sidebar_width", DT_NUM, R_BOTH, UL &SidebarWidth, 0 },
+  /*
+  ** .pp
+  ** The width of the sidebar.
+  */
   { "pgp_use_gpg_agent", DT_BOOL, R_NONE, OPTUSEGPGAGENT, 0},
   /*
   ** .pp
diff -udprP mutt-1.5.21/keymap.c mutt-nntp-sidebar/keymap.c
--- mutt-1.5.21/keymap.c	2010-09-13 10:19:55.000000000 -0700
+++ mutt-nntp-sidebar/keymap.c	2011-06-03 07:05:58.916289332 -0700
@@ -780,7 +780,6 @@ void km_init (void)
   km_bindkey ("<enter>", MENU_MAIN, OP_DISPLAY_MESSAGE);
 
   km_bindkey ("x", MENU_PAGER, OP_EXIT);
-  km_bindkey ("i", MENU_PAGER, OP_EXIT);
   km_bindkey ("<backspace>", MENU_PAGER, OP_PREV_LINE);
   km_bindkey ("<pagedown>", MENU_PAGER, OP_NEXT_PAGE);
   km_bindkey ("<pageup>", MENU_PAGER, OP_PREV_PAGE);
diff -udprP mutt-1.5.21/mailbox.h mutt-nntp-sidebar/mailbox.h
--- mutt-1.5.21/mailbox.h	2011-06-03 07:06:32.522955151 -0700
+++ mutt-nntp-sidebar/mailbox.h	2011-06-03 07:05:58.932955999 -0700
@@ -75,6 +75,9 @@ int mx_is_imap (const char *);
 #ifdef USE_POP
 int mx_is_pop (const char *);
 #endif
+#ifdef USE_NNTP
+int mx_is_nntp (const char *);
+#endif
 
 int mx_access (const char*, int);
 int mx_check_empty (const char *);
diff -udprP mutt-1.5.21/mailbox.h.orig mutt-nntp-sidebar/mailbox.h.orig
--- mutt-1.5.21/mailbox.h.orig	1969-12-31 17:00:00.000000000 -0700
+++ mutt-nntp-sidebar/mailbox.h.orig	2011-06-03 07:05:58.939622665 -0700
@@ -0,0 +1,85 @@
+/*
+ * Copyright (C) 1996-2002 Michael R. Elkins <me@mutt.org>
+ * 
+ *     This program is free software; you can redistribute it and/or modify
+ *     it under the terms of the GNU General Public License as published by
+ *     the Free Software Foundation; either version 2 of the License, or
+ *     (at your option) any later version.
+ * 
+ *     This program is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ * 
+ *     You should have received a copy of the GNU General Public License
+ *     along with this program; if not, write to the Free Software
+ *     Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */ 
+
+#ifndef _MAILBOX_H
+#define _MAILBOX_H
+
+/* flags for mutt_open_mailbox() */
+#define M_NOSORT	(1<<0) /* do not sort the mailbox after opening it */
+#define M_APPEND	(1<<1) /* open mailbox for appending messages */
+#define M_READONLY	(1<<2) /* open in read-only mode */
+#define M_QUIET		(1<<3) /* do not print any messages */
+#define M_NEWFOLDER	(1<<4) /* create a new folder - same as M_APPEND, but uses
+				* safe_fopen() for mbox-style folders.
+				*/
+#define M_PEEK		(1<<5) /* revert atime back after taking a look (if applicable) */
+
+/* mx_open_new_message() */
+#define M_ADD_FROM	1	/* add a From_ line */
+
+/* return values from mx_check_mailbox() */
+enum
+{
+  M_NEW_MAIL = 1,	/* new mail received in mailbox */
+  M_LOCKED,		/* couldn't lock the mailbox */
+  M_REOPENED,		/* mailbox was reopened */
+  M_FLAGS               /* nondestructive flags change (IMAP) */
+};
+
+typedef struct
+{
+  FILE *fp;	/* pointer to the message data */
+  char *path;	/* path to temp file */
+  short magic;	/* type of mailbox this message belongs to */
+  short write;	/* nonzero if message is open for writing */
+  struct {
+    unsigned read : 1;
+    unsigned flagged : 1;
+    unsigned replied : 1;
+  } flags;
+  time_t received;	/* the time at which this message was received */
+} MESSAGE;
+
+CONTEXT *mx_open_mailbox (const char *, int, CONTEXT *);
+
+MESSAGE *mx_open_message (CONTEXT *, int);
+MESSAGE *mx_open_new_message (CONTEXT *, HEADER *, int);
+
+void mx_fastclose_mailbox (CONTEXT *);
+
+int mx_close_mailbox (CONTEXT *, int *);
+int mx_sync_mailbox (CONTEXT *, int *);
+int mx_commit_message (MESSAGE *, CONTEXT *);
+int mx_close_message (MESSAGE **);
+int mx_get_magic (const char *);
+int mx_set_magic (const char *);
+int mx_check_mailbox (CONTEXT *, int *, int);
+#ifdef USE_IMAP
+int mx_is_imap (const char *);
+#endif
+#ifdef USE_POP
+int mx_is_pop (const char *);
+#endif
+
+int mx_access (const char*, int);
+int mx_check_empty (const char *);
+
+int mx_is_maildir (const char *);
+int mx_is_mh (const char *);
+
+#endif
diff -udprP mutt-1.5.21/main.c mutt-nntp-sidebar/main.c
--- mutt-1.5.21/main.c	2010-09-13 10:19:55.000000000 -0700
+++ mutt-nntp-sidebar/main.c	2011-06-03 07:05:58.909622665 -0700
@@ -60,6 +60,10 @@
 #include <stringprep.h>
 #endif
 
+#ifdef USE_NNTP
+#include "nntp.h"
+#endif
+
 static const char *ReachingUs = N_("\
 To contact the developers, please mail to <mutt-dev@mutt.org>.\n\
 To report a bug, please visit http://bugs.mutt.org/.\n");
@@ -134,6 +138,8 @@ options:\n\
 "  -e <command>\tspecify a command to be executed after initialization\n\
   -f <file>\tspecify which mailbox to read\n\
   -F <file>\tspecify an alternate muttrc file\n\
+  -g <server>\tspecify a newsserver (if compiled with NNTP)\n\
+  -G\t\tselect a newsgroup (if compiled with NNTP)\n\
   -H <file>\tspecify a draft file to read header and body from\n\
   -i <file>\tspecify a file which Mutt should include in the body\n\
   -m <type>\tspecify a default mailbox type\n\
@@ -254,6 +260,12 @@ static void show_version (void)
 	"-USE_POP  "
 #endif
 
+#ifdef USE_NNTP
+	"+USE_NNTP  "
+#else
+	"-USE_NNTP  "
+#endif
+
 #ifdef USE_IMAP
         "+USE_IMAP  "
 #else
@@ -522,6 +534,9 @@ init_extended_keys();
 #define M_NOSYSRC (1<<2)	/* -n */
 #define M_RO      (1<<3)	/* -R */
 #define M_SELECT  (1<<4)	/* -y */
+#ifdef USE_NNTP
+#define M_NEWS    (1<<5)	/* -g and -G */
+#endif
 
 int main (int argc, char **argv)
 {
@@ -594,7 +609,11 @@ int main (int argc, char **argv)
         argv[nargc++] = argv[optind];
     }
 
+#ifdef USE_NNTP
+    if ((i = getopt (argc, argv, "+A:a:b:F:f:c:Dd:e:g:GH:s:i:hm:npQ:RvxyzZ")) != EOF)
+#else
     if ((i = getopt (argc, argv, "+A:a:b:F:f:c:Dd:e:H:s:i:hm:npQ:RvxyzZ")) != EOF)
+#endif
       switch (i)
       {
       case 'A':
@@ -691,6 +710,20 @@ int main (int argc, char **argv)
 	flags |= M_SELECT;
 	break;
 
+#ifdef USE_NNTP
+      case 'g': /* Specify a newsserver */
+	{
+	  char buf[LONG_STRING];
+
+	  snprintf (buf, sizeof (buf), "set news_server=%s", optarg);
+	  commands = mutt_add_list (commands, buf);
+	}
+
+      case 'G': /* List of newsgroups */
+	flags |= M_SELECT | M_NEWS;
+	break;
+#endif
+
       case 'z':
 	flags |= M_IGNORE;
 	break;
@@ -978,6 +1011,18 @@ int main (int argc, char **argv)
     }
     else if (flags & M_SELECT)
     {
+#ifdef USE_NNTP
+      if (flags & M_NEWS)
+      {
+	set_option (OPTNEWS);
+	if(!(CurrentNewsSrv = mutt_select_newsserver (NewsServer)))
+	{
+	  mutt_endwin (Errorbuf);
+	  exit (1);
+	}
+      }
+      else
+#endif
       if (!Incoming) {
 	mutt_endwin _("No incoming mailboxes defined.");
 	exit (1);
@@ -993,6 +1038,15 @@ int main (int argc, char **argv)
 
     if (!folder[0])
       strfcpy (folder, NONULL(Spoolfile), sizeof (folder));
+
+#ifdef USE_NNTP
+    if (option (OPTNEWS))
+    {
+      unset_option (OPTNEWS);
+      nntp_expand_path (folder, sizeof (folder), &CurrentNewsSrv->conn->account);
+    }
+    else
+#endif
     mutt_expand_path (folder, sizeof (folder));
 
     mutt_str_replace (&CurrentFolder, folder);
diff -udprP mutt-1.5.21/mutt.h mutt-nntp-sidebar/mutt.h
--- mutt-1.5.21/mutt.h	2011-06-03 07:06:32.526288485 -0700
+++ mutt-nntp-sidebar/mutt.h	2011-06-03 07:05:58.916289332 -0700
@@ -229,6 +229,9 @@ enum
   M_PGP_KEY,
   M_XLABEL,
   M_MIMEATTACH,
+#ifdef USE_NNTP
+  M_NEWSGROUPS,
+#endif
   
   /* Options for Mailcap lookup */
   M_EDIT,
@@ -285,6 +288,12 @@ enum
 #endif
   OPT_SUBJECT,
   OPT_VERIFYSIG,      /* verify PGP signatures */
+#ifdef USE_NNTP
+  OPT_TOMODERATED,
+  OPT_NNTPRECONNECT,
+  OPT_CATCHUP,
+  OPT_FOLLOWUPTOPOSTER,
+#endif /* USE_NNTP */
     
   /* THIS MUST BE THE LAST VALUE. */
   OPT_MAX
@@ -300,6 +309,7 @@ enum
 #define SENDMAILX	(1<<6)
 #define SENDKEY		(1<<7)
 #define SENDRESEND	(1<<8)
+#define SENDNEWS	(1<<9)
 
 /* flags to _mutt_select_file() */
 #define M_SEL_BUFFY	(1<<0)
@@ -319,6 +329,8 @@ enum
   OPTASCIICHARS,
   OPTASKBCC,
   OPTASKCC,
+  OPTASKFOLLOWUP,
+  OPTASKXCOMMENTTO,
   OPTATTACHSPLIT,
   OPTAUTOEDIT,
   OPTAUTOTAG,
@@ -397,6 +409,9 @@ enum
   OPTMETOO,
   OPTMHPURGE,
   OPTMIMEFORWDECODE,
+#ifdef USE_NNTP
+  OPTMIMESUBJECT,	/* encode subject line with RFC2047 */
+#endif
   OPTNARROWTREE,
   OPTPAGERSTOP,
   OPTPIPEDECODE,
@@ -479,6 +494,16 @@ enum
   OPTPGPAUTOINLINE,
   OPTPGPREPLYINLINE,
 
+  /* news options */
+
+#ifdef USE_NNTP
+  OPTSHOWNEWNEWS,
+  OPTSHOWONLYUNREAD,
+  OPTSAVEUNSUB,
+  OPTLOADDESC,
+  OPTXCOMMENTTO,
+#endif /* USE_NNTP */
+
   /* pseudo options */
 
   OPTAUXSORT,		/* (pseudo) using auxillary sort function */
@@ -499,6 +524,7 @@ enum
   OPTSORTSUBTHREADS,	/* (pseudo) used when $sort_aux changes */
   OPTNEEDRESCORE,	/* (pseudo) set when the `score' command is used */
   OPTATTACHMSG,		/* (pseudo) used by attach-message */
+  OPTHIDEREAD,		/* (pseudo) whether or not hide read messages */
   OPTKEEPQUIET,		/* (pseudo) shut up the message and refresh
 			 * 	    functions while we are executing an
 			 * 	    external program.
@@ -509,6 +535,12 @@ enum
   OPTDONTHANDLEPGPKEYS,	/* (pseudo) used to extract PGP keys */
   OPTUNBUFFEREDINPUT,   /* (pseudo) don't use key buffer */
 
+#ifdef USE_NNTP
+  OPTNEWS,		/* (pseudo) used to change reader mode */
+  OPTNEWSSEND,		/* (pseudo) used to change behavior when posting */
+  OPTNEWSCACHE,		/* (pseudo) used to indicate if news cache exist */
+#endif
+
   OPTMAX
 };
 
@@ -588,6 +620,13 @@ typedef struct envelope
   char *supersedes;
   char *date;
   char *x_label;
+  char *organization;
+#ifdef USE_NNTP
+  char *newsgroups;
+  char *xref;
+  char *followup_to;
+  char *x_comment_to;
+#endif
   BUFFER *spam;
   LIST *references;		/* message references (in reverse order) */
   LIST *in_reply_to;		/* in-reply-to header content */
@@ -757,6 +796,9 @@ typedef struct header
   ENVELOPE *env;		/* envelope information */
   BODY *content;		/* list of MIME parts */
   char *path;
+#ifdef USE_NNTP
+  int article_num;
+#endif
   
   char *tree;           	/* character string to print thread tree */
   THREAD *thread;
@@ -772,7 +814,7 @@ typedef struct header
   int refno;			/* message number on server */
 #endif
 
-#if defined USE_POP || defined USE_IMAP
+#if defined USE_POP || defined USE_IMAP || defined USE_NNTP
   void *data;            	/* driver-specific data */
 #endif
   
diff -udprP mutt-1.5.21/mutt.h.orig mutt-nntp-sidebar/mutt.h.orig
--- mutt-1.5.21/mutt.h.orig	2010-09-13 10:19:55.000000000 -0700
+++ mutt-nntp-sidebar/mutt.h.orig	2011-06-03 07:05:58.939622665 -0700
@@ -419,6 +419,7 @@ enum
   OPTSAVEEMPTY,
   OPTSAVENAME,
   OPTSCORE,
+  OPTSIDEBAR,
   OPTSIGDASHES,
   OPTSIGONTOP,
   OPTSORTRE,
@@ -859,6 +860,7 @@ typedef struct _context
 {
   char *path;
   FILE *fp;
+  time_t atime;
   time_t mtime;
   off_t size;
   off_t vsize;
@@ -893,6 +895,7 @@ typedef struct _context
   unsigned int quiet : 1;	/* inhibit status messages? */
   unsigned int collapsed : 1;   /* are all threads collapsed? */
   unsigned int closing : 1;	/* mailbox is being closed */
+  unsigned int peekonly : 1;	/* just taking a glance, revert atime */
 
   /* driver hooks */
   void *data;			/* driver specific data */
diff -udprP mutt-1.5.21/muttlib.c mutt-nntp-sidebar/muttlib.c
--- mutt-1.5.21/muttlib.c	2011-06-03 07:06:32.526288485 -0700
+++ mutt-nntp-sidebar/muttlib.c	2011-06-03 07:05:58.916289332 -0700
@@ -337,7 +337,7 @@ void mutt_free_header (HEADER **h)
 #ifdef MIXMASTER
   mutt_free_list (&(*h)->chain);
 #endif
-#if defined USE_POP || defined USE_IMAP
+#if defined USE_POP || defined USE_IMAP || defined USE_NNTP
   FREE (&(*h)->data);
 #endif
   FREE (h);		/* __FREE_CHECKED__ */
@@ -722,6 +722,13 @@ void mutt_free_envelope (ENVELOPE **p)
   FREE (&(*p)->supersedes);
   FREE (&(*p)->date);
   FREE (&(*p)->x_label);
+  FREE (&(*p)->organization);
+#ifdef USE_NNTP
+  FREE (&(*p)->newsgroups);
+  FREE (&(*p)->xref);
+  FREE (&(*p)->followup_to);
+  FREE (&(*p)->x_comment_to);
+#endif
 
   mutt_buffer_free (&(*p)->spam);
 
@@ -1573,6 +1580,14 @@ int mutt_save_confirm (const char *s, st
     }
   }
 
+#ifdef USE_NNTP
+  if (magic == M_NNTP)
+  {
+    mutt_error _("Can't save message to newsserver.");
+    return 0;
+  }
+#endif
+
   if (stat (s, st) != -1)
   {
     if (magic == -1)
diff -udprP mutt-1.5.21/muttlib.c.orig mutt-nntp-sidebar/muttlib.c.orig
--- mutt-1.5.21/muttlib.c.orig	1969-12-31 17:00:00.000000000 -0700
+++ mutt-nntp-sidebar/muttlib.c.orig	2011-06-03 07:05:58.932955999 -0700
@@ -0,0 +1,2013 @@
+/*
+ * Copyright (C) 1996-2000,2007 Michael R. Elkins <me@mutt.org>
+ * Copyright (C) 1999-2008 Thomas Roessler <roessler@does-not-exist.org>
+ * 
+ *     This program is free software; you can redistribute it and/or modify
+ *     it under the terms of the GNU General Public License as published by
+ *     the Free Software Foundation; either version 2 of the License, or
+ *     (at your option) any later version.
+ * 
+ *     This program is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ * 
+ *     You should have received a copy of the GNU General Public License
+ *     along with this program; if not, write to the Free Software
+ *     Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */ 
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include "mutt.h"
+#include "mutt_curses.h"
+#include "mime.h"
+#include "mailbox.h"
+#include "mx.h"
+#include "url.h"
+
+#ifdef USE_IMAP
+#include "imap.h"
+#endif
+
+#include "mutt_crypt.h"
+
+#include <string.h>
+#include <ctype.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <sys/wait.h>
+#include <errno.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <time.h>
+#include <sys/types.h>
+#include <utime.h>
+
+BODY *mutt_new_body (void)
+{
+  BODY *p = (BODY *) safe_calloc (1, sizeof (BODY));
+    
+  p->disposition = DISPATTACH;
+  p->use_disp = 1;
+  return (p);
+}
+
+
+/* Modified by blong to accept a "suggestion" for file name.  If
+ * that file exists, then construct one with unique name but 
+ * keep any extension.  This might fail, I guess.
+ * Renamed to mutt_adv_mktemp so I only have to change where it's
+ * called, and not all possible cases.
+ */
+void mutt_adv_mktemp (char *s, size_t l)
+{
+  char buf[_POSIX_PATH_MAX];
+  char tmp[_POSIX_PATH_MAX];
+  char *period;
+  size_t sl;
+  struct stat sb;
+  
+  strfcpy (buf, NONULL (Tempdir), sizeof (buf));
+  mutt_expand_path (buf, sizeof (buf));
+  if (s[0] == '\0')
+  {
+    snprintf (s, l, "%s/muttXXXXXX", buf);
+    mktemp (s);
+  }
+  else
+  {
+    strfcpy (tmp, s, sizeof (tmp));
+    mutt_sanitize_filename (tmp, 1);
+    snprintf (s, l, "%s/%s", buf, tmp);
+    if (lstat (s, &sb) == -1 && errno == ENOENT)
+      return;
+    if ((period = strrchr (tmp, '.')) != NULL)
+      *period = 0;
+    snprintf (s, l, "%s/%s.XXXXXX", buf, tmp);
+    mktemp (s);
+    if (period != NULL)
+    {
+      *period = '.';
+      sl = mutt_strlen(s);
+      strfcpy(s + sl, period, l - sl);
+    }
+  }
+}
+
+/* create a send-mode duplicate from a receive-mode body */
+
+int mutt_copy_body (FILE *fp, BODY **tgt, BODY *src)
+{
+  char tmp[_POSIX_PATH_MAX];
+  BODY *b;
+
+  PARAMETER *par, **ppar;
+  
+  short use_disp;
+
+  if (src->filename)
+  {
+    use_disp = 1;
+    strfcpy (tmp, src->filename, sizeof (tmp));
+  }
+  else
+  {
+    use_disp = 0;
+    tmp[0] = '\0';
+  }
+
+  mutt_adv_mktemp (tmp, sizeof (tmp));
+  if (mutt_save_attachment (fp, src, tmp, 0, NULL) == -1)
+    return -1;
+      
+  *tgt = mutt_new_body ();
+  b = *tgt;
+
+  memcpy (b, src, sizeof (BODY));
+  b->parts = NULL;
+  b->next  = NULL;
+
+  b->filename = safe_strdup (tmp);
+  b->use_disp = use_disp;
+  b->unlink = 1;
+
+  if (mutt_is_text_part (b))
+    b->noconv = 1;
+
+  b->xtype = safe_strdup (b->xtype);
+  b->subtype = safe_strdup (b->subtype);
+  b->form_name = safe_strdup (b->form_name);
+  b->filename = safe_strdup (b->filename);
+  b->d_filename = safe_strdup (b->d_filename);
+  b->description = safe_strdup (b->description);
+
+  /* 
+   * we don't seem to need the HEADER structure currently.
+   * XXX - this may change in the future
+   */
+
+  if (b->hdr) b->hdr = NULL;
+  
+  /* copy parameters */
+  for (par = b->parameter, ppar = &b->parameter; par; ppar = &(*ppar)->next, par = par->next)
+  {
+    *ppar = mutt_new_parameter ();
+    (*ppar)->attribute = safe_strdup (par->attribute);
+    (*ppar)->value = safe_strdup (par->value);
+  }
+
+  mutt_stamp_attachment (b);
+  
+  return 0;
+}
+
+
+
+void mutt_free_body (BODY **p)
+{
+  BODY *a = *p, *b;
+
+  while (a)
+  {
+    b = a;
+    a = a->next; 
+
+    if (b->parameter)
+      mutt_free_parameter (&b->parameter);
+    if (b->filename)
+    {
+      if (b->unlink)
+	unlink (b->filename);
+      dprint (1, (debugfile, "mutt_free_body: %sunlinking %s.\n",
+	    b->unlink ? "" : "not ", b->filename));
+    }
+
+    FREE (&b->filename);
+    FREE (&b->content);
+    FREE (&b->xtype);
+    FREE (&b->subtype);
+    FREE (&b->description);
+    FREE (&b->form_name);
+
+    if (b->hdr)
+    {
+      /* Don't free twice (b->hdr->content = b->parts) */
+      b->hdr->content = NULL;
+      mutt_free_header(&b->hdr);
+    }
+
+    if (b->parts)
+      mutt_free_body (&b->parts);
+
+    FREE (&b);
+  }
+
+  *p = 0;
+}
+
+void mutt_free_parameter (PARAMETER **p)
+{
+  PARAMETER *t = *p;
+  PARAMETER *o;
+
+  while (t)
+  {
+    FREE (&t->attribute);
+    FREE (&t->value);
+    o = t;
+    t = t->next;
+    FREE (&o);
+  }
+  *p = 0;
+}
+
+LIST *mutt_add_list (LIST *head, const char *data)
+{
+  size_t len = mutt_strlen (data);
+
+  return mutt_add_list_n (head, data, len ? len + 1 : 0);
+}
+
+LIST *mutt_add_list_n (LIST *head, const void *data, size_t len)
+{
+  LIST *tmp;
+  
+  for (tmp = head; tmp && tmp->next; tmp = tmp->next)
+    ;
+  if (tmp)
+  {
+    tmp->next = safe_malloc (sizeof (LIST));
+    tmp = tmp->next;
+  }
+  else
+    head = tmp = safe_malloc (sizeof (LIST));
+  
+  tmp->data = safe_malloc (len);
+  if (len)
+    memcpy (tmp->data, data, len);
+  tmp->next = NULL;
+  return head;
+}
+
+LIST *mutt_find_list (LIST *l, const char *data)
+{
+  LIST *p = l;
+
+  while (p)
+  {
+    if (data == p->data)
+      return p;
+    if (data && p->data && mutt_strcmp (p->data, data) == 0)
+      return p;
+    p = p->next;
+  }
+  return NULL;
+}
+
+int mutt_remove_from_rx_list (RX_LIST **l, const char *str)
+{
+  RX_LIST *p, *last = NULL;
+  int rv = -1;
+
+  if (mutt_strcmp ("*", str) == 0)
+  {
+    mutt_free_rx_list (l);    /* ``unCMD *'' means delete all current entries */
+    rv = 0;
+  }
+  else
+  {
+    p = *l;
+    last = NULL;
+    while (p)
+    {
+      if (ascii_strcasecmp (str, p->rx->pattern) == 0)
+      {
+	mutt_free_regexp (&p->rx);
+	if (last)
+	  last->next = p->next;
+	else
+	  (*l) = p->next;
+	FREE (&p);
+	rv = 0;
+      }
+      else
+      {
+	last = p;
+	p = p->next;
+      }
+    }
+  }
+  return (rv);
+}
+
+void mutt_free_list (LIST **list)
+{
+  LIST *p;
+  
+  if (!list) return;
+  while (*list)
+  {
+    p = *list;
+    *list = (*list)->next;
+    FREE (&p->data);
+    FREE (&p);
+  }
+}
+
+HEADER *mutt_dup_header(HEADER *h)
+{
+  HEADER *hnew;
+
+  hnew = mutt_new_header();
+  memcpy(hnew, h, sizeof (HEADER));
+  return hnew;
+}
+
+void mutt_free_header (HEADER **h)
+{
+  if(!h || !*h) return;
+  mutt_free_envelope (&(*h)->env);
+  mutt_free_body (&(*h)->content);
+  FREE (&(*h)->maildir_flags);
+  FREE (&(*h)->tree);
+  FREE (&(*h)->path);
+#ifdef MIXMASTER
+  mutt_free_list (&(*h)->chain);
+#endif
+#if defined USE_POP || defined USE_IMAP
+  FREE (&(*h)->data);
+#endif
+  FREE (h);		/* __FREE_CHECKED__ */
+}
+
+/* returns true if the header contained in "s" is in list "t" */
+int mutt_matches_ignore (const char *s, LIST *t)
+{
+  for (; t; t = t->next)
+  {
+    if (!ascii_strncasecmp (s, t->data, mutt_strlen (t->data)) || *t->data == '*')
+      return 1;
+  }
+  return 0;
+}
+
+/* prepend the path part of *path to *link */
+void mutt_expand_link (char *newpath, const char *path, const char *link)
+{
+  const char *lb = NULL;
+  size_t len;
+
+  /* link is full path */
+  if (*link == '/')
+  {
+    strfcpy (newpath, link, _POSIX_PATH_MAX);
+    return;
+  }
+
+  if ((lb = strrchr (path, '/')) == NULL)
+  {
+    /* no path in link */
+    strfcpy (newpath, link, _POSIX_PATH_MAX);
+    return;
+  }
+
+  len = lb - path + 1;
+  memcpy (newpath, path, len);
+  strfcpy (newpath + len, link, _POSIX_PATH_MAX - len);
+}
+
+char *mutt_expand_path (char *s, size_t slen)
+{
+  return _mutt_expand_path (s, slen, 0);
+}
+
+char *_mutt_expand_path (char *s, size_t slen, int rx)
+{
+  char p[_POSIX_PATH_MAX] = "";
+  char q[_POSIX_PATH_MAX] = "";
+  char tmp[_POSIX_PATH_MAX];
+  char *t;
+
+  char *tail = ""; 
+
+  int recurse = 0;
+  
+  do 
+  {
+    recurse = 0;
+
+    switch (*s)
+    {
+      case '~':
+      {
+	if (*(s + 1) == '/' || *(s + 1) == 0)
+	{
+	  strfcpy (p, NONULL(Homedir), sizeof (p));
+	  tail = s + 1;
+	}
+	else
+	{
+	  struct passwd *pw;
+	  if ((t = strchr (s + 1, '/'))) 
+	    *t = 0;
+
+	  if ((pw = getpwnam (s + 1)))
+	  {
+	    strfcpy (p, pw->pw_dir, sizeof (p));
+	    if (t)
+	    {
+	      *t = '/';
+	      tail = t;
+	    }
+	    else
+	      tail = "";
+	  }
+	  else
+	  {
+	    /* user not found! */
+	    if (t)
+	      *t = '/';
+	    *p = '\0';
+	    tail = s;
+	  }
+	}
+      }
+      break;
+      
+      case '=':
+      case '+':    
+      {
+#ifdef USE_IMAP
+	/* if folder = {host} or imap[s]://host/: don't append slash */
+	if (mx_is_imap (NONULL (Maildir)) &&
+	    (Maildir[strlen (Maildir) - 1] == '}' ||
+	     Maildir[strlen (Maildir) - 1] == '/'))
+	  strfcpy (p, NONULL (Maildir), sizeof (p));
+	else
+#endif
+	if (Maildir && *Maildir && Maildir[strlen (Maildir) - 1] == '/')
+	  strfcpy (p, NONULL (Maildir), sizeof (p));
+	else
+	  snprintf (p, sizeof (p), "%s/", NONULL (Maildir));
+	
+	tail = s + 1;
+      }
+      break;
+      
+      /* elm compatibility, @ expands alias to user name */
+    
+      case '@':
+      {
+	HEADER *h;
+	ADDRESS *alias;
+	
+	if ((alias = mutt_lookup_alias (s + 1)))
+	{
+	  h = mutt_new_header();
+	  h->env = mutt_new_envelope();
+	  h->env->from = h->env->to = alias;
+	  mutt_default_save (p, sizeof (p), h);
+	  h->env->from = h->env->to = NULL;
+	  mutt_free_header (&h);
+	  /* Avoid infinite recursion if the resulting folder starts with '@' */
+	  if (*p != '@')
+	    recurse = 1;
+	  
+	  tail = "";
+	}
+      }
+      break;
+      
+      case '>':
+      {
+	strfcpy (p, NONULL(Inbox), sizeof (p));
+	tail = s + 1;
+      }
+      break;
+      
+      case '<':
+      {
+	strfcpy (p, NONULL(Outbox), sizeof (p));
+	tail = s + 1;
+      }
+      break;
+      
+      case '!':
+      {
+	if (*(s+1) == '!')
+	{
+	  strfcpy (p, NONULL(LastFolder), sizeof (p));
+	  tail = s + 2;
+	}
+	else 
+	{
+	  strfcpy (p, NONULL(Spoolfile), sizeof (p));
+	  tail = s + 1;
+	}
+      }
+      break;
+      
+      case '-':
+      {
+	strfcpy (p, NONULL(LastFolder), sizeof (p));
+	tail = s + 1;
+      }
+      break;
+      
+      case '^':        
+      {
+	strfcpy (p, NONULL(CurrentFolder), sizeof (p));
+	tail = s + 1;
+      }
+      break;
+
+      default:
+      {
+	*p = '\0';
+	tail = s;
+      }
+    }
+
+    if (rx && *p && !recurse)
+    {
+      mutt_rx_sanitize_string (q, sizeof (q), p);
+      snprintf (tmp, sizeof (tmp), "%s%s", q, tail);
+    }
+    else
+      snprintf (tmp, sizeof (tmp), "%s%s", p, tail);
+    
+    strfcpy (s, tmp, slen);
+  }
+  while (recurse);
+
+#ifdef USE_IMAP
+  /* Rewrite IMAP path in canonical form - aids in string comparisons of
+   * folders. May possibly fail, in which case s should be the same. */
+  if (mx_is_imap (s))
+    imap_expand_path (s, slen);
+#endif
+
+  return (s);
+}
+
+/* Extract the real name from /etc/passwd's GECOS field.
+ * When set, honor the regular expression in GecosMask,
+ * otherwise assume that the GECOS field is a 
+ * comma-separated list.
+ * Replace "&" by a capitalized version of the user's login
+ * name.
+ */
+
+char *mutt_gecos_name (char *dest, size_t destlen, struct passwd *pw)
+{
+  regmatch_t pat_match[1];
+  size_t pwnl;
+  int idx;
+  char *p;
+  
+  if (!pw || !pw->pw_gecos) 
+    return NULL;
+
+  memset (dest, 0, destlen);
+  
+  if (GecosMask.rx)
+  {
+    if (regexec (GecosMask.rx, pw->pw_gecos, 1, pat_match, 0) == 0)
+      strfcpy (dest, pw->pw_gecos + pat_match[0].rm_so, 
+	       MIN (pat_match[0].rm_eo - pat_match[0].rm_so + 1, destlen));
+  }
+  else if ((p = strchr (pw->pw_gecos, ',')))
+    strfcpy (dest, pw->pw_gecos, MIN (destlen, p - pw->pw_gecos + 1));
+  else
+    strfcpy (dest, pw->pw_gecos, destlen);
+
+  pwnl = strlen (pw->pw_name);
+
+  for (idx = 0; dest[idx]; idx++)
+  {
+    if (dest[idx] == '&')
+    {
+      memmove (&dest[idx + pwnl], &dest[idx + 1],
+	       MAX((ssize_t)(destlen - idx - pwnl - 1), 0));
+      memcpy (&dest[idx], pw->pw_name, MIN(destlen - idx - 1, pwnl));
+      dest[idx] = toupper ((unsigned char) dest[idx]);
+    }
+  }
+      
+  return dest;
+}
+  
+
+char *mutt_get_parameter (const char *s, PARAMETER *p)
+{
+  for (; p; p = p->next)
+    if (ascii_strcasecmp (s, p->attribute) == 0)
+      return (p->value);
+
+  return NULL;
+}
+
+void mutt_set_parameter (const char *attribute, const char *value, PARAMETER **p)
+{
+  PARAMETER *q;
+
+  if (!value)
+  {
+    mutt_delete_parameter (attribute, p);
+    return;
+  }
+  
+  for(q = *p; q; q = q->next)
+  {
+    if (ascii_strcasecmp (attribute, q->attribute) == 0)
+    {
+      mutt_str_replace (&q->value, value);
+      return;
+    }
+  }
+  
+  q = mutt_new_parameter();
+  q->attribute = safe_strdup(attribute);
+  q->value = safe_strdup(value);
+  q->next = *p;
+  *p = q;
+}
+
+void mutt_delete_parameter (const char *attribute, PARAMETER **p)
+{
+  PARAMETER *q;
+  
+  for (q = *p; q; p = &q->next, q = q->next)
+  {
+    if (ascii_strcasecmp (attribute, q->attribute) == 0)
+    {
+      *p = q->next;
+      q->next = NULL;
+      mutt_free_parameter (&q);
+      return;
+    }
+  }
+}
+
+/* returns 1 if Mutt can't display this type of data, 0 otherwise */
+int mutt_needs_mailcap (BODY *m)
+{
+  switch (m->type)
+  {
+    case TYPETEXT:
+      /* we can display any text, overridable by auto_view */
+      return 0;
+      break;
+
+    case TYPEAPPLICATION:
+      if((WithCrypto & APPLICATION_PGP) && mutt_is_application_pgp(m))
+	return 0;
+      if((WithCrypto & APPLICATION_SMIME) && mutt_is_application_smime(m))
+	return 0;
+      break;
+
+    case TYPEMULTIPART:
+    case TYPEMESSAGE:
+      return 0;
+  }
+
+  return 1;
+}
+
+int mutt_is_text_part (BODY *b)
+{
+  int t = b->type;
+  char *s = b->subtype;
+  
+  if ((WithCrypto & APPLICATION_PGP) && mutt_is_application_pgp (b))
+    return 0;
+
+  if (t == TYPETEXT)
+    return 1;
+
+  if (t == TYPEMESSAGE)
+  {
+    if (!ascii_strcasecmp ("delivery-status", s))
+      return 1;
+  }
+
+  if ((WithCrypto & APPLICATION_PGP) && t == TYPEAPPLICATION)
+  {
+    if (!ascii_strcasecmp ("pgp-keys", s))
+      return 1;
+  }
+
+  return 0;
+}
+
+void mutt_free_envelope (ENVELOPE **p)
+{
+  if (!*p) return;
+  rfc822_free_address (&(*p)->return_path);
+  rfc822_free_address (&(*p)->from);
+  rfc822_free_address (&(*p)->to);
+  rfc822_free_address (&(*p)->cc);
+  rfc822_free_address (&(*p)->bcc);
+  rfc822_free_address (&(*p)->sender);
+  rfc822_free_address (&(*p)->reply_to);
+  rfc822_free_address (&(*p)->mail_followup_to);
+
+  FREE (&(*p)->list_post);
+  FREE (&(*p)->subject);
+  /* real_subj is just an offset to subject and shouldn't be freed */
+  FREE (&(*p)->message_id);
+  FREE (&(*p)->supersedes);
+  FREE (&(*p)->date);
+  FREE (&(*p)->x_label);
+
+  mutt_buffer_free (&(*p)->spam);
+
+  mutt_free_list (&(*p)->references);
+  mutt_free_list (&(*p)->in_reply_to);
+  mutt_free_list (&(*p)->userhdrs);
+  FREE (p);		/* __FREE_CHECKED__ */
+}
+
+/* move all the headers from extra not present in base into base */
+void mutt_merge_envelopes(ENVELOPE* base, ENVELOPE** extra)
+{
+  /* copies each existing element if necessary, and sets the element
+  * to NULL in the source so that mutt_free_envelope doesn't leave us
+  * with dangling pointers. */
+#define MOVE_ELEM(h) if (!base->h) { base->h = (*extra)->h; (*extra)->h = NULL; }
+  MOVE_ELEM(return_path);
+  MOVE_ELEM(from);
+  MOVE_ELEM(to);
+  MOVE_ELEM(cc);
+  MOVE_ELEM(bcc);
+  MOVE_ELEM(sender);
+  MOVE_ELEM(reply_to);
+  MOVE_ELEM(mail_followup_to);
+  MOVE_ELEM(list_post);
+  MOVE_ELEM(message_id);
+  MOVE_ELEM(supersedes);
+  MOVE_ELEM(date);
+  MOVE_ELEM(x_label);
+  if (!base->refs_changed)
+  {
+    MOVE_ELEM(references);
+  }
+  if (!base->irt_changed)
+  {
+    MOVE_ELEM(in_reply_to);
+  }
+  
+  /* real_subj is subordinate to subject */
+  if (!base->subject)
+  {
+    base->subject = (*extra)->subject;
+    base->real_subj = (*extra)->real_subj;
+    (*extra)->subject = NULL;
+    (*extra)->real_subj = NULL;
+  }
+  /* spam and user headers should never be hashed, and the new envelope may
+    * have better values. Use new versions regardless. */
+  mutt_buffer_free (&base->spam);
+  mutt_free_list (&base->userhdrs);
+  MOVE_ELEM(spam);
+  MOVE_ELEM(userhdrs);
+#undef MOVE_ELEM
+  
+  mutt_free_envelope(extra);
+}
+
+void _mutt_mktemp (char *s, size_t slen, const char *src, int line)
+{
+  size_t n = snprintf (s, slen, "%s/mutt-%s-%d-%d-%ld%ld", NONULL (Tempdir), NONULL (Hostname),
+      (int) getuid (), (int) getpid (), random (), random ());
+  if (n >= slen)
+    dprint (1, (debugfile, "%s:%d: ERROR: insufficient buffer space to hold temporary filename! slen=%zu but need %zu\n",
+	    src, line, slen, n));
+  dprint (3, (debugfile, "%s:%d: mutt_mktemp returns \"%s\".\n", src, line, s));
+  if (unlink (s) && errno != ENOENT)
+    dprint (1, (debugfile, "%s:%d: ERROR: unlink(\"%s\"): %s (errno %d)\n", src, line, s, strerror (errno), errno));
+}
+
+void mutt_free_alias (ALIAS **p)
+{
+  ALIAS *t;
+
+  while (*p)
+  {
+    t = *p;
+    *p = (*p)->next;
+    mutt_alias_delete_reverse (t);
+    FREE (&t->name);
+    rfc822_free_address (&t->addr);
+    FREE (&t);
+  }
+}
+
+/* collapse the pathname using ~ or = when possible */
+void mutt_pretty_mailbox (char *s, size_t buflen)
+{
+  char *p = s, *q = s;
+  size_t len;
+  url_scheme_t scheme;
+  char tmp[PATH_MAX];
+
+  scheme = url_check_scheme (s);
+
+#ifdef USE_IMAP
+  if (scheme == U_IMAP || scheme == U_IMAPS)
+  {
+    imap_pretty_mailbox (s);
+    return;
+  }
+#endif
+
+  /* if s is an url, only collapse path component */
+  if (scheme != U_UNKNOWN)
+  {
+    p = strchr(s, ':')+1;
+    if (!strncmp (p, "//", 2))
+      q = strchr (p+2, '/');
+    if (!q)
+      q = strchr (p, '\0');
+    p = q;
+  }
+
+  /* cleanup path */
+  if (strstr (p, "//") || strstr (p, "/./"))
+  {
+    /* first attempt to collapse the pathname, this is more
+     * lightweight than realpath() and doesn't resolve links
+     */
+    while (*p)
+    {
+      if (*p == '/' && p[1] == '/')
+      {
+	*q++ = '/';
+	p += 2;
+      }
+      else if (p[0] == '/' && p[1] == '.' && p[2] == '/')
+      {
+	*q++ = '/';
+	p += 3;
+      }
+      else
+	*q++ = *p++;
+    }
+    *q = 0;
+  }
+  else if (strstr (p, "..") && 
+	   (scheme == U_UNKNOWN || scheme == U_FILE) &&
+	   realpath (p, tmp))
+    strfcpy (p, tmp, buflen - (p - s));
+
+  if (mutt_strncmp (s, Maildir, (len = mutt_strlen (Maildir))) == 0 &&
+      s[len] == '/')
+  {
+    *s++ = '=';
+    memmove (s, s + len, mutt_strlen (s + len) + 1);
+  }
+  else if (mutt_strncmp (s, Homedir, (len = mutt_strlen (Homedir))) == 0 &&
+	   s[len] == '/')
+  {
+    *s++ = '~';
+    memmove (s, s + len - 1, mutt_strlen (s + len - 1) + 1);
+  }
+}
+
+void mutt_pretty_size (char *s, size_t len, LOFF_T n)
+{
+  if (n == 0)
+    strfcpy (s, "0K", len);
+  else if (n < 10189) /* 0.1K - 9.9K */
+    snprintf (s, len, "%3.1fK", (n < 103) ? 0.1 : n / 1024.0);
+  else if (n < 1023949) /* 10K - 999K */
+  {
+    /* 51 is magic which causes 10189/10240 to be rounded up to 10 */
+    snprintf (s, len, OFF_T_FMT "K", (n + 51) / 1024);
+  }
+  else if (n < 10433332) /* 1.0M - 9.9M */
+    snprintf (s, len, "%3.1fM", n / 1048576.0);
+  else /* 10M+ */
+  {
+    /* (10433332 + 52428) / 1048576 = 10 */
+    snprintf (s, len, OFF_T_FMT "M", (n + 52428) / 1048576);
+  }
+}
+
+void mutt_expand_file_fmt (char *dest, size_t destlen, const char *fmt, const char *src)
+{
+  char tmp[LONG_STRING];
+  
+  mutt_quote_filename (tmp, sizeof (tmp), src);
+  mutt_expand_fmt (dest, destlen, fmt, tmp);
+}
+
+void mutt_expand_fmt (char *dest, size_t destlen, const char *fmt, const char *src)
+{
+  const char *p;
+  char *d;
+  size_t slen;
+  int found = 0;
+
+  slen = mutt_strlen (src);
+  destlen--;
+  
+  for (p = fmt, d = dest; destlen && *p; p++)
+  {
+    if (*p == '%') 
+    {
+      switch (p[1])
+      {
+	case '%':
+	  *d++ = *p++;
+	  destlen--;
+	  break;
+	case 's':
+	  found = 1;
+	  strfcpy (d, src, destlen + 1);
+	  d       += destlen > slen ? slen : destlen;
+	  destlen -= destlen > slen ? slen : destlen;
+	  p++;
+	  break;
+	default:
+	  *d++ = *p; 
+	  destlen--;
+	  break;
+      }
+    }
+    else
+    {
+      *d++ = *p;
+      destlen--;
+    }
+  }
+  
+  *d = '\0';
+  
+  if (!found && destlen > 0)
+  {
+    safe_strcat (dest, destlen, " ");
+    safe_strcat (dest, destlen, src);
+  }
+  
+}
+
+/* return 0 on success, -1 on abort, 1 on error */
+int mutt_check_overwrite (const char *attname, const char *path,
+				char *fname, size_t flen, int *append, char **directory) 
+{
+  int rc = 0;
+  char tmp[_POSIX_PATH_MAX];
+  struct stat st;
+
+  strfcpy (fname, path, flen);
+  if (access (fname, F_OK) != 0)
+    return 0;
+  if (stat (fname, &st) != 0)
+    return -1;
+  if (S_ISDIR (st.st_mode))
+  {
+    if (directory)
+    {
+      switch (mutt_multi_choice
+	      (_("File is a directory, save under it? [(y)es, (n)o, (a)ll]"), _("yna")))
+      {
+	case 3:		/* all */
+	  mutt_str_replace (directory, fname);
+	  break;
+	case 1:		/* yes */
+	  FREE (directory);		/* __FREE_CHECKED__ */
+	  break;
+	case -1:	/* abort */
+	  FREE (directory); 		/* __FREE_CHECKED__ */
+	  return -1;
+	case  2:	/* no */
+	  FREE (directory);		/* __FREE_CHECKED__ */
+	  return 1;
+      }
+    }
+    else if ((rc = mutt_yesorno (_("File is a directory, save under it?"), M_YES)) != M_YES)
+      return (rc == M_NO) ? 1 : -1;
+
+    if (!attname || !attname[0])
+    {
+      tmp[0] = 0;
+      if (mutt_get_field (_("File under directory: "), tmp, sizeof (tmp),
+				      M_FILE | M_CLEAR) != 0 || !tmp[0])
+	return (-1);
+      mutt_concat_path (fname, path, tmp, flen);
+    }
+    else
+      mutt_concat_path (fname, path, mutt_basename (attname), flen);
+  }
+  
+  if (*append == 0 && access (fname, F_OK) == 0)
+  {
+    switch (mutt_multi_choice
+	    (_("File exists, (o)verwrite, (a)ppend, or (c)ancel?"), _("oac")))
+    {
+      case -1: /* abort */
+        return -1;
+      case 3:  /* cancel */
+	return 1;
+
+      case 2: /* append */
+        *append = M_SAVE_APPEND;
+        break;
+      case 1: /* overwrite */
+        *append = M_SAVE_OVERWRITE;
+        break;
+    }
+  }
+  return 0;
+}
+
+void mutt_save_path (char *d, size_t dsize, ADDRESS *a)
+{
+  if (a && a->mailbox)
+  {
+    strfcpy (d, a->mailbox, dsize);
+    if (!option (OPTSAVEADDRESS))
+    {
+      char *p;
+
+      if ((p = strpbrk (d, "%@")))
+	*p = 0;
+    }
+    mutt_strlower (d);
+  }
+  else
+    *d = 0;
+}
+
+void mutt_safe_path (char *s, size_t l, ADDRESS *a)
+{
+  char *p;
+
+  mutt_save_path (s, l, a);
+  for (p = s; *p; p++)
+    if (*p == '/' || ISSPACE (*p) || !IsPrint ((unsigned char) *p))
+      *p = '_';
+}
+
+
+void mutt_FormatString (char *dest,		/* output buffer */
+			size_t destlen,		/* output buffer len */
+			size_t col,		/* starting column (nonzero when called recursively) */
+			const char *src,	/* template string */
+			format_t *callback,	/* callback for processing */
+			unsigned long data,	/* callback data */
+			format_flag flags)	/* callback flags */
+{
+  char prefix[SHORT_STRING], buf[LONG_STRING], *cp, *wptr = dest, ch;
+  char ifstring[SHORT_STRING], elsestring[SHORT_STRING];
+  size_t wlen, count, len, wid;
+  pid_t pid;
+  FILE *filter;
+  int n;
+  char *recycler;
+
+  prefix[0] = '\0';
+  destlen--; /* save room for the terminal \0 */
+  wlen = (flags & M_FORMAT_ARROWCURSOR && option (OPTARROWCURSOR)) ? 3 : 0;
+  col += wlen;
+
+  if ((flags & M_FORMAT_NOFILTER) == 0)
+  {
+    int off = -1;
+
+    /* Do not consider filters if no pipe at end */
+    n = mutt_strlen(src);
+    if (n > 1 && src[n-1] == '|')
+    {
+      /* Scan backwards for backslashes */
+      off = n;
+      while (off > 0 && src[off-2] == '\\')
+        off--;
+    }
+
+    /* If number of backslashes is even, the pipe is real. */
+    /* n-off is the number of backslashes. */
+    if (off > 0 && ((n-off) % 2) == 0)
+    {
+      BUFFER *srcbuf, *word, *command;
+      char    srccopy[LONG_STRING];
+#ifdef DEBUG
+      int     i = 0;
+#endif
+
+      dprint(3, (debugfile, "fmtpipe = %s\n", src));
+
+      strncpy(srccopy, src, n);
+      srccopy[n-1] = '\0';
+
+      /* prepare BUFFERs */
+      srcbuf = mutt_buffer_from(NULL, srccopy);
+      srcbuf->dptr = srcbuf->data;
+      word = mutt_buffer_init(NULL);
+      command = mutt_buffer_init(NULL);
+
+      /* Iterate expansions across successive arguments */
+      do {
+        char *p;
+
+        /* Extract the command name and copy to command line */
+        dprint(3, (debugfile, "fmtpipe +++: %s\n", srcbuf->dptr));
+        if (word->data)
+          *word->data = '\0';
+        mutt_extract_token(word, srcbuf, 0);
+        dprint(3, (debugfile, "fmtpipe %2d: %s\n", i++, word->data));
+        mutt_buffer_addch(command, '\'');
+        mutt_FormatString(buf, sizeof(buf), 0, word->data, callback, data,
+                          flags | M_FORMAT_NOFILTER);
+        for (p = buf; p && *p; p++)
+        {
+          if (*p == '\'')
+            /* shell quoting doesn't permit escaping a single quote within
+             * single-quoted material.  double-quoting instead will lead
+             * shell variable expansions, so break out of the single-quoted
+             * span, insert a double-quoted single quote, and resume. */
+            mutt_buffer_addstr(command, "'\"'\"'");
+          else
+            mutt_buffer_addch(command, *p);
+        }
+        mutt_buffer_addch(command, '\'');
+        mutt_buffer_addch(command, ' ');
+      } while (MoreArgs(srcbuf));
+
+      dprint(3, (debugfile, "fmtpipe > %s\n", command->data));
+
+      col -= wlen;	/* reset to passed in value */
+      wptr = dest;      /* reset write ptr */
+      wlen = (flags & M_FORMAT_ARROWCURSOR && option (OPTARROWCURSOR)) ? 3 : 0;
+      if ((pid = mutt_create_filter(command->data, NULL, &filter, NULL)) != -1)
+      {
+	int rc;
+
+        n = fread(dest, 1, destlen /* already decremented */, filter);
+        safe_fclose (&filter);
+	rc = mutt_wait_filter(pid);
+	if (rc != 0)
+	  dprint(1, (debugfile, "format pipe command exited code %d\n", rc));
+	if (n > 0) {
+	  dest[n] = 0;
+	  while ((n > 0) && (dest[n-1] == '\n' || dest[n-1] == '\r'))
+	    dest[--n] = '\0';
+	  dprint(3, (debugfile, "fmtpipe < %s\n", dest));
+
+	  /* If the result ends with '%', this indicates that the filter
+	   * generated %-tokens that mutt can expand.  Eliminate the '%'
+	   * marker and recycle the string through mutt_FormatString().
+	   * To literally end with "%", use "%%". */
+	  if ((n > 0) && dest[n-1] == '%')
+	  {
+	    --n;
+	    dest[n] = '\0';               /* remove '%' */
+	    if ((n > 0) && dest[n-1] != '%')
+	    {
+	      recycler = safe_strdup(dest);
+	      if (recycler)
+	      {
+		/* destlen is decremented at the start of this function
+		 * to save space for the terminal nul char.  We can add
+		 * it back for the recursive call since the expansion of
+		 * format pipes does not try to append a nul itself.
+		 */
+		mutt_FormatString(dest, destlen+1, col, recycler, callback, data, flags);
+		FREE(&recycler);
+	      }
+	    }
+	  }
+	}
+	else
+	{
+	  /* read error */
+	  dprint(1, (debugfile, "error reading from fmtpipe: %s (errno=%d)\n", strerror(errno), errno));
+	  *wptr = 0;
+	}
+      }
+      else
+      {
+        /* Filter failed; erase write buffer */
+        *wptr = '\0';
+      }
+
+      mutt_buffer_free(&command);
+      mutt_buffer_free(&srcbuf);
+      mutt_buffer_free(&word);
+      return;
+    }
+  }
+
+  while (*src && wlen < destlen)
+  {
+    if (*src == '%')
+    {
+      if (*++src == '%')
+      {
+	*wptr++ = '%';
+	wlen++;
+	col++;
+	src++;
+	continue;
+      }
+
+      if (*src == '?')
+      {
+	flags |= M_FORMAT_OPTIONAL;
+	src++;
+      }
+      else
+      {
+	flags &= ~M_FORMAT_OPTIONAL;
+
+	/* eat the format string */
+	cp = prefix;
+	count = 0;
+	while (count < sizeof (prefix) &&
+	       (isdigit ((unsigned char) *src) || *src == '.' || *src == '-' || *src == '='))
+	{
+	  *cp++ = *src++;
+	  count++;
+	}
+	*cp = 0;
+      }
+
+      if (!*src)
+	break; /* bad format */
+
+      ch = *src++; /* save the character to switch on */
+
+      if (flags & M_FORMAT_OPTIONAL)
+      {
+        if (*src != '?')
+          break; /* bad format */
+        src++;
+
+        /* eat the `if' part of the string */
+        cp = ifstring;
+	count = 0;
+        while (count < sizeof (ifstring) && *src && *src != '?' && *src != '&')
+	{
+          *cp++ = *src++;
+	  count++;
+	}
+        *cp = 0;
+
+	/* eat the `else' part of the string (optional) */
+	if (*src == '&')
+	  src++; /* skip the & */
+	cp = elsestring;
+	count = 0;
+	while (count < sizeof (elsestring) && *src && *src != '?')
+	{
+	  *cp++ = *src++;
+	  count++;
+	}
+	*cp = 0;
+
+	if (!*src)
+	  break; /* bad format */
+
+        src++; /* move past the trailing `?' */
+      }
+
+      /* handle generic cases first */
+      if (ch == '>' || ch == '*')
+      {
+	/* %>X: right justify to EOL, left takes precedence
+	 * %*X: right justify to EOL, right takes precedence */
+	int soft = ch == '*';
+	int pl, pw;
+	if ((pl = mutt_charlen (src, &pw)) <= 0)
+	  pl = pw = 1;
+
+	/* see if there's room to add content, else ignore */
+        if ( DrawFullLine )
+        {
+	if ((col < COLS && wlen < destlen) || soft)
+	{
+	  int pad;
+
+	  /* get contents after padding */
+	  mutt_FormatString (buf, sizeof (buf), 0, src + pl, callback, data, flags);
+	  len = mutt_strlen (buf);
+	  wid = mutt_strwidth (buf);
+
+	  /* try to consume as many columns as we can, if we don't have
+	   * memory for that, use as much memory as possible */
+	  pad = (COLS - col - wid) / pw;
+	  if (pad > 0 && wlen + (pad * pl) + len > destlen)
+	    pad = ((signed)(destlen - wlen - len)) / pl;
+	  if (pad > 0)
+	  {
+	    while (pad--)
+	    {
+	      memcpy (wptr, src, pl);
+	      wptr += pl;
+	      wlen += pl;
+	      col += pw;
+	    }
+	  }
+	  else if (soft && pad < 0)
+	  {
+	    int offset = (flags & M_FORMAT_ARROWCURSOR && option (OPTARROWCURSOR)) ? 3 : 0;
+	    /* \0-terminate dest for length computation in mutt_wstr_trunc() */
+	    *wptr = 0;
+	    /* make sure right part is at most as wide as display */
+	    len = mutt_wstr_trunc (buf, destlen, COLS-offset, &wid);
+	    /* truncate left so that right part fits completely in */
+	    wlen = mutt_wstr_trunc (dest, destlen - len, col + pad*pw -offset, &col);
+	    wptr = dest + wlen;
+	  }
+	  if (len + wlen > destlen)
+	    len = mutt_wstr_trunc (buf, destlen - wlen, COLS - col, NULL);
+	  memcpy (wptr, buf, len);
+	  wptr += len;
+	  wlen += len;
+	  col += wid;
+	  src += pl;
+	}
+        }
+        else
+        {
+	if ((col < COLS-SidebarWidth && wlen < destlen) || soft)
+        {
+	  int pad;
+
+	  /* get contents after padding */
+	  mutt_FormatString (buf, sizeof (buf), 0, src + pl, callback, data, flags);
+	  len = mutt_strlen (buf);
+	  wid = mutt_strwidth (buf);
+
+	  /* try to consume as many columns as we can, if we don't have
+	   * memory for that, use as much memory as possible */
+	  pad = (COLS - SidebarWidth - col - wid) / pw;
+	  if (pad > 0 && wlen + (pad * pl) + len > destlen)
+	    pad = ((signed)(destlen - wlen - len)) / pl;
+	  if (pad > 0)
+	  {
+	    while (pad--)
+	    {
+	      memcpy (wptr, src, pl);
+	      wptr += pl;
+	      wlen += pl;
+	      col += pw;
+	    }
+	  }
+	  else if (soft && pad < 0)
+	  {
+	    /* \0-terminate dest for length computation in mutt_wstr_trunc() */
+	    *wptr = 0;
+	    /* make sure right part is at most as wide as display */
+	    len = mutt_wstr_trunc (buf, destlen, COLS, &wid);
+	    /* truncate left so that right part fits completely in */
+	    wlen = mutt_wstr_trunc (dest, destlen - len, col + pad, &col);
+	    wptr = dest + wlen;
+	  }
+	  if (len + wlen > destlen)
+	    len = mutt_wstr_trunc (buf, destlen - wlen, COLS - SidebarWidth - col, NULL);
+	  memcpy (wptr, buf, len);
+	  wptr += len;
+	  wlen += len;
+	  col += wid;
+	  src += pl;
+	}
+        }
+	break; /* skip rest of input */
+      }
+      else if (ch == '|')
+      {
+	/* pad to EOL */
+	int pl, pw, c;
+	if ((pl = mutt_charlen (src, &pw)) <= 0)
+	  pl = pw = 1;
+
+	/* see if there's room to add content, else ignore */
+	if (col < COLS && wlen < destlen)
+	{
+	  c = (COLS - col) / pw;
+	  if (c > 0 && wlen + (c * pl) > destlen)
+	    c = ((signed)(destlen - wlen)) / pl;
+	  while (c > 0)
+	  {
+	    memcpy (wptr, src, pl);
+	    wptr += pl;
+	    wlen += pl;
+	    col += pw;
+	    c--;
+	  }
+	  src += pl;
+	}
+	break; /* skip rest of input */
+      }
+      else
+      {
+	short tolower =  0;
+	short nodots  = 0;
+	
+	while (ch == '_' || ch == ':') 
+	{
+	  if (ch == '_')
+	    tolower = 1;
+	  else if (ch == ':') 
+	    nodots = 1;
+	  
+	  ch = *src++;
+	}
+	
+	/* use callback function to handle this case */
+	src = callback (buf, sizeof (buf), col, ch, src, prefix, ifstring, elsestring, data, flags);
+
+	if (tolower)
+	  mutt_strlower (buf);
+	if (nodots) 
+	{
+	  char *p = buf;
+	  for (; *p; p++)
+	    if (*p == '.')
+		*p = '_';
+	}
+	
+	if ((len = mutt_strlen (buf)) + wlen > destlen)
+	  len = mutt_wstr_trunc (buf, destlen - wlen, COLS - col, NULL);
+
+	memcpy (wptr, buf, len);
+	wptr += len;
+	wlen += len;
+	col += mutt_strwidth (buf);
+      }
+    }
+    else if (*src == '\\')
+    {
+      if (!*++src)
+	break;
+      switch (*src)
+      {
+	case 'n':
+	  *wptr = '\n';
+	  break;
+	case 't':
+	  *wptr = '\t';
+	  break;
+	case 'r':
+	  *wptr = '\r';
+	  break;
+	case 'f':
+	  *wptr = '\f';
+	  break;
+	case 'v':
+	  *wptr = '\v';
+	  break;
+	default:
+	  *wptr = *src;
+	  break;
+      }
+      src++;
+      wptr++;
+      wlen++;
+      col++;
+    }
+    else
+    {
+      int tmp, w;
+      /* in case of error, simply copy byte */
+      if ((tmp = mutt_charlen (src, &w)) < 0)
+	tmp = w = 1;
+      if (tmp > 0 && wlen + tmp < destlen)
+      {
+        memcpy (wptr, src, tmp);
+        wptr += tmp;
+        src += tmp;
+        wlen += tmp;
+        col += w;
+      }
+      else
+      {
+	src += destlen - wlen;
+	wlen = destlen;
+      }
+    }
+  }
+  *wptr = 0;
+
+#if 0
+  if (flags & M_FORMAT_MAKEPRINT)
+  {
+    /* Make sure that the string is printable by changing all non-printable
+       chars to dots, or spaces for non-printable whitespace */
+    for (cp = dest ; *cp ; cp++)
+      if (!IsPrint (*cp) &&
+	  !((flags & M_FORMAT_TREE) && (*cp <= M_TREE_MAX)))
+	*cp = isspace ((unsigned char) *cp) ? ' ' : '.';
+  }
+#endif
+}
+
+/* This function allows the user to specify a command to read stdout from in
+   place of a normal file.  If the last character in the string is a pipe (|),
+   then we assume it is a command to run instead of a normal file. */
+FILE *mutt_open_read (const char *path, pid_t *thepid)
+{
+  FILE *f;
+  struct stat s;
+
+  int len = mutt_strlen (path);
+
+  if (path[len - 1] == '|')
+  {
+    /* read from a pipe */
+
+    char *s = safe_strdup (path);
+
+    s[len - 1] = 0;
+    mutt_endwin (NULL);
+    *thepid = mutt_create_filter (s, NULL, &f, NULL);
+    FREE (&s);
+  }
+  else
+  {
+    if (stat (path, &s) < 0)
+      return (NULL);
+    if (S_ISDIR (s.st_mode))
+    {
+      errno = EINVAL;
+      return (NULL);
+    }
+    f = fopen (path, "r");
+    *thepid = -1;
+  }
+  return (f);
+}
+
+/* returns 0 if OK to proceed, -1 to abort, 1 to retry */
+int mutt_save_confirm (const char *s, struct stat *st)
+{
+  char tmp[_POSIX_PATH_MAX];
+  int ret = 0;
+  int rc;
+  int magic = 0;
+
+  magic = mx_get_magic (s);
+
+#ifdef USE_POP
+  if (magic == M_POP)
+  {
+    mutt_error _("Can't save message to POP mailbox.");
+    return 1;
+  }
+#endif
+
+  if (magic > 0 && !mx_access (s, W_OK))
+  {
+    if (option (OPTCONFIRMAPPEND))
+    {
+      snprintf (tmp, sizeof (tmp), _("Append messages to %s?"), s);
+      if ((rc = mutt_yesorno (tmp, M_YES)) == M_NO)
+	ret = 1;
+      else if (rc == -1)
+	ret = -1;
+    }
+  }
+
+  if (stat (s, st) != -1)
+  {
+    if (magic == -1)
+    {
+      mutt_error (_("%s is not a mailbox!"), s);
+      return 1;
+    }
+  }
+  else if (magic != M_IMAP)
+  {
+    st->st_mtime = 0;
+    st->st_atime = 0;
+
+    if (errno == ENOENT)
+    {
+      if (option (OPTCONFIRMCREATE))
+      {
+	snprintf (tmp, sizeof (tmp), _("Create %s?"), s);
+	if ((rc = mutt_yesorno (tmp, M_YES)) == M_NO)
+	  ret = 1;
+	else if (rc == -1)
+	  ret = -1;
+      }
+    }
+    else
+    {
+      mutt_perror (s);
+      return 1;
+    }
+  }
+
+  CLEARLINE (LINES-1);
+  return (ret);
+}
+
+void state_prefix_putc (char c, STATE *s)
+{
+  if (s->flags & M_PENDINGPREFIX)
+  {
+    state_reset_prefix (s);
+    if (s->prefix)
+      state_puts (s->prefix, s);
+  }
+
+  state_putc (c, s);
+
+  if (c == '\n')
+    state_set_prefix (s);
+}
+
+int state_printf (STATE *s, const char *fmt, ...)
+{
+  int rv;
+  va_list ap;
+
+  va_start (ap, fmt);
+  rv = vfprintf (s->fpout, fmt, ap);
+  va_end (ap);
+  
+  return rv;
+}
+
+void state_mark_attach (STATE *s)
+{
+  if ((s->flags & M_DISPLAY) && !mutt_strcmp (Pager, "builtin"))
+    state_puts (AttachmentMarker, s);
+}
+
+void state_attach_puts (const char *t, STATE *s)
+{
+  if (*t != '\n') state_mark_attach (s);
+  while (*t)
+  {
+    state_putc (*t, s);
+    if (*t++ == '\n' && *t)
+      if (*t != '\n') state_mark_attach (s);
+  }
+}
+
+int state_putwc (wchar_t wc, STATE *s)
+{
+  char mb[MB_LEN_MAX] = "";
+  int rc;
+
+  if ((rc = wcrtomb (mb, wc, NULL)) < 0)
+    return rc;
+  if (fputs (mb, s->fpout) == EOF)
+    return -1;
+  return 0;
+}
+
+int state_putws (const wchar_t *ws, STATE *s)
+{
+  const wchar_t *p = ws;
+
+  while (p && *p != L'\0')
+  {
+    if (state_putwc (*p, s) < 0)
+      return -1;
+    p++;
+  }
+  return 0;
+}
+
+void mutt_display_sanitize (char *s)
+{
+  for (; *s; s++)
+  {
+    if (!IsPrint (*s))
+      *s = '?';
+  }
+}
+      
+void mutt_sleep (short s)
+{
+  if (SleepTime > s)
+    sleep (SleepTime);
+  else if (s)
+    sleep (s);
+}
+
+/*
+ * Creates and initializes a BUFFER*. If passed an existing BUFFER*,
+ * just initializes. Frees anything already in the buffer.
+ *
+ * Disregards the 'destroy' flag, which seems reserved for caller.
+ * This is bad, but there's no apparent protocol for it.
+ */
+BUFFER * mutt_buffer_init(BUFFER *b)
+{
+  if (!b)
+  {
+    b = safe_malloc(sizeof(BUFFER));
+    if (!b)
+      return NULL;
+  }
+  else
+  {
+    FREE(&b->data);
+  }
+  memset(b, 0, sizeof(BUFFER));
+  return b;
+}
+
+/*
+ * Creates and initializes a BUFFER*. If passed an existing BUFFER*,
+ * just initializes. Frees anything already in the buffer. Copies in
+ * the seed string.
+ *
+ * Disregards the 'destroy' flag, which seems reserved for caller.
+ * This is bad, but there's no apparent protocol for it.
+ */
+BUFFER * mutt_buffer_from(BUFFER *b, char *seed)
+{
+  if (!seed)
+    return NULL;
+
+  b = mutt_buffer_init(b);
+  b->data = safe_strdup (seed);
+  b->dsize = mutt_strlen (seed);
+  b->dptr = (char *) b->data + b->dsize;
+  return b;
+}
+
+int mutt_buffer_printf (BUFFER* buf, const char* fmt, ...)
+{
+  va_list ap, ap_retry;
+  int len, blen, doff;
+  
+  va_start (ap, fmt);
+  va_copy (ap_retry, ap);
+
+  if (!buf->dptr)
+    buf->dptr = buf->data;
+
+  doff = buf->dptr - buf->data;
+  blen = buf->dsize - doff;
+  /* solaris 9 vsnprintf barfs when blen is 0 */
+  if (!blen)
+  {
+    blen = 128;
+    buf->dsize += blen;
+    safe_realloc (&buf->data, buf->dsize);
+    buf->dptr = buf->data + doff;
+  }
+  if ((len = vsnprintf (buf->dptr, blen, fmt, ap)) >= blen)
+  {
+    blen = ++len - blen;
+    if (blen < 128)
+      blen = 128;
+    buf->dsize += blen;
+    safe_realloc (&buf->data, buf->dsize);
+    buf->dptr = buf->data + doff;
+    len = vsnprintf (buf->dptr, len, fmt, ap_retry);
+  }
+  if (len > 0)
+    buf->dptr += len;
+
+  va_end (ap);
+  va_end (ap_retry);
+
+  return len;
+}
+
+void mutt_buffer_addstr (BUFFER* buf, const char* s)
+{
+  mutt_buffer_add (buf, s, mutt_strlen (s));
+}
+
+void mutt_buffer_addch (BUFFER* buf, char c)
+{
+  mutt_buffer_add (buf, &c, 1);
+}
+
+void mutt_buffer_free (BUFFER **p)
+{
+  if (!p || !*p) 
+    return;
+
+   FREE(&(*p)->data);
+   /* dptr is just an offset to data and shouldn't be freed */
+   FREE(p);		/* __FREE_CHECKED__ */
+}
+
+/* dynamically grows a BUFFER to accomodate s, in increments of 128 bytes.
+ * Always one byte bigger than necessary for the null terminator, and
+ * the buffer is always null-terminated */
+void mutt_buffer_add (BUFFER* buf, const char* s, size_t len)
+{
+  size_t offset;
+
+  if (buf->dptr + len + 1 > buf->data + buf->dsize)
+  {
+    offset = buf->dptr - buf->data;
+    buf->dsize += len < 128 ? 128 : len + 1;
+    /* suppress compiler aliasing warning */
+    safe_realloc ((void**) (void*) &buf->data, buf->dsize);
+    buf->dptr = buf->data + offset;
+  }
+  memcpy (buf->dptr, s, len);
+  buf->dptr += len;
+  *(buf->dptr) = '\0';
+}
+
+/* Decrease a file's modification time by 1 second */
+
+time_t mutt_decrease_mtime (const char *f, struct stat *st)
+{
+  struct utimbuf utim;
+  struct stat _st;
+  time_t mtime;
+  
+  if (!st)
+  {
+    if (stat (f, &_st) == -1)
+      return -1;
+    st = &_st;
+  }
+
+  if ((mtime = st->st_mtime) == time (NULL))
+  {
+    mtime -= 1;
+    utim.actime = mtime;
+    utim.modtime = mtime;
+    utime (f, &utim);
+  }
+  
+  return mtime;
+}
+
+/* sets mtime of 'to' to mtime of 'from' */
+void mutt_set_mtime (const char* from, const char* to)
+{
+  struct utimbuf utim;
+  struct stat st;
+
+  if (stat (from, &st) != -1)
+  {
+    utim.actime = st.st_mtime;
+    utim.modtime = st.st_mtime;
+    utime (to, &utim);
+  }
+}
+
+const char *mutt_make_version (void)
+{
+  static char vstring[STRING];
+  snprintf (vstring, sizeof (vstring), "Mutt %s (%s)",
+	    MUTT_VERSION, ReleaseDate);
+  return vstring;
+}
+
+REGEXP *mutt_compile_regexp (const char *s, int flags)
+{
+  REGEXP *pp = safe_calloc (sizeof (REGEXP), 1);
+  pp->pattern = safe_strdup (s);
+  pp->rx = safe_calloc (sizeof (regex_t), 1);
+  if (REGCOMP (pp->rx, NONULL(s), flags) != 0)
+    mutt_free_regexp (&pp);
+
+  return pp;
+}
+
+void mutt_free_regexp (REGEXP **pp)
+{
+  FREE (&(*pp)->pattern);
+  regfree ((*pp)->rx);
+  FREE (&(*pp)->rx);
+  FREE (pp);		/* __FREE_CHECKED__ */
+}
+
+void mutt_free_rx_list (RX_LIST **list)
+{
+  RX_LIST *p;
+  
+  if (!list) return;
+  while (*list)
+  {
+    p = *list;
+    *list = (*list)->next;
+    mutt_free_regexp (&p->rx);
+    FREE (&p);
+  }
+}
+
+void mutt_free_spam_list (SPAM_LIST **list)
+{
+  SPAM_LIST *p;
+  
+  if (!list) return;
+  while (*list)
+  {
+    p = *list;
+    *list = (*list)->next;
+    mutt_free_regexp (&p->rx);
+    FREE (&p->template);
+    FREE (&p);
+  }
+}
+
+int mutt_match_rx_list (const char *s, RX_LIST *l)
+{
+  if (!s)  return 0;
+  
+  for (; l; l = l->next)
+  {
+    if (regexec (l->rx->rx, s, (size_t) 0, (regmatch_t *) 0, (int) 0) == 0)
+    {
+      dprint (5, (debugfile, "mutt_match_rx_list: %s matches %s\n", s, l->rx->pattern));
+      return 1;
+    }
+  }
+
+  return 0;
+}
+
+/* Match a string against the patterns defined by the 'spam' command and output
+ * the expanded format into `text` when there is a match.  If textsize<=0, the
+ * match is performed but the format is not expanded and no assumptions are made
+ * about the value of `text` so it may be NULL.
+ *
+ * Returns 1 if the argument `s` matches a pattern in the spam list, otherwise
+ * 0. */
+int mutt_match_spam_list (const char *s, SPAM_LIST *l, char *text, int textsize)
+{
+  static regmatch_t *pmatch = NULL;
+  static int nmatch = 0;
+  int tlen = 0;
+  char *p;
+
+  if (!s) return 0;
+
+  for (; l; l = l->next)
+  {
+    /* If this pattern needs more matches, expand pmatch. */
+    if (l->nmatch > nmatch)
+    {
+      safe_realloc (&pmatch, l->nmatch * sizeof(regmatch_t));
+      nmatch = l->nmatch;
+    }
+
+    /* Does this pattern match? */
+    if (regexec (l->rx->rx, s, (size_t) l->nmatch, (regmatch_t *) pmatch, (int) 0) == 0)
+    {
+      dprint (5, (debugfile, "mutt_match_spam_list: %s matches %s\n", s, l->rx->pattern));
+      dprint (5, (debugfile, "mutt_match_spam_list: %d subs\n", (int)l->rx->rx->re_nsub));
+
+      /* Copy template into text, with substitutions. */
+      for (p = l->template; *p && tlen < textsize - 1;)
+      {
+	/* backreference to pattern match substring, eg. %1, %2, etc) */
+	if (*p == '%')
+	{
+	  char *e; /* used as pointer to end of integer backreference in strtol() call */
+	  int n;
+
+	  ++p; /* skip over % char */
+	  n = strtol(p, &e, 10);
+	  /* Ensure that the integer conversion succeeded (e!=p) and bounds check.  The upper bound check
+	   * should not strictly be necessary since add_to_spam_list() finds the largest value, and
+	   * the static array above is always large enough based on that value. */
+	  if (e != p && n >= 0 && n <= l->nmatch && pmatch[n].rm_so != -1) {
+	    /* copy as much of the substring match as will fit in the output buffer, saving space for
+	     * the terminating nul char */
+	    int idx;
+	    for (idx = pmatch[n].rm_so; (idx < pmatch[n].rm_eo) && (tlen < textsize - 1); ++idx)
+	      text[tlen++] = s[idx];
+	  }
+	  p = e; /* skip over the parsed integer */
+	}
+	else
+	{
+	  text[tlen++] = *p++;
+	}
+      }
+      /* tlen should always be less than textsize except when textsize<=0
+       * because the bounds checks in the above code leave room for the
+       * terminal nul char.   This should avoid returning an unterminated
+       * string to the caller.  When textsize<=0 we make no assumption about
+       * the validity of the text pointer. */
+      if (tlen < textsize) {
+	text[tlen] = '\0';
+	dprint (5, (debugfile, "mutt_match_spam_list: \"%s\"\n", text));
+      }
+      return 1;
+    }
+  }
+
+  return 0;
+}
+
+void mutt_encode_path (char *dest, size_t dlen, const char *src)
+{
+  char *p = safe_strdup (src);
+  int rc = mutt_convert_string (&p, Charset, "utf-8", 0);
+  strfcpy (dest, rc == 0 ? p : src, dlen);
+  FREE (&p);
+}
diff -udprP mutt-1.5.21/mx.c mutt-nntp-sidebar/mx.c
--- mutt-1.5.21/mx.c	2011-06-03 07:06:32.529621818 -0700
+++ mutt-nntp-sidebar/mx.c	2011-06-03 07:05:58.939622665 -0700
@@ -343,6 +343,22 @@ int mx_is_pop (const char *p)
 }
 #endif
 
+#ifdef USE_NNTP
+int mx_is_nntp (const char *p)
+{
+  url_scheme_t scheme;
+
+  if (!p)
+    return 0;
+
+  scheme = url_check_scheme (p);
+  if (scheme == U_NNTP || scheme == U_NNTPS)
+    return 1;
+
+  return 0;
+}
+#endif
+
 int mx_get_magic (const char *path)
 {
   struct stat st;
@@ -360,6 +376,11 @@ int mx_get_magic (const char *path)
     return M_POP;
 #endif /* USE_POP */
 
+#ifdef USE_NNTP
+  if (mx_is_nntp (path))
+    return M_NNTP;
+#endif /* USE_NNTP */
+
   if (stat (path, &st) == -1)
   {
     dprint (1, (debugfile, "mx_get_magic(): unable to stat %s: %s (errno %d).\n",
@@ -671,6 +692,12 @@ CONTEXT *mx_open_mailbox (const char *pa
       break;
 #endif /* USE_POP */
 
+#ifdef USE_NNTP
+    case M_NNTP:
+      rc = nntp_open_mailbox (ctx);
+      break;
+#endif /* USE_NNTP */
+
     default:
       rc = -1;
       break;
@@ -779,6 +806,12 @@ static int sync_mailbox (CONTEXT *ctx, i
       rc = pop_sync_mailbox (ctx, index_hint);
       break;
 #endif /* USE_POP */
+
+#ifdef USE_NNTP
+    case M_NNTP:
+      rc = nntp_sync_mailbox (ctx);
+      break;
+#endif /* USE_NNTP */
   }
 
 #if 0
@@ -805,6 +838,16 @@ int mx_close_mailbox (CONTEXT *ctx, int
 
   ctx->closing = 1;
 
+#ifdef USE_NNTP
+  if (ctx->magic == M_NNTP)
+  {
+    int ret;
+
+    ret = nntp_close_mailbox (ctx);
+    mx_fastclose_mailbox (ctx);
+    return ret;
+  }
+#endif
   if (ctx->readonly || ctx->dontwrite)
   {
     /* mailbox is readonly or we don't want to write */
@@ -1356,6 +1399,11 @@ int mx_check_mailbox (CONTEXT *ctx, int
       case M_POP:
 	return (pop_check_mailbox (ctx, index_hint));
 #endif /* USE_POP */
+
+#ifdef USE_NNTP
+      case M_NNTP:
+	return (nntp_check_mailbox (ctx));
+#endif /* USE_NNTP */
     }
   }
 
@@ -1416,6 +1464,15 @@ MESSAGE *mx_open_message (CONTEXT *ctx,
     }
 #endif /* USE_POP */
 
+#ifdef USE_NNTP
+    case M_NNTP:
+    {
+      if (nntp_fetch_message (msg, ctx, msgno) != 0)
+	FREE (&msg);
+      break;
+    }
+#endif /* USE_NNTP */
+
     default:
       dprint (1, (debugfile, "mx_open_message(): function not implemented for mailbox type %d.\n", ctx->magic));
       FREE (&msg);
@@ -1491,6 +1548,9 @@ int mx_close_message (MESSAGE **msg)
   int r = 0;
 
   if ((*msg)->magic == M_MH || (*msg)->magic == M_MAILDIR
+#ifdef USE_NNTP
+      || (*msg)->magic == M_NNTP
+#endif
       || (*msg)->magic == M_IMAP || (*msg)->magic == M_POP)
   {
     r = safe_fclose (&(*msg)->fp);
diff -udprP mutt-1.5.21/mx.c.orig mutt-nntp-sidebar/mx.c.orig
--- mutt-1.5.21/mx.c.orig	1969-12-31 17:00:00.000000000 -0700
+++ mutt-nntp-sidebar/mx.c.orig	2011-06-03 07:05:58.909622665 -0700
@@ -0,0 +1,1635 @@
+/*
+ * Copyright (C) 1996-2002 Michael R. Elkins <me@mutt.org>
+ * Copyright (C) 1999-2003 Thomas Roessler <roessler@does-not-exist.org>
+ * 
+ *     This program is free software; you can redistribute it and/or modify
+ *     it under the terms of the GNU General Public License as published by
+ *     the Free Software Foundation; either version 2 of the License, or
+ *     (at your option) any later version.
+ * 
+ *     This program is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ * 
+ *     You should have received a copy of the GNU General Public License
+ *     along with this program; if not, write to the Free Software
+ *     Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */ 
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include "mutt.h"
+#include "mx.h"
+#include "rfc2047.h"
+#include "sort.h"
+#include "mailbox.h"
+#include "copy.h"
+#include "keymap.h"
+#include "url.h"
+
+#ifdef USE_IMAP
+#include "imap.h"
+#endif
+
+#ifdef USE_POP
+#include "pop.h"
+#endif
+
+#include "buffy.h"
+
+#ifdef USE_DOTLOCK
+#include "dotlock.h"
+#endif
+
+#include "mutt_crypt.h"
+
+#include <dirent.h>
+#include <fcntl.h>
+#include <sys/file.h>
+#include <sys/stat.h>
+#include <errno.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <string.h>
+#include <ctype.h>
+#include <utime.h>
+
+
+#define mutt_is_spool(s)  (mutt_strcmp (Spoolfile, s) == 0)
+
+#ifdef USE_DOTLOCK
+/* parameters: 
+ * path - file to lock
+ * retry - should retry if unable to lock?
+ */
+
+#ifdef DL_STANDALONE
+
+static int invoke_dotlock (const char *path, int dummy, int flags, int retry)
+{
+  char cmd[LONG_STRING + _POSIX_PATH_MAX];
+  char f[SHORT_STRING + _POSIX_PATH_MAX];
+  char r[SHORT_STRING];
+  
+  if (flags & DL_FL_RETRY)
+    snprintf (r, sizeof (r), "-r %d ", retry ? MAXLOCKATTEMPT : 0);
+  
+  mutt_quote_filename (f, sizeof (f), path);
+  
+  snprintf (cmd, sizeof (cmd),
+	    "%s %s%s%s%s%s%s%s",
+	    NONULL (MuttDotlock),
+	    flags & DL_FL_TRY ? "-t " : "",
+	    flags & DL_FL_UNLOCK ? "-u " : "",
+	    flags & DL_FL_USEPRIV ? "-p " : "",
+	    flags & DL_FL_FORCE ? "-f " : "",
+	    flags & DL_FL_UNLINK ? "-d " : "",
+	    flags & DL_FL_RETRY ? r : "",
+	    f);
+  
+  return mutt_system (cmd);
+}
+
+#else 
+
+#define invoke_dotlock dotlock_invoke
+
+#endif
+
+static int dotlock_file (const char *path, int fd, int retry)
+{
+  int r;
+  int flags = DL_FL_USEPRIV | DL_FL_RETRY;
+
+  if (retry) retry = 1;
+
+retry_lock:
+  if ((r = invoke_dotlock(path, fd, flags, retry)) == DL_EX_EXIST)
+  {
+    if (!option (OPTNOCURSES))
+    {
+      char msg[LONG_STRING];
+      
+      snprintf(msg, sizeof(msg), _("Lock count exceeded, remove lock for %s?"),
+	       path);
+      if(retry && mutt_yesorno(msg, M_YES) == M_YES)
+      {
+	flags |= DL_FL_FORCE;
+	retry--;
+	mutt_clear_error ();
+	goto retry_lock;
+      }
+    } 
+    else
+    {
+      mutt_error ( _("Can't dotlock %s.\n"), path);
+    }
+  }
+  return (r == DL_EX_OK ? 0 : -1);
+}
+
+static int undotlock_file (const char *path, int fd)
+{
+  return (invoke_dotlock(path, fd, DL_FL_USEPRIV | DL_FL_UNLOCK, 0) == DL_EX_OK ? 
+	  0 : -1);
+}
+
+#endif /* USE_DOTLOCK */
+
+/* Args:
+ *	excl		if excl != 0, request an exclusive lock
+ *	dot		if dot != 0, try to dotlock the file
+ *	timeout 	should retry locking?
+ */
+int mx_lock_file (const char *path, int fd, int excl, int dot, int timeout)
+{
+#if defined (USE_FCNTL) || defined (USE_FLOCK)
+  int count;
+  int attempt;
+  struct stat sb = { 0 }, prev_sb = { 0 }; /* silence gcc warnings */
+#endif
+  int r = 0;
+
+#ifdef USE_FCNTL
+  struct flock lck;
+  
+  memset (&lck, 0, sizeof (struct flock));
+  lck.l_type = excl ? F_WRLCK : F_RDLCK;
+  lck.l_whence = SEEK_SET;
+
+  count = 0;
+  attempt = 0;
+  while (fcntl (fd, F_SETLK, &lck) == -1)
+  {
+    dprint(1,(debugfile, "mx_lock_file(): fcntl errno %d.\n", errno));
+    if (errno != EAGAIN && errno != EACCES)
+    {
+      mutt_perror ("fcntl");
+      return -1;
+    }
+
+    if (fstat (fd, &sb) != 0)
+      sb.st_size = 0;
+    
+    if (count == 0)
+      prev_sb = sb;
+
+    /* only unlock file if it is unchanged */
+    if (prev_sb.st_size == sb.st_size && ++count >= (timeout?MAXLOCKATTEMPT:0))
+    {
+      if (timeout)
+	mutt_error _("Timeout exceeded while attempting fcntl lock!");
+      return -1;
+    }
+
+    prev_sb = sb;
+
+    mutt_message (_("Waiting for fcntl lock... %d"), ++attempt);
+    sleep (1);
+  }
+#endif /* USE_FCNTL */
+
+#ifdef USE_FLOCK
+  count = 0;
+  attempt = 0;
+  while (flock (fd, (excl ? LOCK_EX : LOCK_SH) | LOCK_NB) == -1)
+  {
+    if (errno != EWOULDBLOCK)
+    {
+      mutt_perror ("flock");
+      r = -1;
+      break;
+    }
+
+    if (fstat(fd, &sb) != 0)
+      sb.st_size = 0;
+    
+    if (count == 0)
+      prev_sb = sb;
+
+    /* only unlock file if it is unchanged */
+    if (prev_sb.st_size == sb.st_size && ++count >= (timeout?MAXLOCKATTEMPT:0))
+    {
+      if (timeout)
+	mutt_error _("Timeout exceeded while attempting flock lock!");
+      r = -1;
+      break;
+    }
+
+    prev_sb = sb;
+
+    mutt_message (_("Waiting for flock attempt... %d"), ++attempt);
+    sleep (1);
+  }
+#endif /* USE_FLOCK */
+
+#ifdef USE_DOTLOCK
+  if (r == 0 && dot)
+    r = dotlock_file (path, fd, timeout);
+#endif /* USE_DOTLOCK */
+
+  if (r != 0)
+  {
+    /* release any other locks obtained in this routine */
+
+#ifdef USE_FCNTL
+    lck.l_type = F_UNLCK;
+    fcntl (fd, F_SETLK, &lck);
+#endif /* USE_FCNTL */
+
+#ifdef USE_FLOCK
+    flock (fd, LOCK_UN);
+#endif /* USE_FLOCK */
+  }
+
+  return r;
+}
+
+int mx_unlock_file (const char *path, int fd, int dot)
+{
+#ifdef USE_FCNTL
+  struct flock unlockit = { F_UNLCK, 0, 0, 0, 0 };
+
+  memset (&unlockit, 0, sizeof (struct flock));
+  unlockit.l_type = F_UNLCK;
+  unlockit.l_whence = SEEK_SET;
+  fcntl (fd, F_SETLK, &unlockit);
+#endif
+
+#ifdef USE_FLOCK
+  flock (fd, LOCK_UN);
+#endif
+
+#ifdef USE_DOTLOCK
+  if (dot)
+    undotlock_file (path, fd);
+#endif
+  
+  return 0;
+}
+
+static void mx_unlink_empty (const char *path)
+{
+  int fd;
+#ifndef USE_DOTLOCK
+  struct stat sb;
+#endif
+
+  if ((fd = open (path, O_RDWR)) == -1)
+    return;
+
+  if (mx_lock_file (path, fd, 1, 0, 1) == -1)
+  {
+    close (fd);
+    return;
+  }
+
+#ifdef USE_DOTLOCK
+  invoke_dotlock (path, fd, DL_FL_UNLINK, 1);
+#else
+  if (fstat (fd, &sb) == 0 && sb.st_size == 0)
+    unlink (path);
+#endif
+
+  mx_unlock_file (path, fd, 0);
+  close (fd);
+}
+
+/* try to figure out what type of mailbox ``path'' is
+ *
+ * return values:
+ *	M_*	mailbox type
+ *	0	not a mailbox
+ *	-1	error
+ */
+
+#ifdef USE_IMAP
+
+int mx_is_imap(const char *p)
+{
+  url_scheme_t scheme;
+
+  if (!p)
+    return 0;
+
+  if (*p == '{')
+    return 1;
+
+  scheme = url_check_scheme (p);
+  if (scheme == U_IMAP || scheme == U_IMAPS)
+    return 1;
+
+  return 0;
+}
+
+#endif
+
+#ifdef USE_POP
+int mx_is_pop (const char *p)
+{
+  url_scheme_t scheme;
+
+  if (!p)
+    return 0;
+
+  scheme = url_check_scheme (p);
+  if (scheme == U_POP || scheme == U_POPS)
+    return 1;
+
+  return 0;
+}
+#endif
+
+int mx_get_magic (const char *path)
+{
+  struct stat st;
+  int magic = 0;
+  char tmp[_POSIX_PATH_MAX];
+  FILE *f;
+
+#ifdef USE_IMAP
+  if(mx_is_imap(path))
+    return M_IMAP;
+#endif /* USE_IMAP */
+
+#ifdef USE_POP
+  if (mx_is_pop (path))
+    return M_POP;
+#endif /* USE_POP */
+
+  if (stat (path, &st) == -1)
+  {
+    dprint (1, (debugfile, "mx_get_magic(): unable to stat %s: %s (errno %d).\n",
+		path, strerror (errno), errno));
+    return (-1);
+  }
+
+  if (S_ISDIR (st.st_mode))
+  {
+    /* check for maildir-style mailbox */
+    if (mx_is_maildir (path))
+      return M_MAILDIR;
+
+    /* check for mh-style mailbox */
+    if (mx_is_mh (path))
+      return M_MH;
+  }
+  else if (st.st_size == 0)
+  {
+    /* hard to tell what zero-length files are, so assume the default magic */
+    if (DefaultMagic == M_MBOX || DefaultMagic == M_MMDF)
+      return (DefaultMagic);
+    else
+      return (M_MBOX);
+  }
+  else if ((f = fopen (path, "r")) != NULL)
+  {
+    struct utimbuf times;
+
+    fgets (tmp, sizeof (tmp), f);
+    if (mutt_strncmp ("From ", tmp, 5) == 0)
+      magic = M_MBOX;
+    else if (mutt_strcmp (MMDF_SEP, tmp) == 0)
+      magic = M_MMDF;
+    safe_fclose (&f);
+
+    if (!option(OPTCHECKMBOXSIZE))
+    {
+      /* need to restore the times here, the file was not really accessed,
+       * only the type was accessed.  This is important, because detection
+       * of "new mail" depends on those times set correctly.
+       */
+      times.actime = st.st_atime;
+      times.modtime = st.st_mtime;
+      utime (path, &times);
+    }
+  }
+  else
+  {
+    dprint (1, (debugfile, "mx_get_magic(): unable to open file %s for reading.\n",
+		path));
+    return (-1);
+  }
+
+  return (magic);
+}
+
+/*
+ * set DefaultMagic to the given value
+ */
+int mx_set_magic (const char *s)
+{
+  if (ascii_strcasecmp (s, "mbox") == 0)
+    DefaultMagic = M_MBOX;
+  else if (ascii_strcasecmp (s, "mmdf") == 0)
+    DefaultMagic = M_MMDF;
+  else if (ascii_strcasecmp (s, "mh") == 0)
+    DefaultMagic = M_MH;
+  else if (ascii_strcasecmp (s, "maildir") == 0)
+    DefaultMagic = M_MAILDIR;
+  else
+    return (-1);
+
+  return 0;
+}
+
+/* mx_access: Wrapper for access, checks permissions on a given mailbox.
+ *   We may be interested in using ACL-style flags at some point, currently
+ *   we use the normal access() flags. */
+int mx_access (const char* path, int flags)
+{
+#ifdef USE_IMAP
+  if (mx_is_imap (path))
+    return imap_access (path, flags);
+#endif
+
+  return access (path, flags);
+}
+
+static int mx_open_mailbox_append (CONTEXT *ctx, int flags)
+{
+  struct stat sb;
+
+  ctx->append = 1;
+
+#ifdef USE_IMAP
+  
+  if(mx_is_imap(ctx->path))  
+    return imap_open_mailbox_append (ctx);
+
+#endif
+  
+  if(stat(ctx->path, &sb) == 0)
+  {
+    ctx->magic = mx_get_magic (ctx->path);
+    
+    switch (ctx->magic)
+    {
+      case 0:
+	mutt_error (_("%s is not a mailbox."), ctx->path);
+	/* fall through */
+      case -1:
+	return (-1);
+    }
+  }
+  else if (errno == ENOENT)
+  {
+    ctx->magic = DefaultMagic;
+
+    if (ctx->magic == M_MH || ctx->magic == M_MAILDIR)
+    {
+      char tmp[_POSIX_PATH_MAX];
+
+      if (mkdir (ctx->path, S_IRWXU))
+      {
+	mutt_perror (ctx->path);
+	return (-1);
+      }
+
+      if (ctx->magic == M_MAILDIR)
+      {
+	snprintf (tmp, sizeof (tmp), "%s/cur", ctx->path);
+	if (mkdir (tmp, S_IRWXU))
+	{
+	  mutt_perror (tmp);
+	  rmdir (ctx->path);
+	  return (-1);
+	}
+
+	snprintf (tmp, sizeof (tmp), "%s/new", ctx->path);
+	if (mkdir (tmp, S_IRWXU))
+	{
+	  mutt_perror (tmp);
+	  snprintf (tmp, sizeof (tmp), "%s/cur", ctx->path);
+	  rmdir (tmp);
+	  rmdir (ctx->path);
+	  return (-1);
+	}
+	snprintf (tmp, sizeof (tmp), "%s/tmp", ctx->path);
+	if (mkdir (tmp, S_IRWXU))
+	{
+	  mutt_perror (tmp);
+	  snprintf (tmp, sizeof (tmp), "%s/cur", ctx->path);
+	  rmdir (tmp);
+	  snprintf (tmp, sizeof (tmp), "%s/new", ctx->path);
+	  rmdir (tmp);
+	  rmdir (ctx->path);
+	  return (-1);
+	}
+      }
+      else
+      {
+	int i;
+
+	snprintf (tmp, sizeof (tmp), "%s/.mh_sequences", ctx->path);
+	if ((i = creat (tmp, S_IRWXU)) == -1)
+	{
+	  mutt_perror (tmp);
+	  rmdir (ctx->path);
+	  return (-1);
+	}
+	close (i);
+      }
+    }
+  }
+  else
+  {
+    mutt_perror (ctx->path);
+    return (-1);
+  }
+
+  switch (ctx->magic)
+  {
+    case M_MBOX:
+    case M_MMDF:
+    if ((ctx->fp = safe_fopen (ctx->path, flags & M_NEWFOLDER ? "w" : "a")) == NULL ||
+	  mbox_lock_mailbox (ctx, 1, 1) != 0)
+      {
+	if (!ctx->fp)
+	  mutt_perror (ctx->path);
+	else
+	{
+	  mutt_error (_("Couldn't lock %s\n"), ctx->path);
+	  safe_fclose (&ctx->fp);
+	}
+	return (-1);
+      }
+      fseek (ctx->fp, 0, 2);
+      break;
+
+    case M_MH:
+    case M_MAILDIR:
+      /* nothing to do */
+      break;
+
+    default:
+      return (-1);
+  }
+
+  return 0;
+}
+
+/*
+ * open a mailbox and parse it
+ *
+ * Args:
+ *	flags	M_NOSORT	do not sort mailbox
+ *		M_APPEND	open mailbox for appending
+ *		M_READONLY	open mailbox in read-only mode
+ *		M_QUIET		only print error messages
+ *		M_PEEK		revert atime where applicable
+ *	ctx	if non-null, context struct to use
+ */
+CONTEXT *mx_open_mailbox (const char *path, int flags, CONTEXT *pctx)
+{
+  CONTEXT *ctx = pctx;
+  int rc;
+
+  if (!ctx)
+    ctx = safe_malloc (sizeof (CONTEXT));
+  memset (ctx, 0, sizeof (CONTEXT));
+  ctx->path = safe_strdup (path);
+
+  ctx->msgnotreadyet = -1;
+  ctx->collapsed = 0;
+
+  for (rc=0; rc < RIGHTSMAX; rc++)
+    mutt_bit_set(ctx->rights,rc);
+
+  if (flags & M_QUIET)
+    ctx->quiet = 1;
+  if (flags & M_READONLY)
+    ctx->readonly = 1;
+  if (flags & M_PEEK)
+    ctx->peekonly = 1;
+
+  if (flags & (M_APPEND|M_NEWFOLDER))
+  {
+    if (mx_open_mailbox_append (ctx, flags) != 0)
+    {
+      mx_fastclose_mailbox (ctx);
+      if (!pctx)
+	FREE (&ctx);
+      return NULL;
+    }
+    return ctx;
+  }
+
+  ctx->magic = mx_get_magic (path);
+  
+  if(ctx->magic == 0)
+    mutt_error (_("%s is not a mailbox."), path);
+
+  if(ctx->magic == -1)
+    mutt_perror(path);
+  
+  if(ctx->magic <= 0)
+  {
+    mx_fastclose_mailbox (ctx);
+    if (!pctx)
+      FREE (&ctx);
+    return (NULL);
+  }
+  
+  /* if the user has a `push' command in their .muttrc, or in a folder-hook,
+   * it will cause the progress messages not to be displayed because
+   * mutt_refresh() will think we are in the middle of a macro.  so set a
+   * flag to indicate that we should really refresh the screen.
+   */
+  set_option (OPTFORCEREFRESH);
+
+  if (!ctx->quiet)
+    mutt_message (_("Reading %s..."), ctx->path);
+
+  switch (ctx->magic)
+  {
+    case M_MH:
+      rc = mh_read_dir (ctx, NULL);
+      break;
+
+    case M_MAILDIR:
+      rc = maildir_read_dir (ctx);
+      break;
+
+    case M_MMDF:
+    case M_MBOX:
+      rc = mbox_open_mailbox (ctx);
+      break;
+
+#ifdef USE_IMAP
+    case M_IMAP:
+      rc = imap_open_mailbox (ctx);
+      break;
+#endif /* USE_IMAP */
+
+#ifdef USE_POP
+    case M_POP:
+      rc = pop_open_mailbox (ctx);
+      break;
+#endif /* USE_POP */
+
+    default:
+      rc = -1;
+      break;
+  }
+
+  if (rc == 0)
+  {
+    if ((flags & M_NOSORT) == 0)
+    {
+      /* avoid unnecessary work since the mailbox is completely unthreaded
+	 to begin with */
+      unset_option (OPTSORTSUBTHREADS);
+      unset_option (OPTNEEDRESCORE);
+      mutt_sort_headers (ctx, 1);
+    }
+    if (!ctx->quiet)
+      mutt_clear_error ();
+  }
+  else
+  {
+    mx_fastclose_mailbox (ctx);
+    if (!pctx)
+      FREE (&ctx);
+  }
+
+  unset_option (OPTFORCEREFRESH);
+  return (ctx);
+}
+
+/* free up memory associated with the mailbox context */
+void mx_fastclose_mailbox (CONTEXT *ctx)
+{
+  int i;
+#ifndef BUFFY_SIZE
+  struct utimbuf ut;
+#endif
+
+  if(!ctx) 
+    return;
+#ifndef BUFFY_SIZE
+  /* fix up the times so buffy won't get confused */
+  if (ctx->peekonly && ctx->path && ctx->mtime > ctx->atime)
+  {
+    ut.actime = ctx->atime;
+    ut.modtime = ctx->mtime;
+    utime (ctx->path, &ut); 
+  }
+#endif
+
+  /* never announce that a mailbox we've just left has new mail. #3290
+   * XXX: really belongs in mx_close_mailbox, but this is a nice hook point */
+  mutt_buffy_setnotified(ctx->path);
+
+  if (ctx->mx_close)
+    ctx->mx_close (ctx);
+
+  if (ctx->subj_hash)
+    hash_destroy (&ctx->subj_hash, NULL);
+  if (ctx->id_hash)
+    hash_destroy (&ctx->id_hash, NULL);
+  mutt_clear_threads (ctx);
+  for (i = 0; i < ctx->msgcount; i++)
+    mutt_free_header (&ctx->hdrs[i]);
+  FREE (&ctx->hdrs);
+  FREE (&ctx->v2r);
+  FREE (&ctx->path);
+  FREE (&ctx->pattern);
+  if (ctx->limit_pattern) 
+    mutt_pattern_free (&ctx->limit_pattern);
+  safe_fclose (&ctx->fp);
+  memset (ctx, 0, sizeof (CONTEXT));
+}
+
+/* save changes to disk */
+static int sync_mailbox (CONTEXT *ctx, int *index_hint)
+{
+  BUFFY *tmp = NULL;
+  int rc = -1;
+
+  if (!ctx->quiet)
+    mutt_message (_("Writing %s..."), ctx->path);
+
+  switch (ctx->magic)
+  {
+    case M_MBOX:
+    case M_MMDF:
+      rc = mbox_sync_mailbox (ctx, index_hint);
+      if (option(OPTCHECKMBOXSIZE))
+	tmp = mutt_find_mailbox (ctx->path);
+      break;
+      
+    case M_MH:
+    case M_MAILDIR:
+      rc = mh_sync_mailbox (ctx, index_hint);
+      break;
+      
+#ifdef USE_IMAP
+    case M_IMAP:
+      /* extra argument means EXPUNGE */
+      rc = imap_sync_mailbox (ctx, 1, index_hint);
+      break;
+#endif /* USE_IMAP */
+
+#ifdef USE_POP
+    case M_POP:
+      rc = pop_sync_mailbox (ctx, index_hint);
+      break;
+#endif /* USE_POP */
+  }
+
+#if 0
+  if (!ctx->quiet && !ctx->shutup && rc == -1)
+    mutt_error ( _("Could not synchronize mailbox %s!"), ctx->path);
+#endif
+  
+  if (tmp && tmp->new == 0)
+    mutt_update_mailbox (tmp);
+  return rc;
+}
+
+/* save changes and close mailbox */
+int mx_close_mailbox (CONTEXT *ctx, int *index_hint)
+{
+  int i, move_messages = 0, purge = 1, read_msgs = 0;
+  int check;
+  int isSpool = 0;
+  CONTEXT f;
+  char mbox[_POSIX_PATH_MAX];
+  char buf[SHORT_STRING];
+
+  if (!ctx) return 0;
+
+  ctx->closing = 1;
+
+  if (ctx->readonly || ctx->dontwrite)
+  {
+    /* mailbox is readonly or we don't want to write */
+    mx_fastclose_mailbox (ctx);
+    return 0;
+  }
+
+  if (ctx->append)
+  {
+    /* mailbox was opened in write-mode */
+    if (ctx->magic == M_MBOX || ctx->magic == M_MMDF)
+      mbox_close_mailbox (ctx);
+    else
+      mx_fastclose_mailbox (ctx);
+    return 0;
+  }
+
+  for (i = 0; i < ctx->msgcount; i++)
+  {
+    if (!ctx->hdrs[i]->deleted && ctx->hdrs[i]->read 
+        && !(ctx->hdrs[i]->flagged && option (OPTKEEPFLAGGED)))
+      read_msgs++;
+  }
+
+  if (read_msgs && quadoption (OPT_MOVE) != M_NO)
+  {
+    char *p;
+
+    if ((p = mutt_find_hook (M_MBOXHOOK, ctx->path)))
+    {
+      isSpool = 1;
+      strfcpy (mbox, p, sizeof (mbox));
+    }
+    else
+    {
+      strfcpy (mbox, NONULL(Inbox), sizeof (mbox));
+      isSpool = mutt_is_spool (ctx->path) && !mutt_is_spool (mbox);
+    }
+
+    if (isSpool && *mbox)
+    {
+      mutt_expand_path (mbox, sizeof (mbox));
+      snprintf (buf, sizeof (buf), _("Move read messages to %s?"), mbox);
+      if ((move_messages = query_quadoption (OPT_MOVE, buf)) == -1)
+      {
+	ctx->closing = 0;
+	return (-1);
+      }
+    }
+  }
+
+  /* 
+   * There is no point in asking whether or not to purge if we are
+   * just marking messages as "trash".
+   */
+  if (ctx->deleted && !(ctx->magic == M_MAILDIR && option (OPTMAILDIRTRASH)))
+  {
+    snprintf (buf, sizeof (buf), ctx->deleted == 1
+	     ? _("Purge %d deleted message?") : _("Purge %d deleted messages?"),
+	      ctx->deleted);
+    if ((purge = query_quadoption (OPT_DELETE, buf)) < 0)
+    {
+      ctx->closing = 0;
+      return (-1);
+    }
+  }
+
+  if (option (OPTMARKOLD))
+  {
+    for (i = 0; i < ctx->msgcount; i++)
+    {
+      if (!ctx->hdrs[i]->deleted && !ctx->hdrs[i]->old && !ctx->hdrs[i]->read)
+	mutt_set_flag (ctx, ctx->hdrs[i], M_OLD, 1);
+    }
+  }
+
+  if (move_messages)
+  {
+    if (!ctx->quiet)
+      mutt_message (_("Moving read messages to %s..."), mbox);
+
+#ifdef USE_IMAP
+    /* try to use server-side copy first */
+    i = 1;
+    
+    if (ctx->magic == M_IMAP && mx_is_imap (mbox))
+    {
+      /* tag messages for moving, and clear old tags, if any */
+      for (i = 0; i < ctx->msgcount; i++)
+	if (ctx->hdrs[i]->read && !ctx->hdrs[i]->deleted
+            && !(ctx->hdrs[i]->flagged && option (OPTKEEPFLAGGED))) 
+	  ctx->hdrs[i]->tagged = 1;
+	else
+	  ctx->hdrs[i]->tagged = 0;
+      
+      i = imap_copy_messages (ctx, NULL, mbox, 1);
+    }
+    
+    if (i == 0) /* success */
+      mutt_clear_error ();
+    else if (i == -1) /* horrible error, bail */
+    {
+      ctx->closing=0;
+      return -1;
+    }
+    else /* use regular append-copy mode */
+#endif
+    {
+      if (mx_open_mailbox (mbox, M_APPEND, &f) == NULL)
+      {
+	ctx->closing = 0;
+	return -1;
+      }
+
+      for (i = 0; i < ctx->msgcount; i++)
+      {
+	if (ctx->hdrs[i]->read && !ctx->hdrs[i]->deleted
+            && !(ctx->hdrs[i]->flagged && option (OPTKEEPFLAGGED)))
+        {
+	  if (mutt_append_message (&f, ctx, ctx->hdrs[i], 0, CH_UPDATE_LEN) == 0)
+	  {
+	    mutt_set_flag (ctx, ctx->hdrs[i], M_DELETE, 1);
+	  }
+	  else
+	  {
+	    mx_close_mailbox (&f, NULL);
+	    ctx->closing = 0;
+	    return -1;
+	  }
+	}
+      }
+    
+      mx_close_mailbox (&f, NULL);
+    }
+    
+  }
+  else if (!ctx->changed && ctx->deleted == 0)
+  {
+    if (!ctx->quiet)
+      mutt_message _("Mailbox is unchanged.");
+    if (ctx->magic == M_MBOX || ctx->magic == M_MMDF)
+      mbox_reset_atime (ctx, NULL);
+    mx_fastclose_mailbox (ctx);
+    return 0;
+  }
+  
+#ifdef USE_IMAP
+  /* allow IMAP to preserve the deleted flag across sessions */
+  if (ctx->magic == M_IMAP)
+  {
+    if ((check = imap_sync_mailbox (ctx, purge, index_hint)) != 0)
+    {
+      ctx->closing = 0;
+      return check;
+    }
+  }
+  else
+#endif
+  {
+    if (!purge)
+    {
+      for (i = 0; i < ctx->msgcount; i++)
+        ctx->hdrs[i]->deleted = 0;
+      ctx->deleted = 0;
+    }
+
+    if (ctx->changed || ctx->deleted)
+    {
+      if ((check = sync_mailbox (ctx, index_hint)) != 0)
+      {
+	ctx->closing = 0;
+	return check;
+      }
+    }
+  }
+
+  if (!ctx->quiet)
+  {
+    if (move_messages)
+      mutt_message (_("%d kept, %d moved, %d deleted."),
+	ctx->msgcount - ctx->deleted, read_msgs, ctx->deleted);
+    else
+      mutt_message (_("%d kept, %d deleted."),
+	ctx->msgcount - ctx->deleted, ctx->deleted);
+  }
+
+  if (ctx->msgcount == ctx->deleted &&
+      (ctx->magic == M_MMDF || ctx->magic == M_MBOX) &&
+      !mutt_is_spool(ctx->path) && !option (OPTSAVEEMPTY))
+    mx_unlink_empty (ctx->path);
+
+  mx_fastclose_mailbox (ctx);
+
+  return 0;
+}
+
+
+/* update a Context structure's internal tables. */
+
+void mx_update_tables(CONTEXT *ctx, int committing)
+{
+  int i, j;
+  
+  /* update memory to reflect the new state of the mailbox */
+  ctx->vcount = 0;
+  ctx->vsize = 0;
+  ctx->tagged = 0;
+  ctx->deleted = 0;
+  ctx->new = 0;
+  ctx->unread = 0;
+  ctx->changed = 0;
+  ctx->flagged = 0;
+#define this_body ctx->hdrs[j]->content
+  for (i = 0, j = 0; i < ctx->msgcount; i++)
+  {
+    if ((committing && (!ctx->hdrs[i]->deleted || 
+			(ctx->magic == M_MAILDIR && option (OPTMAILDIRTRASH)))) ||
+	(!committing && ctx->hdrs[i]->active))
+    {
+      if (i != j)
+      {
+	ctx->hdrs[j] = ctx->hdrs[i];
+	ctx->hdrs[i] = NULL;
+      }
+      ctx->hdrs[j]->msgno = j;
+      if (ctx->hdrs[j]->virtual != -1)
+      {
+	ctx->v2r[ctx->vcount] = j;
+	ctx->hdrs[j]->virtual = ctx->vcount++;
+	ctx->vsize += this_body->length + this_body->offset -
+	  this_body->hdr_offset;
+      }
+
+      if (committing)
+	ctx->hdrs[j]->changed = 0;
+      else if (ctx->hdrs[j]->changed)
+	ctx->changed++;
+      
+      if (!committing || (ctx->magic == M_MAILDIR && option (OPTMAILDIRTRASH)))
+      {
+	if (ctx->hdrs[j]->deleted)
+	  ctx->deleted++;
+      }
+
+      if (ctx->hdrs[j]->tagged)
+	ctx->tagged++;
+      if (ctx->hdrs[j]->flagged)
+	ctx->flagged++;
+      if (!ctx->hdrs[j]->read)
+      { 
+	ctx->unread++;
+	if (!ctx->hdrs[j]->old)
+	  ctx->new++;
+      } 
+
+      j++;
+    }
+    else
+    {
+      if (ctx->magic == M_MH || ctx->magic == M_MAILDIR)
+	ctx->size -= (ctx->hdrs[i]->content->length +
+		      ctx->hdrs[i]->content->offset -
+		      ctx->hdrs[i]->content->hdr_offset);
+      /* remove message from the hash tables */
+      if (ctx->subj_hash && ctx->hdrs[i]->env->real_subj)
+	hash_delete (ctx->subj_hash, ctx->hdrs[i]->env->real_subj, ctx->hdrs[i], NULL);
+      if (ctx->id_hash && ctx->hdrs[i]->env->message_id)
+	hash_delete (ctx->id_hash, ctx->hdrs[i]->env->message_id, ctx->hdrs[i], NULL);
+      mutt_free_header (&ctx->hdrs[i]);
+    }
+  }
+#undef this_body
+  ctx->msgcount = j;
+}
+
+
+/* save changes to mailbox
+ *
+ * return values:
+ *	0		success
+ *	-1		error
+ */
+int mx_sync_mailbox (CONTEXT *ctx, int *index_hint)
+{
+  int rc, i;
+  int purge = 1;
+  int msgcount, deleted;
+
+  if (ctx->dontwrite)
+  {
+    char buf[STRING], tmp[STRING];
+    if (km_expand_key (buf, sizeof(buf),
+                       km_find_func (MENU_MAIN, OP_TOGGLE_WRITE)))
+      snprintf (tmp, sizeof(tmp), _(" Press '%s' to toggle write"), buf);
+    else
+      strfcpy (tmp, _("Use 'toggle-write' to re-enable write!"), sizeof(tmp));
+
+    mutt_error (_("Mailbox is marked unwritable. %s"), tmp);
+    return -1;
+  }
+  else if (ctx->readonly)
+  {
+    mutt_error _("Mailbox is read-only.");
+    return -1;
+  }
+
+  if (!ctx->changed && !ctx->deleted)
+  {
+    if (!ctx->quiet)
+      mutt_message _("Mailbox is unchanged.");
+    return (0);
+  }
+
+  if (ctx->deleted)
+  {
+    char buf[SHORT_STRING];
+
+    snprintf (buf, sizeof (buf), ctx->deleted == 1
+	     ? _("Purge %d deleted message?") : _("Purge %d deleted messages?"),
+	      ctx->deleted);
+    if ((purge = query_quadoption (OPT_DELETE, buf)) < 0)
+      return (-1);
+    else if (purge == M_NO)
+    {
+      if (!ctx->changed)
+	return 0; /* nothing to do! */
+      /* let IMAP servers hold on to D flags */
+      if (ctx->magic != M_IMAP)
+      {
+        for (i = 0 ; i < ctx->msgcount ; i++)
+          ctx->hdrs[i]->deleted = 0;
+        ctx->deleted = 0;
+      }
+    }
+    else if (ctx->last_tag && ctx->last_tag->deleted)
+      ctx->last_tag = NULL; /* reset last tagged msg now useless */
+  }
+
+  /* really only for IMAP - imap_sync_mailbox results in a call to
+   * mx_update_tables, so ctx->deleted is 0 when it comes back */
+  msgcount = ctx->msgcount;
+  deleted = ctx->deleted;
+
+#ifdef USE_IMAP
+  if (ctx->magic == M_IMAP)
+    rc = imap_sync_mailbox (ctx, purge, index_hint);
+  else
+#endif
+    rc = sync_mailbox (ctx, index_hint);
+  if (rc == 0)
+  {
+#ifdef USE_IMAP
+    if (ctx->magic == M_IMAP && !purge)
+    {
+      if (!ctx->quiet)
+        mutt_message _("Mailbox checkpointed.");
+    }
+    else
+#endif
+    {
+      if (!ctx->quiet)
+	mutt_message (_("%d kept, %d deleted."), msgcount - deleted,
+		      deleted);
+    }
+
+    mutt_sleep (0);
+    
+    if (ctx->msgcount == ctx->deleted &&
+	(ctx->magic == M_MBOX || ctx->magic == M_MMDF) &&
+	!mutt_is_spool (ctx->path) && !option (OPTSAVEEMPTY))
+    {
+      unlink (ctx->path);
+      mx_fastclose_mailbox (ctx);
+      return 0;
+    }
+
+    /* if we haven't deleted any messages, we don't need to resort */
+    /* ... except for certain folder formats which need "unsorted" 
+     * sort order in order to synchronize folders.
+     * 
+     * MH and maildir are safe.  mbox-style seems to need re-sorting,
+     * at least with the new threading code.
+     */
+    if (purge || (ctx->magic != M_MAILDIR && ctx->magic != M_MH))
+    {
+      /* IMAP does this automatically after handling EXPUNGE */
+      if (ctx->magic != M_IMAP)
+      {
+	mx_update_tables (ctx, 1);
+	mutt_sort_headers (ctx, 1); /* rethread from scratch */
+      }
+    }
+  }
+
+  return (rc);
+}
+
+
+/* {maildir,mh}_open_new_message are in mh.c. */
+
+static int mbox_open_new_message (MESSAGE *msg, CONTEXT *dest, HEADER *hdr)
+{
+  msg->fp = dest->fp;
+  return 0;
+}
+
+#ifdef USE_IMAP
+static int imap_open_new_message (MESSAGE *msg, CONTEXT *dest, HEADER *hdr)
+{
+  char tmp[_POSIX_PATH_MAX];
+
+  mutt_mktemp (tmp, sizeof (tmp));
+  if ((msg->fp = safe_fopen (tmp, "w")) == NULL)
+  {
+    mutt_perror (tmp);
+    return (-1);
+  }
+  msg->path = safe_strdup(tmp);
+  return 0;
+}
+#endif
+
+/* args:
+ *	dest	destintation mailbox
+ *	hdr	message being copied (required for maildir support, because
+ *		the filename depends on the message flags)
+ */
+MESSAGE *mx_open_new_message (CONTEXT *dest, HEADER *hdr, int flags)
+{
+  MESSAGE *msg;
+  int (*func) (MESSAGE *, CONTEXT *, HEADER *);
+  ADDRESS *p = NULL;
+
+  switch (dest->magic)
+  {
+    case M_MMDF:
+    case M_MBOX:
+      func = mbox_open_new_message;
+      break;
+    case M_MAILDIR:
+      func = maildir_open_new_message;
+      break;
+    case M_MH:
+      func = mh_open_new_message;
+      break;
+#ifdef USE_IMAP
+    case M_IMAP:
+      func = imap_open_new_message;
+      break;
+#endif
+    default:
+      dprint (1, (debugfile, "mx_open_new_message(): function unimplemented for mailbox type %d.\n",
+		  dest->magic));
+      return (NULL);
+  }
+
+  msg = safe_calloc (1, sizeof (MESSAGE));
+  msg->magic = dest->magic;
+  msg->write = 1;
+
+  if (hdr)
+  {
+    msg->flags.flagged = hdr->flagged;
+    msg->flags.replied = hdr->replied;
+    msg->flags.read    = hdr->read;
+    msg->received = hdr->received;
+  }
+
+  if(msg->received == 0)
+    time(&msg->received);
+  
+  if (func (msg, dest, hdr) == 0)
+  {
+    if (dest->magic == M_MMDF)
+      fputs (MMDF_SEP, msg->fp);
+
+    if ((msg->magic == M_MBOX || msg->magic ==  M_MMDF) &&
+	flags & M_ADD_FROM)
+    {
+      if (hdr)
+      {
+	if (hdr->env->return_path)
+	  p = hdr->env->return_path;
+	else if (hdr->env->sender)
+	  p = hdr->env->sender;
+	else
+	  p = hdr->env->from;
+      }
+
+      fprintf (msg->fp, "From %s %s", p ? p->mailbox : NONULL(Username), ctime (&msg->received));
+    }
+  }
+  else
+    FREE (&msg);
+
+  return msg;
+}
+
+/* check for new mail */
+int mx_check_mailbox (CONTEXT *ctx, int *index_hint, int lock)
+{
+  int rc;
+
+  if (ctx)
+  {
+    if (ctx->locked) lock = 0;
+
+    switch (ctx->magic)
+    {
+      case M_MBOX:
+      case M_MMDF:
+
+	if (lock)
+	{
+	  mutt_block_signals ();
+	  if (mbox_lock_mailbox (ctx, 0, 0) == -1)
+	  {
+	    mutt_unblock_signals ();
+	    return M_LOCKED;
+	  }
+	}
+	
+	rc = mbox_check_mailbox (ctx, index_hint);
+
+	if (lock)
+	{
+	  mutt_unblock_signals ();
+	  mbox_unlock_mailbox (ctx);
+	}
+	
+	return rc;
+
+
+      case M_MH:
+	return (mh_check_mailbox (ctx, index_hint));
+      case M_MAILDIR:
+	return (maildir_check_mailbox (ctx, index_hint));
+
+#ifdef USE_IMAP
+      case M_IMAP:
+	/* caller expects that mailbox may change */
+        imap_allow_reopen (ctx);
+	rc = imap_check_mailbox (ctx, index_hint, 0);
+        imap_disallow_reopen (ctx);
+	return rc;
+#endif /* USE_IMAP */
+
+#ifdef USE_POP
+      case M_POP:
+	return (pop_check_mailbox (ctx, index_hint));
+#endif /* USE_POP */
+    }
+  }
+
+  dprint (1, (debugfile, "mx_check_mailbox: null or invalid context.\n"));
+  return (-1);
+}
+
+/* return a stream pointer for a message */
+MESSAGE *mx_open_message (CONTEXT *ctx, int msgno)
+{
+  MESSAGE *msg;
+  
+  msg = safe_calloc (1, sizeof (MESSAGE));
+  switch (msg->magic = ctx->magic)
+  {
+    case M_MBOX:
+    case M_MMDF:
+      msg->fp = ctx->fp;
+      break;
+
+    case M_MH:
+    case M_MAILDIR:
+    {
+      HEADER *cur = ctx->hdrs[msgno];
+      char path[_POSIX_PATH_MAX];
+      
+      snprintf (path, sizeof (path), "%s/%s", ctx->path, cur->path);
+      
+      if ((msg->fp = fopen (path, "r")) == NULL && errno == ENOENT &&
+	  ctx->magic == M_MAILDIR)
+	msg->fp = maildir_open_find_message (ctx->path, cur->path);
+      
+      if (msg->fp == NULL)
+      {
+	mutt_perror (path);
+	dprint (1, (debugfile, "mx_open_message: fopen: %s: %s (errno %d).\n",
+		    path, strerror (errno), errno));
+	FREE (&msg);
+      }
+    }
+    break;
+    
+#ifdef USE_IMAP
+    case M_IMAP:
+    {
+      if (imap_fetch_message (msg, ctx, msgno) != 0)
+	FREE (&msg);
+      break;
+    }
+#endif /* USE_IMAP */
+
+#ifdef USE_POP
+    case M_POP:
+    {
+      if (pop_fetch_message (msg, ctx, msgno) != 0)
+	FREE (&msg);
+      break;
+    }
+#endif /* USE_POP */
+
+    default:
+      dprint (1, (debugfile, "mx_open_message(): function not implemented for mailbox type %d.\n", ctx->magic));
+      FREE (&msg);
+      break;
+  }
+  return (msg);
+}
+
+/* commit a message to a folder */
+
+int mx_commit_message (MESSAGE *msg, CONTEXT *ctx)
+{
+  int r = 0;
+
+  if (!(msg->write && ctx->append))
+  {
+    dprint (1, (debugfile, "mx_commit_message(): msg->write = %d, ctx->append = %d\n",
+		msg->write, ctx->append));
+    return -1;
+  }
+
+  switch (msg->magic)
+  {
+    case M_MMDF:
+    {
+      if (fputs (MMDF_SEP, msg->fp) == EOF)
+	r = -1;
+      break;
+    }
+    
+    case M_MBOX:
+    {
+      if (fputc ('\n', msg->fp) == EOF)
+	r = -1;
+      break;
+    }
+
+#ifdef USE_IMAP
+    case M_IMAP:
+    {
+      if ((r = safe_fclose (&msg->fp)) == 0)
+	r = imap_append_message (ctx, msg);
+      break;
+    }
+#endif
+    
+    case M_MAILDIR:
+    {
+      r = maildir_commit_message (ctx, msg, NULL);
+      break;
+    }
+    
+    case M_MH:
+    {
+      r = mh_commit_message (ctx, msg, NULL);
+      break;
+    }
+  }
+  
+  if (r == 0 && (ctx->magic == M_MBOX || ctx->magic == M_MMDF)
+      && (fflush (msg->fp) == EOF || fsync (fileno (msg->fp)) == -1))
+  {
+    mutt_perror _("Can't write message");
+    r = -1;
+  }
+ 
+  return r;
+}
+
+/* close a pointer to a message */
+int mx_close_message (MESSAGE **msg)
+{
+  int r = 0;
+
+  if ((*msg)->magic == M_MH || (*msg)->magic == M_MAILDIR
+      || (*msg)->magic == M_IMAP || (*msg)->magic == M_POP)
+  {
+    r = safe_fclose (&(*msg)->fp);
+  }
+  else
+    (*msg)->fp = NULL;
+
+  if ((*msg)->path)
+  {
+    dprint (1, (debugfile, "mx_close_message (): unlinking %s\n",
+		(*msg)->path));
+    unlink ((*msg)->path);
+    FREE (&(*msg)->path);
+  }
+
+  FREE (msg);		/* __FREE_CHECKED__ */
+  return (r);
+}
+
+void mx_alloc_memory (CONTEXT *ctx)
+{
+  int i;
+  size_t s = MAX (sizeof (HEADER *), sizeof (int));
+  
+  if ((ctx->hdrmax + 25) * s < ctx->hdrmax * s)
+  {
+    mutt_error _("Integer overflow -- can't allocate memory.");
+    sleep (1);
+    mutt_exit (1);
+  }
+  
+  if (ctx->hdrs)
+  {
+    safe_realloc (&ctx->hdrs, sizeof (HEADER *) * (ctx->hdrmax += 25));
+    safe_realloc (&ctx->v2r, sizeof (int) * ctx->hdrmax);
+  }
+  else
+  {
+    ctx->hdrs = safe_calloc ((ctx->hdrmax += 25), sizeof (HEADER *));
+    ctx->v2r = safe_calloc (ctx->hdrmax, sizeof (int));
+  }
+  for (i = ctx->msgcount ; i < ctx->hdrmax ; i++)
+  {
+    ctx->hdrs[i] = NULL;
+    ctx->v2r[i] = -1;
+  }
+}
+
+/* this routine is called to update the counts in the context structure for
+ * the last message header parsed.
+ */
+void mx_update_context (CONTEXT *ctx, int new_messages)
+{
+  HEADER *h;
+  int msgno;
+
+  for (msgno = ctx->msgcount - new_messages; msgno < ctx->msgcount; msgno++)
+  {
+    h = ctx->hdrs[msgno];
+
+    if (WithCrypto)
+    {
+      /* NOTE: this _must_ be done before the check for mailcap! */
+      h->security = crypt_query (h->content);
+    }
+
+    if (!ctx->pattern)
+    {
+      ctx->v2r[ctx->vcount] = msgno;
+      h->virtual = ctx->vcount++;
+    }
+    else
+      h->virtual = -1;
+    h->msgno = msgno;
+
+    if (h->env->supersedes)
+    {
+      HEADER *h2;
+
+      if (!ctx->id_hash)	
+	ctx->id_hash = mutt_make_id_hash (ctx);
+
+      h2 = hash_find (ctx->id_hash, h->env->supersedes);
+
+      /* FREE (&h->env->supersedes); should I ? */
+      if (h2)
+      {
+	h2->superseded = 1;
+	if (option (OPTSCORE)) 
+	  mutt_score_message (ctx, h2, 1);
+      }
+    }
+
+    /* add this message to the hash tables */
+    if (ctx->id_hash && h->env->message_id)
+      hash_insert (ctx->id_hash, h->env->message_id, h, 0);
+    if (ctx->subj_hash && h->env->real_subj)
+      hash_insert (ctx->subj_hash, h->env->real_subj, h, 1);
+
+    if (option (OPTSCORE)) 
+      mutt_score_message (ctx, h, 0);
+
+    if (h->changed)
+      ctx->changed = 1;
+    if (h->flagged)
+      ctx->flagged++;
+    if (h->deleted)
+      ctx->deleted++;
+    if (!h->read)
+    {
+      ctx->unread++;
+      if (!h->old)
+	ctx->new++;
+    }
+  }
+}
+
+/*
+ * Return:
+ * 1 if the specified mailbox contains 0 messages.
+ * 0 if the mailbox contains messages
+ * -1 on error
+ */
+int mx_check_empty (const char *path)
+{
+  switch (mx_get_magic (path))
+  {
+    case M_MBOX:
+    case M_MMDF:
+      return mbox_check_empty (path);
+    case M_MH:
+      return mh_check_empty (path);
+    case M_MAILDIR:
+      return maildir_check_empty (path);
+    default:
+      errno = EINVAL;
+      return -1;
+  }
+  /* not reached */
+}
+
+/* vim: set sw=2: */
diff -udprP mutt-1.5.21/mx.h mutt-nntp-sidebar/mx.h
--- mutt-1.5.21/mx.h	2011-06-03 07:06:32.529621818 -0700
+++ mutt-nntp-sidebar/mx.h	2011-06-03 07:05:58.916289332 -0700
@@ -34,6 +34,9 @@ enum
   M_MMDF,
   M_MH,
   M_MAILDIR,
+#ifdef USE_NNTP
+  M_NNTP,
+#endif
   M_IMAP,
   M_POP
 };
diff -udprP mutt-1.5.21/newsrc.c mutt-nntp-sidebar/newsrc.c
--- mutt-1.5.21/newsrc.c	1969-12-31 17:00:00.000000000 -0700
+++ mutt-nntp-sidebar/newsrc.c	2011-06-03 07:05:58.929622666 -0700
@@ -0,0 +1,1170 @@
+/*
+ * Copyright (C) 1998 Brandon Long <blong@fiction.net>
+ * Copyright (C) 1999 Andrej Gritsenko <andrej@lucky.net>
+ * Copyright (C) 2000-2009 Vsevolod Volkov <vvv@mutt.org.ua>
+ * 
+ *     This program is free software; you can redistribute it and/or modify
+ *     it under the terms of the GNU General Public License as published by
+ *     the Free Software Foundation; either version 2 of the License, or
+ *     (at your option) any later version.
+ * 
+ *     This program is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ * 
+ *     You should have received a copy of the GNU General Public License
+ *     along with this program; if not, write to the Free Software
+ *     Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */ 
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include "mutt.h"
+#include "mutt_curses.h"
+#include "sort.h"
+#include "mx.h"
+#include "mime.h"
+#include "mailbox.h"
+#include "nntp.h"
+#include "rfc822.h"
+#include "rfc1524.h"
+#include "rfc2047.h"
+
+#include <unistd.h>
+#include <string.h>
+#include <ctype.h>
+#include <stdlib.h>
+#include <sys/stat.h>
+
+void nntp_add_to_list (NNTP_SERVER *s, NNTP_DATA *d)
+{
+  LIST *l;
+
+  if (!s || !d)
+    return;
+
+  l = safe_calloc (1, sizeof (LIST));
+  if (s->list)
+    s->tail->next = l;
+  else
+    s->list = l;
+  s->tail = l;
+  l->data = (void *) d;
+}
+
+static int nntp_parse_newsrc_line (NNTP_SERVER *news, char *line)
+{
+  NNTP_DATA *data;
+  char group[LONG_STRING];
+  int x = 1;
+  char *p = line, *b, *h;
+  size_t len;
+
+  while (*p)
+  {
+    if (*p++ == ',')
+      x++;
+  }
+
+  p = line;
+  while (*p && (*p != ':' && *p != '!')) p++;
+  if (!*p)
+    return -1;
+  len = p + 1 - line;
+  if (len > sizeof (group))
+    len = sizeof (group);
+  strfcpy (group, line, len);
+  if ((data = (NNTP_DATA *)hash_find (news->newsgroups, group)) == NULL)
+  {
+    data = (NNTP_DATA *) safe_calloc (1, sizeof (NNTP_DATA) + strlen (group) + 1);
+    data->group = (char *) data + sizeof (NNTP_DATA);
+    strcpy (data->group, group);
+    data->nserv = news;
+    data->deleted = 1;
+    if (news->newsgroups->nelem < news->newsgroups->curnelem * 2)
+      news->newsgroups = hash_resize (news->newsgroups, news->newsgroups->nelem * 2, 0);
+    hash_insert (news->newsgroups, data->group, data, 0);
+    nntp_add_to_list (news, data);
+  }
+  else
+    FREE ((void **) &data->entries);
+
+  data->rc = 1;
+  data->entries = safe_calloc (x*2, sizeof (NEWSRC_ENTRY));
+  data->max = x*2;
+
+  if (*p == ':')
+    data->subscribed = 1;
+  else
+    data->subscribed = 0;
+
+  p++;
+  b = p;
+  x = 0;
+  while (*b)
+  {
+    while (*p && *p != ',' && *p != '\n') p++;
+    if (*p)
+    {
+      *p = '\0';
+      p++;
+    }
+    if ((h = strchr(b, '-')))
+    {
+      *h = '\0';
+      h++;
+      data->entries[x].first = atoi(b);
+      data->entries[x].last = atoi(h);
+    }
+    else
+    {
+      data->entries[x].first = atoi(b);
+      data->entries[x].last = data->entries[x].first;
+    }
+    b = p;
+    if (data->entries[x].last != 0)
+      x++;
+  }
+  if (x && !data->lastMessage)
+    data->lastMessage = data->entries[x-1].last;
+  data->num = x;
+  mutt_newsgroup_stat (data);
+  dprint (2, (debugfile, "parse_line: Newsgroup %s\n", data->group));
+  
+  return 0;
+}
+
+static int slurp_newsrc (NNTP_SERVER *news)
+{
+  FILE *fp;
+  char *buf;
+  struct stat sb;
+
+  news->stat = stat (news->newsrc, &sb);
+  news->size = sb.st_size;
+  news->mtime = sb.st_mtime;
+
+  if ((fp = safe_fopen (news->newsrc, "r")) == NULL)
+    return -1;
+  /* hmm, should we use dotlock? */
+  if (mx_lock_file (news->newsrc, fileno (fp), 0, 0, 1))
+  {
+    fclose (fp);
+    return -1;
+  }
+
+  buf = safe_malloc (sb.st_size + 1);
+  while (sb.st_size && fgets (buf, sb.st_size + 1, fp))
+    nntp_parse_newsrc_line (news, buf);
+  FREE (&buf);
+
+  mx_unlock_file (news->newsrc, fileno (fp), 0);
+  fclose (fp);
+  return 0;
+}
+
+void nntp_cache_expand (char *dst, const char *src)
+{
+  snprintf (dst, _POSIX_PATH_MAX, "%s/%s", NewsCacheDir, src);
+  mutt_expand_path (dst, _POSIX_PATH_MAX);
+}
+
+/* Loads $news_cache_dir/.index into memory, loads newsserver data
+ * and newsgroup cache names */
+static int nntp_parse_cacheindex (NNTP_SERVER *news)
+{
+  struct stat st;
+  char buf[HUGE_STRING], *cp;
+  char dir[_POSIX_PATH_MAX], file[_POSIX_PATH_MAX];
+  FILE *index;
+  NNTP_DATA *data;
+  int l, m, t;
+
+  /* check is server name defined or not */
+  if (!news || !news->conn || !news->conn->account.host)
+    return -1;
+  unset_option (OPTNEWSCACHE);
+  if (!NewsCacheDir || !*NewsCacheDir)
+    return 0;
+
+  strfcpy (dir, NewsCacheDir, sizeof (dir));
+  mutt_expand_path (dir, sizeof(dir));
+
+  if (lstat (dir, &st) || (st.st_mode & S_IFDIR) == 0)
+  {
+    snprintf (buf, sizeof(buf), _("Directory %s not exist. Create it?"), dir);
+    if (mutt_yesorno (buf, M_YES) != M_YES || mkdir (dir, (S_IRWXU+S_IRWXG+
+	  S_IRWXO)))
+    {
+      mutt_error _("Cache directory not created!");
+      return -1;
+    }
+    mutt_clear_error();
+  }
+
+  set_option (OPTNEWSCACHE);
+
+  FREE (&news->cache);
+  snprintf (buf, sizeof(buf), "%s/.index", dir);
+  if (!(index = safe_fopen (buf, "a+")))
+    return 0;
+  rewind (index);
+  while (fgets (buf, sizeof(buf), index))
+  {
+    buf[strlen(buf) - 1] = 0;	/* strip ending '\n' */
+    if (!mutt_strncmp (buf, "#: ", 3) &&
+	!mutt_strcasecmp (buf+3, news->conn->account.host))
+      break;
+  }
+  while (fgets (buf, sizeof(buf), index))
+  {
+    cp = buf;
+    while (*cp && *cp != ' ') cp++;
+    if (!*cp) continue;
+    cp[0] = 0;
+    if (!mutt_strcmp (buf, "#:"))
+      break;
+    sscanf (cp + 1, "%s %d %d", file, &l, &m);
+    if (!mutt_strcmp (buf, "ALL"))
+    {
+      news->cache = safe_strdup (file);
+      news->newgroups_time = m;
+    }
+    else if (news->newsgroups)
+    {
+      if ((data = (NNTP_DATA *)hash_find (news->newsgroups, buf)) == NULL)
+      {
+	data = (NNTP_DATA *) safe_calloc (1, sizeof (NNTP_DATA) + strlen (buf) + 1);
+	data->group = (char *) data + sizeof (NNTP_DATA);
+	strcpy(data->group, buf);
+	data->nserv = news;
+	data->deleted = 1;
+	if (news->newsgroups->nelem < news->newsgroups->curnelem * 2)
+	  news->newsgroups = hash_resize (news->newsgroups, news->newsgroups->nelem * 2, 0);
+	hash_insert (news->newsgroups, data->group, data, 0);
+	nntp_add_to_list (news, data);
+      }
+      data->cache = safe_strdup (file);
+      t = 0;
+      if (!data->firstMessage || data->lastMessage < m)
+	t = 1;
+      if (!data->firstMessage)
+	data->firstMessage = l;
+      if (data->lastMessage < m)
+	data->lastMessage = m;
+      data->lastCached = m;
+      if (t || !data->unread)
+	mutt_newsgroup_stat (data);
+    }
+  }
+  fclose (index);
+  return 0;
+}
+
+const char *
+nntp_format_str (char *dest, size_t destlen, size_t col, char op, const char *src,
+		const char *fmt, const char *ifstring, const char *elsestring,
+		unsigned long data, format_flag flags)
+{
+  char fn[SHORT_STRING], tmp[SHORT_STRING];
+
+  switch (op)
+  {
+    case 's':
+      strncpy (fn, NewsServer, sizeof(fn) - 1);
+      mutt_strlower (fn);
+      snprintf (tmp, sizeof (tmp), "%%%ss", fmt);
+      snprintf (dest, destlen, tmp, fn);
+      break;
+  }
+  return (src);
+}
+
+/* nntp_parse_url: given an NNPT URL, return host, port,
+ * username, password and newsgroup will recognise. */
+int nntp_parse_url (const char *server, ACCOUNT *acct,
+		    char *group, size_t group_len)
+{
+  ciss_url_t url;
+  char *c;
+  int ret = -1;
+
+  /* Defaults */
+  acct->flags = 0;
+  acct->port = NNTP_PORT;
+  acct->type = M_ACCT_TYPE_NNTP;
+
+  c = safe_strdup (server);
+  url_parse_ciss (&url, c);
+
+  if (url.scheme == U_NNTP || url.scheme == U_NNTPS)
+  {
+    if (url.scheme == U_NNTPS)
+    {
+      acct->flags |= M_ACCT_SSL;
+      acct->port = NNTP_SSL_PORT;
+    }
+
+    *group = '\0';
+    if (url.path)
+      strfcpy (group, url.path, group_len);
+
+    ret = mutt_account_fromurl (acct, &url);
+  }
+
+  FREE (&c);
+  return ret;
+}
+
+void nntp_expand_path (char *line, size_t len, ACCOUNT *acct)
+{
+  ciss_url_t url;
+
+  url.path = safe_strdup (line);
+  mutt_account_tourl (acct, &url);
+  url_ciss_tostring (&url, line, len, 0);
+  FREE (&url.path);
+}
+
+/*
+ * Automatically loads a newsrc into memory, if necessary.
+ * Checks the size/mtime of a newsrc file, if it doesn't match, load
+ * again.  Hmm, if a system has broken mtimes, this might mean the file
+ * is reloaded every time, which we'd have to fix.
+ *
+ * a newsrc file is a line per newsgroup, with the newsgroup, then a 
+ * ':' denoting subscribed or '!' denoting unsubscribed, then a 
+ * comma separated list of article numbers and ranges.
+ */
+NNTP_SERVER *mutt_select_newsserver (char *server)
+{
+  char file[_POSIX_PATH_MAX];
+  char *buf, *p;
+  LIST *list;
+  ACCOUNT acct;
+  NNTP_SERVER *serv;
+  CONNECTION *conn;
+
+  if (!server || !*server)
+  {
+    mutt_error _("No newsserver defined!");
+    return NULL;
+  }
+
+  buf = p = safe_calloc (strlen (server) + 10, sizeof (char));
+  if (url_check_scheme (server) == U_UNKNOWN)
+  {
+    strcpy (buf, "news://");
+    p = strchr (buf, '\0');
+  }
+  strcpy (p, server);
+
+  if ((nntp_parse_url (buf, &acct, file, sizeof (file))) < 0 || *file)
+  {
+    FREE (&buf);
+    mutt_error (_("%s is an invalid newsserver specification!"), server);
+    return NULL;
+  }
+  FREE (&buf);
+
+  conn = mutt_conn_find (NULL, &acct);
+  if (!conn)
+    return NULL;
+
+  mutt_FormatString (file, sizeof (file), 0, NONULL (NewsRc), nntp_format_str, 0, 0);
+  mutt_expand_path (file, sizeof (file));
+
+  serv = (NNTP_SERVER *)conn->data;
+  if (serv)
+  {
+    struct stat sb;
+
+    /* externally modified? */
+    if (serv->stat != stat (file, &sb) || (!serv->stat &&
+       (serv->size != sb.st_size || serv->mtime != sb.st_mtime)))
+    {
+      for (list = serv->list; list; list = list->next)
+      {
+	NNTP_DATA *data = (NNTP_DATA *) list->data;
+
+	if (data)
+	{
+	  data->subscribed = 0;
+	  data->rc = 0;
+	  data->num = 0;
+	}
+      }
+      slurp_newsrc (serv);
+      nntp_clear_cacheindex (serv);
+    }
+
+    if (serv->status == NNTP_BYE)
+      serv->status = NNTP_NONE;
+    nntp_check_newgroups (serv, 0);
+    return serv;
+  }
+
+  /* New newsserver */
+  serv = safe_calloc (1, sizeof (NNTP_SERVER));
+  serv->conn = conn;
+  serv->newsrc = safe_strdup (file);
+  serv->newsgroups = hash_create (1009, 0);
+  slurp_newsrc (serv);			/* load .newsrc */
+  nntp_parse_cacheindex (serv);		/* load .index */
+  if (option (OPTNEWSCACHE) && serv->cache && nntp_get_cache_all (serv) >= 0)
+    nntp_check_newgroups (serv, 1);
+  else if (nntp_get_active (serv) < 0)
+  {
+    hash_destroy (&serv->newsgroups, nntp_delete_data);
+    for (list = serv->list; list; list = list->next)
+      list->data = NULL;
+    mutt_free_list (&serv->list);
+    FREE (&serv->newsrc);
+    FREE (&serv->cache);
+    FREE (&serv);
+    return NULL;
+  }
+  nntp_clear_cacheindex (serv);
+  conn->data = (void *)serv;
+
+  return serv;
+}
+
+/* 
+ * full status flags are not supported by nntp, but we can fake some
+ * of them.  This is how:
+ * Read = a read message number is in the .newsrc
+ * New = a message is new since we last read this newsgroup
+ * Old = anything else
+ * So, Read is marked as such in the newsrc, old is anything that is 
+ * "skipped" in the newsrc, and new is anything not in the newsrc nor
+ * in the cache. By skipped, I mean before the last unread message
+ */
+void nntp_get_status (CONTEXT *ctx, HEADER *h, char *group, int article)
+{
+  NNTP_DATA *data = (NNTP_DATA *) ctx->data;
+  int x;
+
+  if (group)
+    data = (NNTP_DATA *) hash_find (data->nserv->newsgroups, group);
+
+  if (!data)
+  {
+#ifdef DEBUG
+    if (group)
+      dprint (3, (debugfile, "newsgroup %s not found\n", group));
+#endif
+    return;
+  }
+
+  for (x = 0; x < data->num; x++)
+  {
+    if ((article >= data->entries[x].first) &&
+	(article <= data->entries[x].last))
+    {
+      /* we cannot use mutt_set_flag() because mx_update_context()
+	 didn't called yet */
+      h->read = 1;
+      return;
+    }
+  }
+  /* If article was not cached yet, it is new! :) */
+  if (!data->cache || article > data->lastCached)
+    return;
+  /* Old articles are articles which aren't read but an article after them
+   * has been cached */
+  if (option (OPTMARKOLD))
+    h->old = 1;
+}
+
+void mutt_newsgroup_stat (NNTP_DATA *data)
+{
+  int i;
+  unsigned int first, last;
+
+  data->unread = 0;
+  if (data->lastMessage == 0 || data->firstMessage > data->lastMessage)
+    return;
+
+  data->unread = data->lastMessage - data->firstMessage + 1;
+  for (i = 0; i < data->num; i++)
+  {
+    first = data->entries[i].first;
+    if (first < data->firstMessage)
+      first = data->firstMessage;
+    last = data->entries[i].last;
+    if (last > data->lastMessage)
+      last = data->lastMessage;
+    if (first <= last)
+      data->unread -= last - first + 1;
+  }
+}
+
+static int puti (char *line, int num)
+{
+  char *p, s[32];
+
+  for (p = s; num; )
+  {
+    *p++ = '0' + num % 10;
+    num /= 10;
+  }
+  while (p > s)
+    *line++ = *--p, num++;
+  *line = '\0';
+  return num;
+}
+
+static void nntp_create_newsrc_line (NNTP_DATA *data, char **buf, char **pline, size_t *buflen)
+{
+  char *line = *pline;
+  size_t len = *buflen - (*pline - *buf);
+  int x, i;
+
+  if (len < LONG_STRING * 10)
+  {
+    len += *buflen;
+    *buflen *= 2;
+    line = *buf;
+    safe_realloc (buf, *buflen);
+    line = *buf + (*pline - line);
+  }
+  strcpy (line, data->group);
+  len -= strlen (line) + 1;
+  line += strlen (line);
+  *line++ = data->subscribed ? ':' : '!';
+  *line++ = ' ';
+  *line = '\0';
+
+  for (x = 0; x < data->num; x++)
+  {
+    if (len < LONG_STRING)
+    {
+      len += *buflen;
+      *buflen *= 2;
+      *pline = line;
+      line = *buf;
+      safe_realloc (buf, *buflen);
+      line = *buf + (*pline - line);
+    }
+    if (x)
+    {
+      *line++ = ',';
+      len--;
+    }
+
+#if 0
+    if (data->entries[x].first == data->entries[x].last)
+      snprintf (line, len, "%d%n", data->entries[x].first, &i);
+    else
+      snprintf (line, len, "%d-%d%n", 
+	    data->entries[x].first, data->entries[x].last, &i);
+    len -= i;
+    line += i;
+#else
+    i = puti (line, data->entries[x].first);
+    line +=i; len -= i;
+    if (data->entries[x].first != data->entries[x].last)
+    {
+      *line++ = '-';
+      len--;
+      i = puti (line, data->entries[x].last);
+      line +=i; len -= i;
+    }
+#endif
+  }
+  *line++ = '\n';
+  *line = '\0';
+  *pline = line;
+}
+
+void newsrc_gen_entries (CONTEXT *ctx)
+{
+  NNTP_DATA *data = (NNTP_DATA *)ctx->data;
+  int series, x;
+  unsigned int last = 0, first = 1;
+  int save_sort = SORT_ORDER;
+
+  if (Sort != SORT_ORDER)
+  {
+    save_sort = Sort;
+    Sort = SORT_ORDER;
+    mutt_sort_headers (ctx, 0);
+  }
+
+  if (!data->max)
+  {
+    data->entries = safe_calloc (5, sizeof (NEWSRC_ENTRY));
+    data->max = 5;
+  }
+
+  /*
+   * Set up to fake initial sequence from 1 to the article before the 
+   * first article in our list
+   */
+  data->num = 0;
+  series = 1;
+
+  for (x = 0; x < ctx->msgcount; x++)
+  {
+    if (series) /* search for first unread */
+    {
+      /*
+       * We don't actually check sequential order, since we mark 
+       * "missing" entries as read/deleted
+       */
+      last = ctx->hdrs[x]->article_num;
+      if (last >= data->firstMessage && !ctx->hdrs[x]->deleted &&
+	    !ctx->hdrs[x]->read)
+      {
+	if (data->num >= data->max)
+	{
+	  data->max = data->max * 2;
+	  safe_realloc (&data->entries, 
+	      data->max * sizeof (NEWSRC_ENTRY));
+	}
+	data->entries[data->num].first = first;
+	data->entries[data->num].last = last - 1;
+	data->num++;
+	series = 0;
+      }
+    }
+    else /* search for first read */
+    {
+      if (ctx->hdrs[x]->deleted || ctx->hdrs[x]->read)
+      {
+	first = last + 1;
+	series = 1;
+      }
+      last = ctx->hdrs[x]->article_num;
+    }
+  }
+  if (series && first <= data->lastLoaded)
+  {
+    if (data->num >= data->max)
+    {
+      data->max = data->max * 2;
+      safe_realloc (&data->entries, 
+		    data->max * sizeof (NEWSRC_ENTRY));
+    }
+    data->entries[data->num].first = first;
+    data->entries[data->num].last = data->lastLoaded;
+    data->num++;
+  }
+
+  if (save_sort != Sort)
+  {
+    Sort = save_sort;
+    mutt_sort_headers (ctx, 0);
+  }
+}
+
+static int mutt_update_list_file (char *filename, char *section,
+				  char *key, char *line)
+{
+  FILE *ifp;
+  FILE *ofp;
+  char buf[HUGE_STRING];
+  char tmpfile[_POSIX_PATH_MAX];
+  char *c;
+  int ext = 0, done = 0, r = 0;
+
+  /* if file not exist, create it */
+  if ((ifp = safe_fopen (filename, "a")))
+    fclose (ifp);
+  dprint (1, (debugfile, "Opening %s\n", filename));
+  if (!(ifp = safe_fopen (filename, "r")))
+  {
+    mutt_error (_("Unable to open %s for reading"), filename);
+    return -1;
+  }
+  if (mx_lock_file (filename, fileno (ifp), 0, 0, 1))
+  {
+    fclose (ifp);
+    mutt_error (_("Unable to lock %s"), filename);
+    return -1;
+  }
+  snprintf (tmpfile, sizeof(tmpfile), "%s.tmp", filename);
+  dprint (1, (debugfile, "Opening %s\n", tmpfile));
+  if (!(ofp = fopen (tmpfile, "w")))
+  {
+    fclose (ifp);
+    mutt_error (_("Unable to open %s for writing"), tmpfile);
+    return -1;
+  }
+
+  if (section)
+  {
+    while (r != EOF && !done && fgets (buf, sizeof (buf), ifp))
+    {
+      r = fputs (buf, ofp);
+      c = buf;
+      while (*c && *c != '\n') c++;
+      c[0] = 0;	/* strip EOL */
+      if (!strncmp (buf, "#: ", 3) && !mutt_strcasecmp (buf+3, section))
+	done++;
+    }
+    if (r != EOF && !done)
+    {
+      snprintf (buf, sizeof(buf), "#: %s\n", section);
+      r = fputs (buf, ofp);
+    }
+    done = 0;
+  }
+
+  while (r != EOF && fgets (buf, sizeof (buf), ifp))
+  {
+    if (ext)
+    {
+      c = buf;
+      while (*c && (*c != '\r') && (*c != '\n')) c++;
+      c--;
+      if (*c != '\\') ext = 0;
+    }
+    else if ((section && !strncmp (buf, "#: ", 3)))
+    {
+      if (!done && line)
+      {
+	fputs (line, ofp);
+	fputc ('\n', ofp);
+      }
+      r = fputs (buf, ofp);
+      done++;
+      break;
+    }
+    else if (key && !strncmp (buf, key, strlen(key)) &&
+	    (!*key || buf[strlen(key)] == ' '))
+    {
+      c = buf;
+      ext = 0;
+      while (*c && (*c != '\r') && (*c != '\n')) c++;
+      c--;
+      if (*c == '\\') ext = 1;
+      if (!done && line)
+      {
+	r = fputs (line, ofp);
+	if (*key)
+	  r = fputc ('\n', ofp);
+	done++;
+      }
+    }
+    else
+    {
+      r = fputs (buf, ofp);
+    }
+  }
+
+  while (r != EOF && fgets (buf, sizeof (buf), ifp))
+    r = fputs (buf, ofp);
+
+  /* If there wasn't a line to replace, put it on the end of the file */
+  if (r != EOF && !done && line)
+  {
+    fputs (line, ofp);
+    r = fputc ('\n', ofp);
+  }
+  mx_unlock_file (filename, fileno (ifp), 0);
+  fclose (ofp);
+  fclose (ifp);
+  if (r == EOF)
+  {
+    unlink (tmpfile);
+    mutt_error (_("Can't write %s"), tmpfile);
+    return -1;
+  }
+  if (rename (tmpfile, filename) < 0)
+  {
+    unlink (tmpfile);
+    mutt_error (_("Can't rename %s to %s"), tmpfile, filename);
+    return -1;
+  }
+  return 0;
+}
+
+int mutt_newsrc_update (NNTP_SERVER *news)
+{
+  char *buf, *line;
+  NNTP_DATA *data;
+  LIST *tmp;
+  int r = -1;
+  size_t len, llen;
+
+  if (!news)
+    return -1;
+  llen = len = 10 * LONG_STRING;
+  line = buf = safe_calloc (1, len);
+  /* we will generate full newsrc here */
+  for (tmp = news->list; tmp; tmp = tmp->next)
+  {
+    data = (NNTP_DATA *) tmp->data;
+    if (!data || !data->rc)
+      continue;
+    nntp_create_newsrc_line (data, &buf, &line, &llen);
+    if (*line)
+      dprint (2, (debugfile, "Added to newsrc: %s\n", line));
+    line += strlen (line);
+  }
+  /* newrc being fully rewritten */
+  if (news->newsrc &&
+     (r = mutt_update_list_file (news->newsrc, NULL, "", buf)) == 0)
+  {
+    struct stat st;
+
+    stat (news->newsrc, &st);
+    news->size = st.st_size;
+    news->mtime = st.st_mtime;
+  }
+  FREE (&buf);
+  return r;
+}
+
+static FILE *mutt_mkname (char *s)
+{
+  char buf[_POSIX_PATH_MAX], *pc;
+  int fd;
+  FILE *fp;
+
+  nntp_cache_expand (buf, s);
+  if ((fp = safe_fopen (buf, "w")))
+    return fp;
+
+  nntp_cache_expand (buf, "cache-XXXXXX");
+  pc = buf + strlen (buf) - 12;	/* positioning to "cache-XXXXXX" */
+  if ((fd = mkstemp (buf)) == -1)
+    return NULL;
+  strcpy (s, pc);	/* generated name */
+  return fdopen (fd, "w");
+}
+
+/* Updates info into .index file: ALL or about selected newsgroup */
+static int nntp_update_cacheindex (NNTP_SERVER *serv, NNTP_DATA *data)
+{
+  char buf[LONG_STRING], *key = "ALL";
+  char file[_POSIX_PATH_MAX];
+
+  if (!serv || !serv->conn || !serv->conn->account.host)
+    return -1;
+
+  if (data && data->group)
+  {
+    key = data->group;
+    snprintf (buf, sizeof (buf), "%s %s %d %d", key, data->cache,
+	  data->firstMessage, data->lastLoaded);
+  }
+  else
+  {
+    strfcpy (file, serv->cache, sizeof (file));
+    snprintf (buf, sizeof (buf), "ALL %s 0 %d", file, (int)serv->newgroups_time);
+  }
+  nntp_cache_expand (file, ".index");
+  return mutt_update_list_file (file, serv->conn->account.host, key, buf);
+}
+
+/* Remove cache files of unsubscribed newsgroups */
+void nntp_clear_cacheindex (NNTP_SERVER *news)
+{
+  NNTP_DATA *data;
+  LIST *tmp;
+
+  if (option (OPTSAVEUNSUB) || !news)
+    return;
+
+  for (tmp = news->list; tmp; tmp = tmp->next)
+  {
+    data = (NNTP_DATA *) tmp->data;
+    if (!data || data->subscribed || !data->cache)
+      continue;
+    nntp_delete_cache (data);
+    dprint (2, (debugfile, "Removed from .index: %s\n", data->group));
+  }
+  return;
+}
+
+int nntp_save_cache_index (NNTP_SERVER *news)
+{
+  char buf[HUGE_STRING];
+  char file[_POSIX_PATH_MAX];
+  NNTP_DATA *d;
+  FILE *f;
+  LIST *l;
+
+  if (!news || !news->newsgroups)
+    return -1;
+  if (!option (OPTNEWSCACHE))
+    return 0;
+
+  if (news->cache)
+  {
+    nntp_cache_expand (file, news->cache);
+    unlink (file);
+    f = safe_fopen (file, "w");
+  }
+  else
+  {
+    strfcpy (buf, news->conn->account.host, sizeof(buf));
+    f = mutt_mkname (buf);
+    news->cache = safe_strdup (buf);
+    nntp_cache_expand (file, buf);
+  }
+  if (!f)
+    return -1;
+
+  for (l = news->list; l; l = l->next)
+  {
+    if ((d = (NNTP_DATA *)l->data) && !d->deleted)
+    {
+      if (d->desc)
+	snprintf (buf, sizeof(buf), "%s %d %d %c %s\n", d->group,
+	      d->lastMessage, d->firstMessage, d->allowed ? 'y' : 'n',
+ 	      d->desc);
+      else
+	snprintf (buf, sizeof(buf), "%s %d %d %c\n", d->group,
+	      d->lastMessage, d->firstMessage, d->allowed ? 'y' : 'n');
+      if (fputs (buf, f) == EOF)
+      {
+	fclose (f);
+	unlink (file);
+	return -1;
+      }
+    }
+  }
+  fclose (f);
+
+  if (nntp_update_cacheindex (news, NULL))
+  {
+    unlink (file);
+    return -1;
+  }
+  return 0;
+}
+
+int nntp_save_cache_group (CONTEXT *ctx)
+{
+  char buf[HUGE_STRING], addr[STRING];
+  char file[_POSIX_PATH_MAX];
+  FILE *f;
+  HEADER *h;
+  struct tm *tm;
+  int i = 0, save = SORT_ORDER;
+  int prev = 0;
+
+  if (!option (OPTNEWSCACHE))
+    return 0;
+  if (!ctx || !ctx->data || ctx->magic != M_NNTP)
+    return -1;
+
+  if (((NNTP_DATA *)ctx->data)->cache)
+  {
+    nntp_cache_expand (file, ((NNTP_DATA *)ctx->data)->cache);
+    unlink (file);
+    f = safe_fopen (file, "w");
+  }
+  else
+  {
+    snprintf (buf, sizeof(buf), "%s-%s",
+	((NNTP_DATA *)ctx->data)->nserv->conn->account.host,
+	((NNTP_DATA *)ctx->data)->group);
+    f = mutt_mkname (buf);
+    ((NNTP_DATA *)ctx->data)->cache = safe_strdup (buf);
+    nntp_cache_expand (file, buf);
+  }
+  if (!f)
+    return -1;
+
+  if (Sort != SORT_ORDER)
+  {
+    save = Sort;
+    Sort = SORT_ORDER;
+    mutt_sort_headers (ctx, 0);
+  }
+
+  /* Save only $nntp_context messages... */
+  ((NNTP_DATA *)ctx->data)->lastCached = 0;
+  if (NntpContext && ctx->msgcount > NntpContext)
+    i = ctx->msgcount - NntpContext;
+  for (; i < ctx->msgcount; i++)
+  {
+    if (!ctx->hdrs[i]->deleted && ctx->hdrs[i]->article_num != prev)
+    {
+      h = ctx->hdrs[i];
+      addr[0] = 0;
+      rfc822_write_address (addr, sizeof(addr), h->env->from, 0);
+      tm = gmtime (&h->date_sent);
+      snprintf (buf, sizeof(buf),
+	    "%d\t%s\t%s\t%d %s %d %02d:%02d:%02d GMT\t%s\t",
+	    h->article_num, h->env->subject, addr, tm->tm_mday,
+	    Months[tm->tm_mon], tm->tm_year+1900, tm->tm_hour, tm->tm_min,
+	    tm->tm_sec, h->env->message_id);
+      fputs (buf, f);
+      if (h->env->references)
+	mutt_write_references (h->env->references, f, -10);
+      snprintf (buf, sizeof(buf), "\t%ld\t%d\tXref: %s\n", (long int) h->content->length,
+	    (int) h->lines, NONULL(h->env->xref));
+      if (fputs (buf, f) == EOF)
+      {
+	fclose (f);
+	unlink (file);
+	return -1;
+      }
+    }
+    prev = ctx->hdrs[i]->article_num;
+  }
+
+  if (save != Sort)
+  {
+    Sort = save;
+    mutt_sort_headers (ctx, 0);
+  }
+  fclose (f);
+
+  if (nntp_update_cacheindex (((NNTP_DATA *)ctx->data)->nserv,
+	(NNTP_DATA *)ctx->data))
+  {
+    unlink (file);
+    return -1;
+  }
+  ((NNTP_DATA *)ctx->data)->lastCached = ((NNTP_DATA *)ctx->data)->lastLoaded;
+  return 0;
+}
+
+void nntp_delete_cache (NNTP_DATA *data)
+{
+  char buf[_POSIX_PATH_MAX];
+
+  if (!option (OPTNEWSCACHE) || !data || !data->cache || !data->nserv)
+    return;
+
+  nntp_cache_expand (buf, data->cache);
+  unlink (buf);
+  FREE (&data->cache);
+  data->lastCached = 0;
+  nntp_cache_expand (buf, ".index");
+  mutt_update_list_file (buf, data->nserv->conn->account.host, data->group, NULL);
+}
+
+NNTP_DATA *mutt_newsgroup_subscribe (NNTP_SERVER *news, char *group)
+{
+  NNTP_DATA *data;
+
+  if (!news || !news->newsgroups || !group || !*group)
+    return NULL;
+  if (!(data = (NNTP_DATA *)hash_find (news->newsgroups, group)))
+  {
+    data = (NNTP_DATA *) safe_calloc (1, sizeof (NNTP_DATA) + strlen (group) + 1);
+    data->group = (char *) data + sizeof (NNTP_DATA);
+    strcpy (data->group, group);
+    data->nserv = news;
+    data->deleted = 1;
+    if (news->newsgroups->nelem < news->newsgroups->curnelem * 2)
+      news->newsgroups = hash_resize (news->newsgroups, news->newsgroups->nelem * 2, 0);
+    hash_insert (news->newsgroups, data->group, data, 0);
+    nntp_add_to_list (news, data);
+  }
+  if (!data->subscribed)
+  {
+    data->subscribed = 1;
+    data->rc = 1;
+  }
+  return data;
+}
+
+NNTP_DATA *mutt_newsgroup_unsubscribe (NNTP_SERVER *news, char *group)
+{
+  NNTP_DATA *data;
+
+  if (!news || !news->newsgroups || !group || !*group ||
+	!(data = (NNTP_DATA *)hash_find (news->newsgroups, group)))
+    return NULL;
+  if (data->subscribed)
+  {
+    data->subscribed = 0;
+    if (!option (OPTSAVEUNSUB))
+      data->rc = 0;
+  }
+  return data;
+}
+
+NNTP_DATA *mutt_newsgroup_catchup (NNTP_SERVER *news, char *group)
+{
+  NNTP_DATA *data;
+
+  if (!news || !news->newsgroups || !group || !*group ||
+      !(data = (NNTP_DATA *)hash_find (news->newsgroups, group)))
+    return NULL;
+  if (!data->max)
+  {
+    data->entries = safe_calloc (5, sizeof (NEWSRC_ENTRY));
+    data->max = 5;
+  }
+  data->num = 1;
+  data->entries[0].first = 1;
+  data->unread = 0;
+  data->entries[0].last = data->lastMessage;
+  if (Context && Context->data == data)
+  {
+    int x;
+
+    for (x = 0; x < Context->msgcount; x++)
+      mutt_set_flag (Context, Context->hdrs[x], M_READ, 1);
+  }
+  return data;
+}
+
+NNTP_DATA *mutt_newsgroup_uncatchup (NNTP_SERVER *news, char *group)
+{
+  NNTP_DATA *data;
+
+  if (!news || !news->newsgroups || !group || !*group ||
+      !(data = (NNTP_DATA *)hash_find (news->newsgroups, group)))
+    return NULL;
+  if (!data->max)
+  {
+    data->entries = safe_calloc (5, sizeof (NEWSRC_ENTRY));
+    data->max = 5;
+  }
+  data->num = 1;
+  data->entries[0].first = 1;
+  data->entries[0].last = data->firstMessage - 1;
+  if (Context && Context->data == data)
+  {
+    int x;
+
+    data->unread = Context->msgcount;
+    for (x = 0; x < Context->msgcount; x++)
+      mutt_set_flag (Context, Context->hdrs[x], M_READ, 0);
+  }
+  else
+    data->unread = data->lastMessage - data->entries[0].last;
+  return data;
+}
+
+/* this routine gives the first newsgroup with new messages */
+void nntp_buffy (char *s)
+{
+  LIST *list;
+
+  for (list = CurrentNewsSrv->list; list; list = list->next)
+  {
+    NNTP_DATA *data = (NNTP_DATA *) list->data;
+
+    if (data && data->subscribed && data->unread)
+    {
+      if (Context && Context->magic == M_NNTP &&
+	  !mutt_strcmp (data->group, ((NNTP_DATA *) Context->data)->group))
+      {
+	unsigned int i, unread = 0;
+
+	for (i = 0; i < Context->msgcount; i++)
+	  if (!Context->hdrs[i]->read && !Context->hdrs[i]->deleted)
+	    unread++;
+	if (!unread)
+	  continue;
+      }
+      strcpy (s, data->group);
+      break;
+    }
+  }
+}
diff -udprP mutt-1.5.21/nntp.c mutt-nntp-sidebar/nntp.c
--- mutt-1.5.21/nntp.c	1969-12-31 17:00:00.000000000 -0700
+++ mutt-nntp-sidebar/nntp.c	2011-06-03 07:05:58.906289332 -0700
@@ -0,0 +1,1588 @@
+/*
+ * Copyright (C) 1998 Brandon Long <blong@fiction.net>
+ * Copyright (C) 1999 Andrej Gritsenko <andrej@lucky.net>
+ * Copyright (C) 2000-2007 Vsevolod Volkov <vvv@mutt.org.ua>
+ * 
+ *     This program is free software; you can redistribute it and/or modify
+ *     it under the terms of the GNU General Public License as published by
+ *     the Free Software Foundation; either version 2 of the License, or
+ *     (at your option) any later version.
+ * 
+ *     This program is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ * 
+ *     You should have received a copy of the GNU General Public License
+ *     along with this program; if not, write to the Free Software
+ *     Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */ 
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include "mutt.h"
+#include "mutt_curses.h"
+#include "sort.h"
+#include "mx.h"
+#include "mime.h"
+#include "rfc1524.h"
+#include "rfc2047.h"
+#include "mailbox.h"
+#include "nntp.h"
+
+#ifdef HAVE_PGP
+#include "pgp.h"
+#endif
+
+#ifdef HAVE_SMIME
+#include "smime.h"
+#endif
+
+#include <unistd.h>
+#include <string.h>
+#include <ctype.h>
+#include <stdlib.h>
+
+static unsigned int _checked = 0;
+
+#ifdef DEBUG
+static void nntp_error (const char *where, const char *msg)
+{
+  dprint (1, (debugfile, "nntp_error(): unexpected response in %s: %s\n", where, msg));
+}
+#endif /* DEBUG */
+
+static int nntp_auth (NNTP_SERVER *serv)
+{
+  CONNECTION *conn = serv->conn;
+  char buf[STRING];
+  unsigned char flags = conn->account.flags;
+
+  if (mutt_account_getuser (&conn->account) || !conn->account.user[0] ||
+      mutt_account_getpass (&conn->account) || !conn->account.pass[0])
+  {
+    conn->account.flags = flags;
+    return -2;
+  }
+
+  mutt_message _("Logging in...");
+
+  snprintf (buf, sizeof (buf), "AUTHINFO USER %s\r\n", conn->account.user);
+  mutt_socket_write (conn, buf);
+  if (mutt_socket_readln (buf, sizeof (buf), conn) < 0)
+  {
+    conn->account.flags = flags;
+    return -1;
+  }
+
+#ifdef DEBUG
+  /* don't print the password unless we're at the ungodly debugging level */
+  if (debuglevel < M_SOCK_LOG_FULL)
+    dprint (M_SOCK_LOG_CMD, (debugfile, "> AUTHINFO PASS *\n"));
+#endif
+  snprintf (buf, sizeof (buf), "AUTHINFO PASS %s\r\n", conn->account.pass);
+  mutt_socket_write_d (conn, buf, -1, M_SOCK_LOG_FULL);
+  if (mutt_socket_readln (buf, sizeof (buf), conn) < 0)
+  {
+    conn->account.flags = flags;
+    return -1;
+  }
+
+  if (mutt_strncmp ("281", buf, 3))
+  {
+    conn->account.flags = flags;
+    mutt_error _("Login failed.");
+    sleep (2);
+    return -3;
+  }
+
+  return 0;
+}
+
+static int nntp_connect_error (NNTP_SERVER *serv)
+{
+  serv->status = NNTP_NONE;
+  mutt_socket_close (serv->conn);
+  mutt_error _("Server closed connection!");
+  sleep (2);
+  return -1;
+}
+
+static int nntp_connect_and_auth (NNTP_SERVER *serv)
+{
+  CONNECTION *conn = serv->conn;
+  char buf[STRING];
+  int rc;
+
+  serv->status = NNTP_NONE;
+
+  if (mutt_socket_open (conn) < 0)
+    return -1;
+
+  if (mutt_socket_readln (buf, sizeof (buf), conn) < 0)
+    return nntp_connect_error (serv);
+
+  if (!mutt_strncmp ("200", buf, 3))
+    mutt_message (_("Connected to %s. Posting ok."), conn->account.host);
+  else if (!mutt_strncmp ("201", buf, 3))
+    mutt_message (_("Connected to %s. Posting NOT ok."), conn->account.host);
+  else
+  {
+    mutt_socket_close (conn);
+    mutt_remove_trailing_ws (buf);
+    mutt_error ("%s", buf);
+    sleep (2);
+    return -1;
+  }
+
+  sleep (1);
+
+  /* Tell INN to switch to mode reader if it isn't so. Ignore all
+   returned codes and messages. */
+  mutt_socket_write (conn, "MODE READER\r\n");
+  if (mutt_socket_readln (buf, sizeof (buf), conn) < 0)
+    return nntp_connect_error (serv);
+
+  mutt_socket_write (conn, "STAT\r\n");
+  if (mutt_socket_readln (buf, sizeof (buf), conn) < 0)
+    return nntp_connect_error (serv);
+
+  if (!(conn->account.flags & M_ACCT_USER) && mutt_strncmp ("480", buf, 3))
+  {
+    serv->status = NNTP_OK;
+    return 0;
+  }
+
+  rc = nntp_auth (serv);
+  if (rc == -1)
+    return nntp_connect_error (serv);
+  if (rc == -2)
+  {
+    mutt_socket_close (conn);
+    serv->status = NNTP_BYE;
+    return -1;
+  }
+  if (rc < 0)
+  {
+    mutt_socket_close (conn);
+    mutt_error _("Login failed.");
+    sleep (2);
+    return -1;
+  }
+  serv->status = NNTP_OK;
+  return 0;
+}
+
+static int nntp_attempt_features (NNTP_SERVER *serv)
+{
+  char buf[LONG_STRING];
+  CONNECTION *conn = serv->conn;
+
+  mutt_socket_write (conn, "XOVER\r\n");
+  if (mutt_socket_readln (buf, sizeof (buf), conn) < 0)
+    return nntp_connect_error (serv);
+  if (mutt_strncmp ("500", buf, 3))
+    serv->hasXOVER = 1;
+
+  mutt_socket_write (conn, "XPAT\r\n");
+  if (mutt_socket_readln (buf, sizeof (buf), conn) < 0)
+    return nntp_connect_error (serv);
+  if (mutt_strncmp ("500", buf, 3))
+    serv->hasXPAT = 1;
+
+  mutt_socket_write (conn, "LISTGROUP\r\n");
+  if (mutt_socket_readln (buf, sizeof (buf), conn) < 0)
+    return nntp_connect_error (serv);
+  if (mutt_strncmp ("500", buf, 3))
+    serv->hasLISTGROUP = 1;
+
+  mutt_socket_write (conn, "XGTITLE +\r\n");
+  if (mutt_socket_readln (buf, sizeof (buf), conn) < 0)
+    return nntp_connect_error (serv);
+  if (mutt_strncmp ("500", buf, 3))
+    serv->hasXGTITLE = 1;
+
+  if (!mutt_strncmp ("282", buf, 3))
+  {
+    do
+    {
+      if (mutt_socket_readln (buf, sizeof (buf), conn) < 0)
+	return nntp_connect_error (serv);
+    } while (!(buf[0] == '.' && buf[1] == '\0'));
+  }
+
+  return 0;
+}
+
+static int nntp_open_connection (NNTP_SERVER *serv)
+{
+  if (serv->status == NNTP_OK)
+    return 0;
+  if (serv->status == NNTP_BYE)
+    return -1;
+  if (nntp_connect_and_auth (serv) < 0)
+    return -1;
+  if (nntp_attempt_features (serv) < 0)
+    return -1;
+  return 0;
+}
+
+static int nntp_reconnect (NNTP_SERVER *serv)
+{
+  char buf[SHORT_STRING];
+
+  mutt_socket_close (serv->conn);
+
+  FOREVER
+  {
+    if (nntp_connect_and_auth (serv) == 0)
+      return 0;
+
+    snprintf (buf, sizeof (buf), _("Connection to %s lost. Reconnect?"),
+				serv->conn->account.host);
+    if (query_quadoption (OPT_NNTPRECONNECT, buf) != M_YES)
+    {
+      serv->status = NNTP_BYE;
+      return -1;
+    }
+  }
+}
+
+/* Send data from line[LONG_STRING] and receive answer to same line */
+static int mutt_nntp_query (NNTP_DATA *data, char *line, size_t linelen)
+{
+  char buf[LONG_STRING];
+  int done = TRUE;
+
+  if (data->nserv->status == NNTP_BYE)
+    return -1;
+
+  do
+  {
+    if (*line)
+    {
+      mutt_socket_write (data->nserv->conn, line);
+    }
+    else if (data->group)
+    {
+      snprintf (buf, sizeof (buf), "GROUP %s\r\n", data->group);
+      mutt_socket_write (data->nserv->conn, buf);
+    }
+
+    done = TRUE;
+    if (mutt_socket_readln (buf, sizeof (buf), data->nserv->conn) < 0)
+    {
+      if (nntp_reconnect (data->nserv) < 0)
+ 	return -1;
+
+      if (data->group)
+      {
+	snprintf (buf, sizeof (buf), "GROUP %s\r\n", data->group);
+	mutt_socket_write (data->nserv->conn, buf);
+	if (mutt_socket_readln (buf, sizeof (buf), data->nserv->conn) < 0)
+	  return -1;
+      }
+      if (*line)
+	done = FALSE;
+    }
+    else if ((!mutt_strncmp ("480", buf, 3)) && nntp_auth (data->nserv) < 0)
+      return -1;
+  } while (!done);
+
+  strfcpy (line, buf, linelen);
+  return 0;
+}
+
+/*
+ * This function calls  funct(*line, *data)  for each received line,
+ * funct(NULL, *data)  if  rewind(*data)  needs, exits when fail or done.
+ * Returned codes:
+ *  0 - successful,
+ *  1 - correct but not performed (may be, have to be continued),
+ * -1 - conection lost,
+ * -2 - invalid command or execution error,
+ * -3 - error in funct(*line, *data).
+ */
+static int mutt_nntp_fetch (NNTP_DATA *nntp_data, char *query, char *msg,
+		int (*funct) (char *, void *), void *data, int tagged)
+{
+  char buf[LONG_STRING];
+  char *inbuf, *p;
+  int done = FALSE;
+  int chunk, line;
+  size_t lenbuf = 0;
+  int ret;
+
+  do
+  {
+    strfcpy (buf, query, sizeof (buf));
+    if (mutt_nntp_query (nntp_data, buf, sizeof (buf)) < 0)
+      return -1;
+    if (buf[0] == '5')
+      return -2;
+    if (buf[0] != '2')
+      return 1;
+
+    ret = 0;
+    line = 0;
+    inbuf = safe_malloc (sizeof (buf));
+
+    FOREVER
+    {
+      chunk = mutt_socket_readln_d (buf, sizeof (buf), nntp_data->nserv->conn,
+				    M_SOCK_LOG_HDR);
+      if (chunk < 0)
+	break;
+
+      p = buf;
+      if (!lenbuf && buf[0] == '.')
+      {
+	if (buf[1] == '\0')
+	{
+	  done = TRUE;
+	  break;
+	}
+	if (buf[1] == '.')
+	  p++;
+      }
+
+      strfcpy (inbuf + lenbuf, p, sizeof (buf));
+
+      if (chunk >= sizeof (buf))
+      {
+	lenbuf += strlen (p);
+      }
+      else
+      {
+	line++;
+	if (msg && ReadInc && (line % ReadInc == 0)) {
+	  if (tagged)
+	    mutt_message (_("%s (tagged: %d) %d"), msg, tagged, line);
+	  else
+	    mutt_message ("%s %d", msg, line);
+	}
+
+	if (ret == 0 && funct (inbuf, data) < 0)
+	  ret = -3;
+	lenbuf = 0;
+      }
+
+      safe_realloc (&inbuf, lenbuf + sizeof (buf));
+    }
+    FREE (&inbuf);
+    funct (NULL, data);
+  }
+  while (!done);
+  return ret;
+}
+
+static int nntp_read_tempfile (char *line, void *file)
+{
+  FILE *f = (FILE *)file;
+
+  if (!line)
+    rewind (f);
+  else
+  {
+    fputs (line, f);
+    if (fputc ('\n', f) == EOF)
+      return -1;
+  }
+  return 0;
+}
+
+static void nntp_parse_xref (CONTEXT *ctx, char *group, char *xref, HEADER *h)
+{
+  register char *p, *b;
+  register char *colon = NULL;
+
+  b = p = xref;
+  while (*p)
+  {
+    /* skip to next word */
+    b = p;
+    while (*b && ((*b == ' ') || (*b == '\t'))) b++;
+    p = b;
+    colon = NULL;
+    /* skip to end of word */
+    while (*p && (*p != ' ') && (*p != '\t')) 
+    {
+      if (*p == ':')
+	colon = p;
+      p++;
+    }
+    if (*p)
+    {
+      *p = '\0';
+      p++;
+    }
+    if (colon)
+    {
+      *colon = '\0';
+      colon++;
+      nntp_get_status (ctx, h, b, atoi(colon));
+      if (h && h->article_num == 0 && mutt_strcmp (group, b) == 0)
+	h->article_num = atoi(colon);
+    }
+  }
+}
+
+/*
+ * returns:
+ *  0 on success
+ *  1 if article not found
+ * -1 if read or write error on tempfile or socket
+ */
+static int nntp_read_header (CONTEXT *ctx, const char *msgid, int article_num)
+{
+  NNTP_DATA *nntp_data = ((NNTP_DATA *)ctx->data);
+  FILE *f;
+  char buf[LONG_STRING];
+  char tempfile[_POSIX_PATH_MAX];
+  int ret;
+  HEADER *h = ctx->hdrs[ctx->msgcount];
+
+  mutt_mktemp (tempfile, sizeof(tempfile));
+  if (!(f = safe_fopen (tempfile, "w+")))
+    return -1;
+
+  if (!msgid)
+    snprintf (buf, sizeof (buf), "HEAD %d\r\n", article_num);
+  else
+    snprintf (buf, sizeof (buf), "HEAD %s\r\n", msgid);
+
+  ret = mutt_nntp_fetch (nntp_data, buf, NULL, nntp_read_tempfile, f, 0);
+  if (ret)
+  {
+#ifdef DEBUG
+    if (ret != -1)
+      dprint(1, (debugfile, "nntp_read_header: %s\n", buf));
+#endif
+    fclose (f);
+    unlink (tempfile);
+    return (ret == -1 ? -1 : 1);
+  }
+
+  h->article_num = article_num;
+  h->env = mutt_read_rfc822_header (f, h, 0, 0);
+  fclose (f);
+  unlink (tempfile);
+
+  if (h->env->xref != NULL)
+    nntp_parse_xref (ctx, nntp_data->group, h->env->xref, h);
+  else if (h->article_num == 0 && msgid)
+  {
+    snprintf (buf, sizeof (buf), "STAT %s\r\n", msgid);
+    if (mutt_nntp_query (nntp_data, buf, sizeof (buf)) == 0)
+      h->article_num = atoi (buf + 4);
+  }
+
+  return 0;
+}
+
+static int parse_description (char *line, void *n)
+{
+#define news ((NNTP_SERVER *) n)
+  register char *d = line;
+  NNTP_DATA *data;
+
+  if (!line)
+    return 0;
+  while (*d && *d != '\t' && *d != ' ') d++;
+    *d = 0;
+  d++;
+  while (*d && (*d == '\t' || *d == ' ')) d++;
+  dprint (2, (debugfile, "group: %s, desc: %s\n", line, d));
+  if ((data = (NNTP_DATA *) hash_find (news->newsgroups, line)) != NULL &&
+	mutt_strcmp (d, data->desc))
+  {
+    FREE (&data->desc);
+    data->desc = safe_strdup (d);
+  }
+  return 0;
+#undef news
+}
+
+static void nntp_get_desc (NNTP_DATA *data, char *mask, char *msg)
+{
+  char buf[STRING];
+
+  if (!option (OPTLOADDESC) || !data || !data->nserv)
+    return;
+
+  /* Get newsgroup description, if we can */
+  if (data->nserv->hasXGTITLE)
+    snprintf (buf, sizeof (buf), "XGTITLE %s\r\n", mask);
+  else
+    snprintf (buf, sizeof (buf), "LIST NEWSGROUPS %s\r\n", mask);
+  if (mutt_nntp_fetch (data, buf, msg, parse_description, data->nserv, 0) != 0)
+  {
+#ifdef DEBUG
+    nntp_error ("nntp_get_desc()", buf);
+#endif
+  }
+}
+
+/*
+ * XOVER returns a tab separated list of:
+ * id|subject|from|date|Msgid|references|bytes|lines|xref
+ *
+ * This has to duplicate some of the functionality of 
+ * mutt_read_rfc822_header(), since it replaces the call to that (albeit with
+ * a limited number of headers which are "parsed" by placement in the list)
+ */
+static int nntp_parse_xover (CONTEXT *ctx, char *buf, HEADER *hdr)
+{
+  NNTP_DATA *nntp_data = (NNTP_DATA *) ctx->data;
+  char *p, *b;
+  int x, done = 0;
+
+  hdr->env = mutt_new_envelope();
+  hdr->env->newsgroups = safe_strdup (nntp_data->group);
+  hdr->content = mutt_new_body();
+  hdr->content->type = TYPETEXT;
+  hdr->content->subtype = safe_strdup ("plain");
+  hdr->content->encoding = ENC7BIT;
+  hdr->content->disposition = DISPINLINE;
+  hdr->content->length = -1;
+  b = p = buf;
+
+  for (x = 0; !done && x < 9; x++)
+  {
+    /* if from file, need to skip newline character */
+    while (*p && *p != '\n' && *p != '\t') p++;
+    if (!*p) done++;
+    *p = '\0';
+    p++;
+    switch (x)
+    {
+      case 0:
+
+	hdr->article_num = atoi (b);
+	nntp_get_status (ctx, hdr, NULL, hdr->article_num);
+	break;
+      case 1:
+	hdr->env->subject = safe_strdup (b);
+	/* Now we need to do the things which would normally be done in 
+	 * mutt_read_rfc822_header() */
+	if (hdr->env->subject)
+	{
+	  regmatch_t pmatch[1];
+
+	  rfc2047_decode (&hdr->env->subject);
+
+	  if (regexec (ReplyRegexp.rx, hdr->env->subject, 1, pmatch, 0) == 0)
+	    hdr->env->real_subj = hdr->env->subject + pmatch[0].rm_eo;
+	  else
+	    hdr->env->real_subj = hdr->env->subject;
+	}
+	break;
+      case 2:
+	rfc822_free_address (&hdr->env->from);
+	hdr->env->from = rfc822_parse_adrlist (hdr->env->from, b);
+	rfc2047_decode_adrlist (hdr->env->from);
+	break;
+      case 3:
+	hdr->date_sent = mutt_parse_date (b, hdr);
+	hdr->received = hdr->date_sent;
+	break;
+      case 4:
+	FREE (&hdr->env->message_id);
+	hdr->env->message_id = safe_strdup (b);
+	break;
+      case 5:
+	mutt_free_list (&hdr->env->references);
+	hdr->env->references = mutt_parse_references (b, 0);
+	break;
+      case 6:
+	hdr->content->length = atoi (b);
+	break;
+      case 7:
+	hdr->lines = atoi (b);
+	break;
+      case 8:
+	if (!hdr->read)
+	  FREE (&hdr->env->xref);
+	  b = b + 6;	/* skips the "Xref: " */
+	  hdr->env->xref = safe_strdup (b);
+	  nntp_parse_xref (ctx, nntp_data->group, b, hdr);
+    }
+    if (!*p)
+      return -1;
+    b = p;
+  }
+  return 0;
+}
+
+typedef struct
+{
+  CONTEXT *ctx;
+  unsigned int base;
+  unsigned int first;
+  unsigned int last;
+  unsigned short *messages;
+  char* msg;
+} FETCH_CONTEXT;
+
+#define fc ((FETCH_CONTEXT *) c)
+static int nntp_fetch_numbers (char *line, void *c)
+{
+  unsigned int num;
+
+  if (!line)
+    return 0;
+  num = atoi (line);
+  if (num < fc->base || num > fc->last)
+    return 0;
+  fc->messages[num - fc->base] = 1;
+  return 0;
+}
+
+static int add_xover_line (char *line, void *c)
+{
+  unsigned int num, total;
+  CONTEXT *ctx = fc->ctx;
+  NNTP_DATA *data = (NNTP_DATA *)ctx->data;
+
+  if (!line)
+    return 0;
+
+  if (ctx->msgcount >= ctx->hdrmax)
+    mx_alloc_memory (ctx);
+  ctx->hdrs[ctx->msgcount] = mutt_new_header ();
+  ctx->hdrs[ctx->msgcount]->index = ctx->msgcount;
+
+  nntp_parse_xover (ctx, line, ctx->hdrs[ctx->msgcount]);
+  num = ctx->hdrs[ctx->msgcount]->article_num;
+
+  if (num >= fc->first && num <= fc->last && fc->messages[num - fc->base])
+  {
+    ctx->msgcount++;
+    if (num > data->lastLoaded)
+      data->lastLoaded = num;
+    num = num - fc->first + 1;
+    total = fc->last - fc->first + 1;
+    if (!ctx->quiet && fc->msg && ReadInc && (num % ReadInc == 0))
+      mutt_message ("%s %d/%d", fc->msg, num, total);
+  }
+  else
+    mutt_free_header (&ctx->hdrs[ctx->msgcount]); /* skip it */
+
+  return 0;
+}
+#undef fc
+
+static int nntp_fetch_headers (CONTEXT *ctx, unsigned int first,
+	unsigned int last)
+{
+  char buf[HUGE_STRING];
+  char *msg = _("Fetching message headers...");
+  NNTP_DATA *nntp_data = ((NNTP_DATA *)ctx->data);
+  int ret;
+  int num;
+  int oldmsgcount;
+  unsigned int current;
+  FILE *f;
+  FETCH_CONTEXT fc;
+
+  /* if empty group or nothing to do */
+  if (!last || first > last)
+    return 0;
+
+  /* fetch list of articles */
+  fc.ctx = ctx;
+  fc.base = first;
+  fc.last = last;
+  fc.messages = safe_calloc (last - first + 1, sizeof (unsigned short));
+  if (nntp_data->nserv->hasLISTGROUP)
+  {
+    mutt_message _("Fetching list of articles...");
+    snprintf (buf, sizeof (buf), "LISTGROUP %s\r\n", nntp_data->group);
+    if (mutt_nntp_fetch (nntp_data, buf, NULL, nntp_fetch_numbers, &fc, 0) != 0)
+    {
+      mutt_error (_("LISTGROUP command failed: %s"), buf);
+#ifdef DEBUG
+      nntp_error ("nntp_fetch_headers()", buf);
+#endif
+      FREE (&fc.messages);
+      return -1;
+    }
+  }
+  else
+  {
+    for (num = 0; num < last - first + 1; num++)
+      fc.messages[num] = 1;
+  }
+
+  /* CACHE: must be loaded xover cache here */
+  num = nntp_data->lastCached - first + 1;
+  if (option (OPTNEWSCACHE) && nntp_data->cache && num > 0)
+  {
+    nntp_cache_expand (buf, nntp_data->cache);
+    mutt_message _("Fetching headers from cache...");
+    if ((f = safe_fopen (buf, "r")))
+    {
+      int r = 0;
+
+      /* counting number of lines */
+      while (fgets (buf, sizeof (buf), f) != NULL)
+	r++;
+      rewind (f);
+      while (r > num && fgets (buf, sizeof (buf), f) != NULL)
+	r--;
+      oldmsgcount = ctx->msgcount;
+      fc.first = first;
+      fc.last = first + num - 1;
+      fc.msg = NULL;
+      while (fgets (buf, sizeof (buf), f) != NULL)
+	add_xover_line (buf, &fc);
+      fclose (f);
+      nntp_data->lastLoaded = fc.last;
+      first = fc.last + 1;
+      if (ctx->msgcount > oldmsgcount)
+	mx_update_context (ctx, ctx->msgcount - oldmsgcount);
+    }
+    else
+      nntp_delete_cache (nntp_data);
+  }
+  num = last - first + 1;
+  if (num <= 0)
+  {
+    FREE (&fc.messages);
+    return 0;
+  }
+
+  /*
+   * Without XOVER, we have to fetch each article header and parse
+   * it.  With XOVER, we ask for all of them
+   */
+  mutt_message (msg);
+  if (nntp_data->nserv->hasXOVER)
+  {
+    oldmsgcount = ctx->msgcount;
+    fc.first = first;
+    fc.last = last;
+    fc.msg = msg;
+    snprintf (buf, sizeof (buf), "XOVER %d-%d\r\n", first, last);
+    ret = mutt_nntp_fetch (nntp_data, buf, NULL, add_xover_line, &fc, 0);
+    if (ctx->msgcount > oldmsgcount)
+      mx_update_context (ctx, ctx->msgcount - oldmsgcount);
+    if (ret != 0)
+    {
+      mutt_error (_("XOVER command failed: %s"), buf);
+#ifdef DEBUG
+      nntp_error ("nntp_fetch_headers()", buf);
+#endif
+      FREE (&fc.messages);
+      return -1;
+    }
+    /* fetched OK */
+  }
+  else
+  for (current = first; current <= last; current++)
+  {
+    HEADER *h;
+
+    ret = current - first + 1;
+    mutt_message ("%s %d/%d", msg, ret, num);
+
+    if (!fc.messages[current - fc.base])
+      continue;
+
+    if (ctx->msgcount >= ctx->hdrmax)
+      mx_alloc_memory (ctx);
+    h = ctx->hdrs[ctx->msgcount] = mutt_new_header ();
+    h->index = ctx->msgcount;
+
+    ret = nntp_read_header (ctx, NULL, current);
+    if (ret == 0) /* Got article. Fetch next header */
+    {
+      nntp_get_status (ctx, h, NULL, h->article_num);
+      ctx->msgcount++;
+      mx_update_context (ctx, 1);
+    }
+    else
+      mutt_free_header (&h); /* skip it */
+    if (ret == -1)
+    {
+      FREE (&fc.messages);
+      return -1;
+    }
+
+    if (current > nntp_data->lastLoaded)
+      nntp_data->lastLoaded = current;
+  }
+  FREE (&fc.messages);
+  nntp_data->lastLoaded = last;
+  mutt_clear_error ();
+  return 0;
+}
+
+/* 
+ * currently, nntp "mailbox" is "newsgroup"
+ */
+int nntp_open_mailbox (CONTEXT *ctx)
+{
+  NNTP_DATA *nntp_data;
+  NNTP_SERVER *serv;
+  char buf[HUGE_STRING];
+  char server[LONG_STRING];
+  int count = 0;
+  unsigned int first;
+  ACCOUNT acct;
+
+  if (nntp_parse_url (ctx->path, &acct, buf, sizeof (buf)) < 0 || !*buf)
+  {
+    mutt_error (_("%s is an invalid newsgroup specification!"), ctx->path);
+    mutt_sleep (2);
+    return -1;
+  }
+
+  server[0] = '\0';
+  nntp_expand_path (server, sizeof (server), &acct);
+  if (!(serv = mutt_select_newsserver (server)) || serv->status != NNTP_OK)
+    return -1;
+
+  CurrentNewsSrv = serv;
+
+  /* create NNTP-specific state struct if nof found in list */
+  if ((nntp_data = (NNTP_DATA *) hash_find (serv->newsgroups, buf)) == NULL)
+  {
+    nntp_data = safe_calloc (1, sizeof (NNTP_DATA) + strlen (buf) + 1);
+    nntp_data->group = (char *) nntp_data + sizeof (NNTP_DATA);
+    strcpy (nntp_data->group, buf);
+    hash_insert (serv->newsgroups, nntp_data->group, nntp_data, 0);
+    nntp_add_to_list (serv, nntp_data);
+  }
+  ctx->data = nntp_data;
+  ctx->mx_close = nntp_fastclose_mailbox;
+  nntp_data->nserv = serv;
+
+  mutt_message (_("Selecting %s..."), nntp_data->group);
+
+  if (!nntp_data->desc)
+  {
+    nntp_get_desc (nntp_data, nntp_data->group, NULL);
+    if (nntp_data->desc)
+      nntp_save_cache_index (serv);
+  }
+
+  buf[0] = 0;
+  if (mutt_nntp_query (nntp_data, buf, sizeof(buf)) < 0)
+  {
+#ifdef DEBUG
+    nntp_error ("nntp_open_mailbox()", buf);
+#endif
+    return -1;
+  }
+
+  if (mutt_strncmp ("211", buf, 3))
+  {
+    LIST *l = serv->list;
+
+    /* GROUP command failed */
+    if (!mutt_strncmp ("411", buf, 3))
+    {
+      mutt_error (_("Newsgroup %s not found on server %s"),
+		    nntp_data->group, serv->conn->account.host);
+
+      /* CACHE: delete cache and line from .index */
+      nntp_delete_cache (nntp_data);
+      hash_delete (serv->newsgroups, nntp_data->group, NULL, nntp_delete_data);
+      while (l && l->data != (void *) nntp_data) l = l->next;
+      if (l)
+	l->data = NULL;
+
+      sleep (2);
+    }
+
+    return -1;
+  }
+
+  sscanf (buf + 4, "%d %u %u %s", &count, &nntp_data->firstMessage, 
+	  &nntp_data->lastMessage, buf);
+
+  nntp_data->deleted = 0;
+
+  time (&serv->check_time);
+
+  /*
+   * Check for max adding context. If it is greater than $nntp_context,
+   * strip off extra articles
+   */
+  first = nntp_data->firstMessage;
+  if (NntpContext && nntp_data->lastMessage - first + 1 > NntpContext)
+    first = nntp_data->lastMessage - NntpContext + 1;
+  if (first)
+    nntp_data->lastLoaded = first - 1;
+  return nntp_fetch_headers (ctx, first, nntp_data->lastMessage);
+}
+
+int nntp_fetch_message (MESSAGE *msg, CONTEXT *ctx, int msgno)
+{
+  char buf[LONG_STRING];
+  char path[_POSIX_PATH_MAX];
+  NNTP_CACHE *cache;
+  char *m = _("Fetching message...");
+  int ret;
+
+  /* see if we already have the message in our cache */
+  cache = &((NNTP_DATA *) ctx->data)->acache[ctx->hdrs[msgno]->index % NNTP_CACHE_LEN];
+
+  /* if everything is fine, assign msg->fp and return */
+  if (cache->path && cache->index == ctx->hdrs[msgno]->index &&
+      (msg->fp = fopen (cache->path, "r")))
+    return 0;
+
+  /* clear the previous entry */
+  unlink (cache->path);
+  free (cache->path);
+
+  mutt_message (m);
+
+  cache->index = ctx->hdrs[msgno]->index;
+  mutt_mktemp (path, sizeof(path));
+  cache->path = safe_strdup (path);
+  if (!(msg->fp = safe_fopen (path, "w+")))
+  {
+    FREE (&cache->path);
+    return -1;
+  }
+
+  if (ctx->hdrs[msgno]->article_num == 0)
+    snprintf (buf, sizeof (buf), "ARTICLE %s\r\n",
+	  ctx->hdrs[msgno]->env->message_id);
+  else
+    snprintf (buf, sizeof (buf), "ARTICLE %d\r\n",
+	  ctx->hdrs[msgno]->article_num);
+
+  ret = mutt_nntp_fetch ((NNTP_DATA *)ctx->data, buf, m, nntp_read_tempfile,
+	msg->fp, ctx->tagged);
+  if (ret == 1)
+  {
+    mutt_error (_("Article %d not found on server"), 
+	  ctx->hdrs[msgno]->article_num);
+    dprint (1, (debugfile, "nntp_fetch_message: %s\n", buf));
+  }
+
+  if (ret)
+  {
+    fclose (msg->fp);
+    unlink (path);
+    FREE (&cache->path);
+    return -1;
+  }
+
+  mutt_free_envelope (&ctx->hdrs[msgno]->env);
+  ctx->hdrs[msgno]->env = mutt_read_rfc822_header (msg->fp, ctx->hdrs[msgno], 0, 0);
+  /* fix content length */
+  fseek(msg->fp, 0, SEEK_END);
+  ctx->hdrs[msgno]->content->length = ftell (msg->fp) - 
+                                        ctx->hdrs[msgno]->content->offset;
+
+  /* this is called in mutt before the open which fetches the message, 
+   * which is probably wrong, but we just call it again here to handle
+   * the problem instead of fixing it.
+   */
+  mutt_parse_mime_message (ctx, ctx->hdrs[msgno]);
+
+  /* These would normally be updated in mx_update_context(), but the 
+   * full headers aren't parsed with XOVER, so the information wasn't
+   * available then.
+   */
+#if defined(HAVE_PGP) || defined(HAVE_SMIME)
+  ctx->hdrs[msgno]->security = crypt_query (ctx->hdrs[msgno]->content);
+#endif /* HAVE_PGP || HAVE_SMIME */
+
+  mutt_clear_error();
+  rewind (msg->fp);
+
+  return 0;
+}
+
+/* Post article */
+int nntp_post (const char *msg) {
+  char buf[LONG_STRING];
+  size_t len;
+  FILE *f;
+  NNTP_DATA *nntp_data;
+
+  if (Context && Context->magic == M_NNTP)
+    nntp_data = (NNTP_DATA *)Context->data;
+  else
+  {
+    if (!(CurrentNewsSrv = mutt_select_newsserver (NewsServer)) ||
+	!CurrentNewsSrv->list || !CurrentNewsSrv->list->data)
+    {
+      mutt_error (_("Can't post article. No connection to news server."));
+      return -1;
+    }
+    nntp_data = (NNTP_DATA *)CurrentNewsSrv->list->data;
+  }
+
+  if (!(f = safe_fopen (msg, "r")))
+  {
+    mutt_error (_("Can't post article. Unable to open %s"), msg);
+    return -1;
+  }
+
+  strfcpy (buf, "POST\r\n", sizeof (buf));
+  if (mutt_nntp_query (nntp_data, buf, sizeof (buf)) < 0)
+  {
+    mutt_error (_("Can't post article. Connection to %s lost."),
+		nntp_data->nserv->conn->account.host);
+    return -1;
+  }
+  if (buf[0] != '3')
+  {
+    mutt_error (_("Can't post article: %s"), buf);
+    return -1;
+  }
+
+  buf[0] = '.';
+  buf[1] = '\0';
+  while (fgets (buf + 1, sizeof (buf) - 2, f) != NULL)
+  {
+    len = strlen (buf);
+    if (buf[len - 1] == '\n')
+    {
+      buf[len - 1] = '\r';
+      buf[len] = '\n';
+      len++;
+      buf[len] = '\0';
+    }
+    if (buf[1] == '.')
+      mutt_socket_write_d (nntp_data->nserv->conn, buf, -1, M_SOCK_LOG_HDR);
+    else
+      mutt_socket_write_d (nntp_data->nserv->conn, buf + 1, -1, M_SOCK_LOG_HDR);
+  }
+  fclose (f);
+
+  if (buf[strlen (buf) - 1] != '\n')
+    mutt_socket_write_d (nntp_data->nserv->conn, "\r\n", -1, M_SOCK_LOG_HDR);
+  mutt_socket_write_d (nntp_data->nserv->conn, ".\r\n", -1, M_SOCK_LOG_HDR);
+  if (mutt_socket_readln (buf, sizeof (buf), nntp_data->nserv->conn) < 0)
+  {
+    mutt_error (_("Can't post article. Connection to %s lost."),
+		nntp_data->nserv->conn->account.host);
+    return -1;
+  }
+  if (buf[0] != '2')
+  {
+    mutt_error (_("Can't post article: %s"), buf);
+    return -1;
+  }
+
+  return 0;
+}
+
+/* nntp_logout_all: close all open connections. */
+void nntp_logout_all (void)
+{
+  char buf[LONG_STRING];
+  CONNECTION* conn;
+
+  conn = mutt_socket_head ();
+
+  while (conn)
+  {
+    CONNECTION *next = conn->next;
+
+    if (conn->account.type == M_ACCT_TYPE_NNTP)
+    {
+      mutt_message (_("Closing connection to %s..."), conn->account.host);
+      mutt_socket_write (conn, "QUIT\r\n");
+      mutt_socket_readln (buf, sizeof (buf), conn);
+      mutt_clear_error ();
+      mutt_socket_close (conn);
+      mutt_socket_free (conn);
+    }
+
+    conn = next;
+  }
+}
+
+static void nntp_free_acache (NNTP_DATA *data)
+{
+  int i;
+
+  for (i = 0; i < NNTP_CACHE_LEN; i++)
+  {
+    if (data->acache[i].path)
+    {
+      unlink (data->acache[i].path);
+      FREE (&data->acache[i].path);
+    }
+  }
+}
+
+void nntp_delete_data (void *p)
+{
+  NNTP_DATA *data = (NNTP_DATA *)p;
+
+  if (!p)
+    return;
+  FREE (&data->entries);
+  FREE (&data->desc);
+  FREE (&data->cache);
+  nntp_free_acache (data);
+  FREE (p);
+}
+
+int nntp_sync_mailbox (CONTEXT *ctx)
+{
+  NNTP_DATA *data = ctx->data;
+
+  /* CACHE: update cache and .index files */
+  if ((option (OPTSAVEUNSUB) || data->subscribed))
+    nntp_save_cache_group (ctx);
+  nntp_free_acache (data);
+
+  data->nserv->check_time = 0; /* next nntp_check_mailbox() will really check */
+  return 0;
+}
+
+int nntp_fastclose_mailbox (CONTEXT *ctx)
+{
+  NNTP_DATA *data = (NNTP_DATA *) ctx->data, *tmp;
+
+  if (!data)
+    return 0;
+  nntp_free_acache (data);
+  if (!data->nserv || !data->nserv->newsgroups || !data->group)
+    return 0;
+  nntp_save_cache_index (data->nserv);
+  if ((tmp = hash_find (data->nserv->newsgroups, data->group)) == NULL
+	|| tmp != data)
+    nntp_delete_data (data);
+  return 0;
+}
+
+/* commit changes and terminate connection */
+int nntp_close_mailbox (CONTEXT *ctx)
+{
+  if (!ctx)
+    return -1;
+  mutt_message _("Quitting newsgroup...");
+  if (ctx->data)
+  {
+    NNTP_DATA *data = (NNTP_DATA *) ctx->data;
+    int ret;
+
+    if (data->nserv && data->nserv->conn && ctx->unread)
+    {
+      ret = query_quadoption (OPT_CATCHUP, _("Mark all articles read?"));
+      if (ret == M_YES)
+	mutt_newsgroup_catchup (data->nserv, data->group);
+      else if (ret < 0)
+	return -1;
+    }
+  }
+  nntp_sync_mailbox (ctx);
+  if (ctx->data && ((NNTP_DATA *)ctx->data)->nserv)
+  {
+    NNTP_SERVER *news;
+
+    news = ((NNTP_DATA *)ctx->data)->nserv;
+    newsrc_gen_entries (ctx);
+    ((NNTP_DATA *)ctx->data)->unread = ctx->unread;
+    mutt_newsrc_update (news);
+  }
+  mutt_clear_error();
+  return 0;
+}
+
+/* use the GROUP command to poll for new mail */
+static int _nntp_check_mailbox (CONTEXT *ctx, NNTP_DATA *nntp_data)
+{
+  char buf[LONG_STRING];
+  int count = 0;
+
+  if (nntp_data->nserv->check_time + NewsPollTimeout > time (NULL))
+    return 0;
+
+  buf[0] = 0;
+  if (mutt_nntp_query (nntp_data, buf, sizeof (buf)) < 0)
+  {
+#ifdef DEBUG
+    nntp_error ("nntp_check_mailbox()", buf);
+#endif
+    return -1;
+  }
+  if (mutt_strncmp ("211", buf, 3))
+  {
+    buf[0] = 0;
+    if (mutt_nntp_query (nntp_data, buf, sizeof (buf)) < 0)
+    {
+#ifdef DEBUG
+      nntp_error ("nntp_check_mailbox()", buf);
+#endif
+      return -1;
+    }
+  }
+  if (!mutt_strncmp ("211", buf, 3))
+  {
+    int first;
+    int last;
+
+    sscanf (buf + 4, "%d %d %d", &count, &first, &last);
+    nntp_data->firstMessage = first;
+    nntp_data->lastMessage = last;
+    if (ctx && last > nntp_data->lastLoaded)
+    {
+      nntp_fetch_headers (ctx, nntp_data->lastLoaded + 1, last);
+      time (&nntp_data->nserv->check_time);
+      return 1;
+    }
+    if (!last || (!nntp_data->rc && !nntp_data->lastCached))
+      nntp_data->unread = count;
+    else
+      mutt_newsgroup_stat (nntp_data);
+    /* active was renumbered? */
+    if (last < nntp_data->lastLoaded)
+    {
+      if (!nntp_data->max)
+      {
+	nntp_data->entries = safe_calloc (5, sizeof (NEWSRC_ENTRY));
+	nntp_data->max = 5;
+      }
+      nntp_data->lastCached = 0;
+      nntp_data->num = 1;
+      nntp_data->entries[0].first = 1;
+      nntp_data->entries[0].last = 0;
+    }
+  }
+
+  time (&nntp_data->nserv->check_time);
+  return 0;
+}
+
+int nntp_check_mailbox (CONTEXT *ctx)
+{
+  return _nntp_check_mailbox (ctx, (NNTP_DATA *)ctx->data);
+}
+
+static int add_group (char *buf, void *serv)
+{
+#define s ((NNTP_SERVER *) serv)
+  char group[LONG_STRING], mod, desc[HUGE_STRING];
+  int first, last;
+  NNTP_DATA *nntp_data;
+  static int n = 0;
+
+  _checked = n;	/* _checked have N, where N = number of groups */
+  if (!buf)	/* at EOF must be zerouth */
+    n = 0;
+
+  if (!s || !buf)
+    return 0;
+
+  *desc = 0;
+  sscanf (buf, "%s %d %d %c %[^\n]", group, &last, &first, &mod, desc);
+  if (!group)
+    return 0;
+  if ((nntp_data = (NNTP_DATA *) hash_find (s->newsgroups, group)) == NULL)
+  {
+    n++;
+    nntp_data = safe_calloc (1, sizeof (NNTP_DATA) + strlen (group) + 1);
+    nntp_data->group = (char *) nntp_data + sizeof (NNTP_DATA);
+    strcpy (nntp_data->group, group);
+    nntp_data->nserv = s;
+    if (s->newsgroups->nelem < s->newsgroups->curnelem * 2)
+      s->newsgroups = hash_resize (s->newsgroups, s->newsgroups->nelem * 2, 0);
+    hash_insert (s->newsgroups, nntp_data->group, nntp_data, 0);
+    nntp_add_to_list (s, nntp_data);
+  }
+  nntp_data->deleted = 0;
+  nntp_data->firstMessage = first;
+  nntp_data->lastMessage = last;
+  if (mod == 'y')
+    nntp_data->allowed = 1;
+  else
+    nntp_data->allowed = 0;
+  if (nntp_data->desc)
+    FREE (&nntp_data->desc);
+  if (*desc)
+    nntp_data->desc = safe_strdup (desc);
+  if (nntp_data->rc || nntp_data->lastCached)
+    mutt_newsgroup_stat (nntp_data);
+  else if (nntp_data->lastMessage &&
+	nntp_data->firstMessage <= nntp_data->lastMessage)
+    nntp_data->unread = nntp_data->lastMessage - nntp_data->firstMessage + 1;
+  else
+    nntp_data->unread = 0;
+
+  return 0;
+#undef s
+}
+
+int nntp_check_newgroups (NNTP_SERVER *serv, int force)
+{
+  char buf[LONG_STRING];
+  char msg[SHORT_STRING];
+  NNTP_DATA nntp_data;
+  LIST *l;
+  LIST emp;
+  time_t now;
+  struct tm *t;
+  unsigned int count = 0;
+  unsigned int total = 0;
+
+  if (!serv || !serv->newgroups_time)
+    return -1;
+
+  if (nntp_open_connection (serv) < 0)
+    return -1;
+
+  /* check subscribed groups for new news */
+  if (option (OPTSHOWNEWNEWS))
+  {
+    mutt_message _("Checking for new messages...");
+    for (l = serv->list; l; l = l->next)
+    {
+      serv->check_time = 0;	/* really check! */
+      if (l->data && ((NNTP_DATA *) l->data)->subscribed)
+	_nntp_check_mailbox (NULL, (NNTP_DATA *) l->data);
+    }
+  }
+  else if (!force)
+    return 0;
+
+  mutt_message _("Checking for new newsgroups...");
+  now = serv->newgroups_time;
+  time (&serv->newgroups_time);
+  t = gmtime (&now);
+  snprintf (buf, sizeof (buf), "NEWGROUPS %02d%02d%02d %02d%02d%02d GMT\r\n",
+	(t->tm_year % 100), t->tm_mon + 1, t->tm_mday, t->tm_hour, t->tm_min,
+	t->tm_sec);
+  nntp_data.nserv = serv;
+  if (Context && Context->magic == M_NNTP)
+    nntp_data.group = ((NNTP_DATA *)Context->data)->group;
+  else
+    nntp_data.group = NULL;
+  l = serv->tail;
+  if (mutt_nntp_fetch (&nntp_data, buf, _("Adding new newsgroups..."),
+	add_group, serv, 0) != 0)
+  {
+#ifdef DEBUG
+    nntp_error ("nntp_check_newgroups()", buf);
+#endif
+    return -1;
+  }
+
+  strfcpy (msg, _("Loading descriptions..."), sizeof (msg));
+  mutt_message (msg);
+  if (l)
+    emp.next = l->next;
+  else
+    emp.next = serv->list;
+  l = &emp;
+  while (l->next)
+  {
+    l = l->next;
+    ((NNTP_DATA *) l->data)->new = 1;
+    total++;
+  }
+  l = &emp;
+  while (l->next)
+  {
+    l = l->next;
+    nntp_get_desc ((NNTP_DATA *) l->data, ((NNTP_DATA *) l->data)->group, NULL);
+    count++;
+    if (ReadInc && (count % ReadInc == 0))
+      mutt_message ("%s %d/%d", msg, count, total);
+  }
+  if (emp.next)
+    nntp_save_cache_index (serv);
+  mutt_clear_error ();
+  return _checked;
+}
+
+/* Load list of all newsgroups from cache ALL */
+int nntp_get_cache_all (NNTP_SERVER *serv)
+{
+  char buf[HUGE_STRING];
+  FILE *f;
+
+  nntp_cache_expand (buf, serv->cache);
+  if ((f = safe_fopen (buf, "r")))
+  {
+    int i = 0;
+
+    while (fgets (buf, sizeof(buf), f) != NULL)
+    {
+      if (ReadInc && (i % ReadInc == 0))
+	mutt_message (_("Loading list from cache... %d"), i);
+      add_group (buf, serv);
+      i++;
+    }
+    add_group (NULL, NULL);
+    fclose (f);
+    mutt_clear_error ();
+    return 0;
+  }
+  else
+  {
+    FREE (&serv->cache);
+    return -1;
+  }
+}
+
+/* Load list of all newsgroups from active */
+int nntp_get_active (NNTP_SERVER *serv)
+{
+  char msg[SHORT_STRING];
+  NNTP_DATA nntp_data;
+  LIST *tmp;
+
+  if (nntp_open_connection (serv) < 0)
+    return -1;
+
+  snprintf (msg, sizeof(msg), _("Loading list of all newsgroups on server %s..."),
+		serv->conn->account.host);
+  mutt_message (msg);
+  time (&serv->newgroups_time);
+  nntp_data.nserv = serv;
+  nntp_data.group = NULL;
+
+  if (mutt_nntp_fetch (&nntp_data, "LIST\r\n", msg, add_group, serv, 0) < 0)
+  {
+#ifdef DEBUG
+    nntp_error ("nntp_get_active()", "LIST\r\n");
+#endif
+    return -1;
+  }
+
+  strfcpy (msg, _("Loading descriptions..."), sizeof (msg));
+  mutt_message (msg);
+  nntp_get_desc (&nntp_data, "*", msg);
+
+  for (tmp = serv->list; tmp; tmp = tmp->next)
+  {
+    NNTP_DATA *data = (NNTP_DATA *)tmp->data;
+
+    if (data && data->deleted && !data->rc)
+    {
+      nntp_delete_cache (data);
+      hash_delete (serv->newsgroups, data->group, NULL, nntp_delete_data);
+      tmp->data = NULL;
+    }
+  }
+  nntp_save_cache_index (serv);
+
+  mutt_clear_error ();
+  return _checked;
+}
+
+/*
+ * returns -1 if error ocurred while retrieving header,
+ * number of articles which ones exist in context on success.
+ */
+int nntp_check_msgid (CONTEXT *ctx, const char *msgid)
+{
+  int ret;
+
+  /* if msgid is already in context, don't reload them */
+  if (hash_find (ctx->id_hash, msgid))
+    return 1;
+  if (ctx->msgcount == ctx->hdrmax)
+    mx_alloc_memory (ctx);
+  ctx->hdrs[ctx->msgcount] = mutt_new_header ();
+  ctx->hdrs[ctx->msgcount]->index = ctx->msgcount;
+  
+  mutt_message (_("Fetching %s from server..."), msgid);
+  ret = nntp_read_header (ctx, msgid, 0);
+  /* since nntp_read_header() may set read flag, we must reset it */
+  ctx->hdrs[ctx->msgcount]->read = 0;
+  if (ret != 0)
+    mutt_free_header (&ctx->hdrs[ctx->msgcount]);
+  else
+  {
+    ctx->msgcount++;
+    mx_update_context (ctx, 1);
+    ctx->changed = 1;
+  }
+  return ret;
+}
+
+typedef struct
+{
+  CONTEXT *ctx;
+  unsigned int num;
+  unsigned int max;
+  unsigned int *child;
+} CHILD_CONTEXT;
+
+static int check_children (char *s, void *c)
+{
+#define cc ((CHILD_CONTEXT *) c)
+  unsigned int i, n;
+
+  if (!s || (n = atoi (s)) == 0)
+    return 0;
+  for (i = 0; i < cc->ctx->msgcount; i++)
+    if (cc->ctx->hdrs[i]->article_num == n)
+      return 0;
+  if (cc->num >= cc->max)
+    safe_realloc (&cc->child, sizeof (unsigned int) * (cc->max += 25));
+  cc->child[cc->num++] = n;
+
+  return 0;
+#undef cc
+}
+
+int nntp_check_children (CONTEXT *ctx, const char *msgid)
+{
+  NNTP_DATA *nntp_data = (NNTP_DATA *)ctx->data;
+  char buf[STRING];
+  int i, ret = 0, tmp = 0;
+  CHILD_CONTEXT cc;
+
+  if (!nntp_data || !nntp_data->nserv || !nntp_data->nserv->conn ||
+	!nntp_data->nserv->conn->account.host)
+    return -1;
+  if (nntp_data->firstMessage > nntp_data->lastLoaded)
+    return 0;
+  if (!nntp_data->nserv->hasXPAT)
+  {
+    mutt_error (_("Server %s does not support this operation!"),
+	  nntp_data->nserv->conn->account.host);
+    return -1;
+  }
+
+  snprintf (buf, sizeof (buf), "XPAT References %d-%d *%s*\r\n", 
+	nntp_data->firstMessage, nntp_data->lastLoaded, msgid);
+
+  cc.ctx = ctx;
+  cc.num = 0;
+  cc.max = 25;
+  cc.child = safe_malloc (sizeof (unsigned int) * 25);
+  if (mutt_nntp_fetch (nntp_data, buf, NULL, check_children, &cc, 0))
+  {
+    FREE (&cc.child);
+    return -1;
+  }
+  /* dont try to read the xover cache. check_children() already
+   * made sure that we dont have the article, so we need to visit
+   * the server. Reading the cache at this point is also bad
+   * because it would duplicate messages */
+  if (option (OPTNEWSCACHE))
+  {
+    tmp++;
+    unset_option (OPTNEWSCACHE);
+  }
+  for (i = 0; i < cc.num; i++)
+  {
+    if ((ret = nntp_fetch_headers (ctx, cc.child[i], cc.child[i])))
+      break;
+    if (ctx->msgcount &&
+	  ctx->hdrs[ctx->msgcount - 1]->article_num == cc.child[i])
+      ctx->hdrs[ctx->msgcount - 1]->read = 0;
+  }
+  if (tmp)
+    set_option (OPTNEWSCACHE);
+  FREE (&cc.child);
+  return ret;
+}
diff -udprP mutt-1.5.21/nntp.h mutt-nntp-sidebar/nntp.h
--- mutt-1.5.21/nntp.h	1969-12-31 17:00:00.000000000 -0700
+++ mutt-nntp-sidebar/nntp.h	2011-06-03 07:05:58.916289332 -0700
@@ -0,0 +1,136 @@
+/*
+ * Copyright (C) 1998 Brandon Long <blong@fiction.net>
+ * Copyright (C) 1999 Andrej Gritsenko <andrej@lucky.net>
+ * Copyright (C) 2000-2007 Vsevolod Volkov <vvv@mutt.org.ua>
+ * 
+ *     This program is free software; you can redistribute it and/or modify
+ *     it under the terms of the GNU General Public License as published by
+ *     the Free Software Foundation; either version 2 of the License, or
+ *     (at your option) any later version.
+ * 
+ *     This program is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ * 
+ *     You should have received a copy of the GNU General Public License
+ *     along with this program; if not, write to the Free Software
+ *     Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */ 
+
+#ifndef _NNTP_H_
+#define _NNTP_H_ 1
+
+#include "mutt_socket.h"
+#include "mailbox.h"
+
+#include <time.h>
+
+#define NNTP_PORT 119
+#define NNTP_SSL_PORT 563
+
+/* number of entries in the hash table */
+#define NNTP_CACHE_LEN 10
+
+enum
+{
+  NNTP_NONE = 0,
+  NNTP_OK,
+  NNTP_BYE
+};
+
+typedef struct
+{
+  int first;
+  int last;
+} NEWSRC_ENTRY;
+
+typedef struct
+{
+  unsigned int hasXPAT : 1;
+  unsigned int hasXGTITLE : 1;
+  unsigned int hasXOVER : 1;
+  unsigned int hasLISTGROUP : 1;
+  unsigned int status : 3;
+  char *newsrc;
+  char *cache;
+  int stat;
+  off_t size;
+  time_t mtime;
+  time_t newgroups_time;
+  time_t check_time;
+  HASH *newsgroups;
+  LIST *list;	/* list of newsgroups */
+  LIST *tail;	/* last entry of list */
+  CONNECTION *conn;
+} NNTP_SERVER;
+
+typedef struct
+{
+  unsigned int index;
+  char *path;
+} NNTP_CACHE;
+
+typedef struct
+{
+  NEWSRC_ENTRY *entries;
+  unsigned int num;	/* number of used entries */
+  unsigned int max;	/* number of allocated entries */
+  unsigned int unread;
+  unsigned int firstMessage;
+  unsigned int lastMessage;
+  unsigned int lastLoaded;
+  unsigned int lastCached;
+  unsigned int subscribed : 1;
+  unsigned int rc : 1;
+  unsigned int new : 1;
+  unsigned int allowed : 1;
+  unsigned int deleted : 1;
+  char *group;
+  char *desc;
+  char *cache;
+  NNTP_SERVER *nserv;
+  NNTP_CACHE acache[NNTP_CACHE_LEN];
+} NNTP_DATA;
+
+/* internal functions */
+int nntp_get_active (NNTP_SERVER *);
+int nntp_get_cache_all (NNTP_SERVER *);
+int nntp_save_cache_index (NNTP_SERVER *);
+int nntp_check_newgroups (NNTP_SERVER *, int);
+int nntp_save_cache_group (CONTEXT *);
+int nntp_parse_url (const char *, ACCOUNT *, char *, size_t);
+void newsrc_gen_entries (CONTEXT *);
+void nntp_get_status (CONTEXT *, HEADER *, char *, int);
+void mutt_newsgroup_stat (NNTP_DATA *);
+void nntp_delete_cache (NNTP_DATA *);
+void nntp_add_to_list (NNTP_SERVER *, NNTP_DATA *);
+void nntp_cache_expand (char *, const char *);
+void nntp_delete_data (void *);
+
+/* exposed interface */
+NNTP_SERVER *mutt_select_newsserver (char *);
+NNTP_DATA *mutt_newsgroup_subscribe (NNTP_SERVER *, char *);
+NNTP_DATA *mutt_newsgroup_unsubscribe (NNTP_SERVER *, char *);
+NNTP_DATA *mutt_newsgroup_catchup (NNTP_SERVER *, char *);
+NNTP_DATA *mutt_newsgroup_uncatchup (NNTP_SERVER *, char *);
+void nntp_clear_cacheindex (NNTP_SERVER *);
+int mutt_newsrc_update (NNTP_SERVER *);
+int nntp_open_mailbox (CONTEXT *);
+int nntp_sync_mailbox (CONTEXT *);
+int nntp_check_mailbox (CONTEXT *);
+int nntp_close_mailbox (CONTEXT *);
+int nntp_fastclose_mailbox (CONTEXT *);
+int nntp_fetch_message (MESSAGE *, CONTEXT *, int);
+int nntp_post (const char *);
+int nntp_check_msgid (CONTEXT *, const char *);
+int nntp_check_children (CONTEXT *, const char *);
+void nntp_buffy (char *);
+void nntp_expand_path (char *, size_t, ACCOUNT *);
+void nntp_logout_all ();
+const char *nntp_format_str (char *, size_t, size_t, char, const char *, const char *,
+		const char *, const char *, unsigned long, format_flag);
+
+NNTP_SERVER *CurrentNewsSrv INITVAL (NULL);
+
+#endif /* _NNTP_H_ */
diff -udprP mutt-1.5.21/pager.c mutt-nntp-sidebar/pager.c
--- mutt-1.5.21/pager.c	2011-06-03 07:06:32.529621818 -0700
+++ mutt-nntp-sidebar/pager.c	2011-06-03 07:05:58.939622665 -0700
@@ -1085,6 +1085,11 @@ fill_buffer (FILE *f, LOFF_T *last_pos,
   return b_read;
 }
 
+#ifdef USE_NNTP
+#include "mx.h"
+#include "nntp.h"
+#endif
+
 
 static int format_line (struct line_t **lineInfo, int n, unsigned char *buf,
 			int flags, ansi_attr *pa, int cnt,
@@ -1542,6 +1547,16 @@ static struct mapping_t PagerHelpExtra[]
   { NULL,	0 }
 };
 
+#ifdef USE_NNTP
+static struct mapping_t PagerNewsHelpExtra[] = {
+  { N_("Post"),     OP_POST },
+  { N_("Followup"), OP_FOLLOWUP },
+  { N_("Del"),      OP_DELETE },
+  { N_("Next"),     OP_MAIN_NEXT_UNDELETED },
+  { NULL,           0 }
+};
+#endif
+
 
 
 /* This pager is actually not so simple as it once was.  It now operates in
@@ -1583,6 +1598,10 @@ mutt_pager (const char *banner, const ch
   int old_PagerIndexLines;		/* some people want to resize it
   					 * while inside the pager... */
 
+#ifdef USE_NNTP
+  char *followup_to;
+#endif
+
   if (!(flags & M_SHOWCOLOR))
     flags |= M_SHOWFLAT;
 
@@ -1622,7 +1641,11 @@ mutt_pager (const char *banner, const ch
   if (IsHeader (extra))
   {
     strfcpy (tmphelp, helpstr, sizeof (tmphelp));
-    mutt_compile_help (buffer, sizeof (buffer), MENU_PAGER, PagerHelpExtra);
+    mutt_compile_help (buffer, sizeof (buffer), MENU_PAGER,
+#ifdef USE_NNTP
+	(Context && (Context->magic == M_NNTP)) ? PagerNewsHelpExtra :
+#endif
+	PagerHelpExtra);
     snprintf (helpstr, sizeof (helpstr), "%s %s", tmphelp, buffer);
   }
   if (!InHelp)
@@ -2501,6 +2524,15 @@ search_next:
 	CHECK_READONLY;
 	CHECK_ACL(M_ACL_WRITE, "flag message");
 
+#ifdef USE_NNTP
+	if (Context->magic == M_NNTP)
+	{
+	  mutt_flushinp ();
+	  mutt_error _("Can't change 'important' flag on NNTP server.");
+	  break;
+	}
+#endif
+
 	mutt_set_flag (Context, extra->hdr, M_FLAG, !extra->hdr->flagged);
 	redraw = REDRAW_STATUS | REDRAW_INDEX;
 	if (option (OPTRESOLVE))
@@ -2534,6 +2566,60 @@ search_next:
 	redraw = REDRAW_FULL;
 	break;
 
+#ifdef USE_NNTP
+      case OP_POST:
+	CHECK_MODE(IsHeader (extra) && !IsAttach (extra));
+	CHECK_ATTACH;
+	if (extra->ctx && extra->ctx->magic == M_NNTP &&
+	    !((NNTP_DATA *)extra->ctx->data)->allowed &&
+	    query_quadoption (OPT_TOMODERATED,_("Posting to this group not allowed, may be moderated. Continue?")) != M_YES)
+	  break;
+	ci_send_message (SENDNEWS, NULL, NULL, extra->ctx, NULL);
+	redraw = REDRAW_FULL;
+	break;
+
+      case OP_FORWARD_TO_GROUP:
+	CHECK_MODE(IsHeader (extra) || IsMsgAttach (extra));
+	CHECK_ATTACH;
+	if (extra->ctx && extra->ctx->magic == M_NNTP &&
+	    !((NNTP_DATA *)extra->ctx->data)->allowed &&
+	    query_quadoption (OPT_TOMODERATED,_("Posting to this group not allowed, may be moderated. Continue?")) != M_YES)
+	  break;
+	if (IsMsgAttach (extra))
+	  mutt_attach_forward (extra->fp, extra->hdr, extra->idx,
+			       extra->idxlen, extra->bdy, SENDNEWS);
+	else
+	  ci_send_message (SENDNEWS|SENDFORWARD, NULL, NULL, extra->ctx, extra->hdr);
+	redraw = REDRAW_FULL;
+	break;
+
+      case OP_FOLLOWUP:
+	CHECK_MODE(IsHeader (extra) || IsMsgAttach (extra));
+	CHECK_ATTACH;
+
+        if (IsMsgAttach (extra))
+	  followup_to = extra->bdy->hdr->env->followup_to;
+        else
+	  followup_to = extra->hdr->env->followup_to;
+
+	if (!followup_to || mutt_strcasecmp (followup_to, "poster") ||
+	    query_quadoption (OPT_FOLLOWUPTOPOSTER,_("Reply by mail as poster prefers?")) != M_YES)
+	{
+	  if (extra->ctx && extra->ctx->magic == M_NNTP &&
+	      !((NNTP_DATA *)extra->ctx->data)->allowed &&
+	      query_quadoption (OPT_TOMODERATED,_("Posting to this group not allowed, may be moderated. Continue?")) != M_YES)
+	    break;
+	  if (IsMsgAttach (extra))
+	    mutt_attach_reply (extra->fp, extra->hdr, extra->idx,
+			       extra->idxlen, extra->bdy, SENDNEWS|SENDREPLY);
+	  else
+	    ci_send_message (SENDNEWS|SENDREPLY, NULL, NULL,
+			     extra->ctx, extra->hdr);
+	  redraw = REDRAW_FULL;
+	  break;
+	}
+#endif
+
       case OP_REPLY:
 	CHECK_MODE(IsHeader (extra) || IsMsgAttach (extra));
         CHECK_ATTACH;      
@@ -2580,7 +2666,7 @@ search_next:
         CHECK_ATTACH;
         if (IsMsgAttach (extra))
 	  mutt_attach_forward (extra->fp, extra->hdr, extra->idx,
-			       extra->idxlen, extra->bdy);
+			       extra->idxlen, extra->bdy, 0);
         else
 	  ci_send_message (SENDFORWARD, NULL, NULL, extra->ctx, extra->hdr);
 	redraw = REDRAW_FULL;
diff -udprP mutt-1.5.21/pager.c.orig mutt-nntp-sidebar/pager.c.orig
--- mutt-1.5.21/pager.c.orig	1969-12-31 17:00:00.000000000 -0700
+++ mutt-nntp-sidebar/pager.c.orig	2011-06-03 07:05:58.942955998 -0700
@@ -0,0 +1,2811 @@
+/*
+ * Copyright (C) 1996-2002,2007 Michael R. Elkins <me@mutt.org>
+ * 
+ *     This program is free software; you can redistribute it and/or modify
+ *     it under the terms of the GNU General Public License as published by
+ *     the Free Software Foundation; either version 2 of the License, or
+ *     (at your option) any later version.
+ * 
+ *     This program is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ * 
+ *     You should have received a copy of the GNU General Public License
+ *     along with this program; if not, write to the Free Software
+ *     Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */ 
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include "mutt.h"
+#include "mutt_curses.h"
+#include "mutt_regex.h"
+#include "keymap.h"
+#include "mutt_menu.h"
+#include "mapping.h"
+#include "pager.h"
+#include "attach.h"
+#include "mbyte.h"
+#include "sidebar.h"
+
+#include "mutt_crypt.h"
+
+#include <sys/stat.h>
+#include <ctype.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <string.h>
+#include <errno.h>
+
+#define ISHEADER(x) ((x) == MT_COLOR_HEADER || (x) == MT_COLOR_HDEFAULT)
+
+#define IsAttach(x) (x && (x)->bdy)
+#define IsRecvAttach(x) (x && (x)->bdy && (x)->fp)
+#define IsSendAttach(x) (x && (x)->bdy && !(x)->fp)
+#define IsMsgAttach(x) (x && (x)->fp && (x)->bdy && (x)->bdy->hdr)
+#define IsHeader(x) (x && (x)->hdr && !(x)->bdy)
+
+static const char *Not_available_in_this_menu = N_("Not available in this menu.");
+static const char *Mailbox_is_read_only = N_("Mailbox is read-only.");
+static const char *Function_not_permitted_in_attach_message_mode = N_("Function not permitted in attach-message mode.");
+
+/* hack to return to position when returning from index to same message */
+static int TopLine = 0;
+static HEADER *OldHdr = NULL;
+
+#define CHECK_MODE(x)	if (!(x)) \
+			{ \
+			  	mutt_flushinp (); \
+				mutt_error _(Not_available_in_this_menu); \
+				break; \
+			}
+
+#define CHECK_READONLY	if (Context->readonly) \
+			{ \
+				mutt_flushinp (); \
+				mutt_error _(Mailbox_is_read_only);	\
+				break; \
+			}
+
+#define CHECK_ATTACH if(option(OPTATTACHMSG)) \
+		     {\
+			mutt_flushinp (); \
+			mutt_error _(Function_not_permitted_in_attach_message_mode); \
+			break; \
+		     }
+
+#define CHECK_ACL(aclbit,action) \
+		if (!mutt_bit_isset(Context->rights,aclbit)) { \
+			mutt_flushinp(); \
+			mutt_error (_("Cannot %s: Operation not permitted by ACL"), action); \
+			break; \
+		}
+
+struct q_class_t
+{
+  int length;
+  int index;
+  int color;
+  char *prefix;
+  struct q_class_t *next, *prev;
+  struct q_class_t *down, *up;
+};
+
+struct syntax_t
+{
+  int color;
+  int first;
+  int last;
+};
+
+struct line_t
+{
+  LOFF_T offset;
+  short type;
+  short continuation;
+  short chunks;
+  short search_cnt;
+  struct syntax_t *syntax;
+  struct syntax_t *search;
+  struct q_class_t *quote;
+  unsigned int is_cont_hdr; /* this line is a continuation of the previous header line */
+};
+
+#define ANSI_OFF       (1<<0)
+#define ANSI_BLINK     (1<<1)
+#define ANSI_BOLD      (1<<2)
+#define ANSI_UNDERLINE (1<<3)
+#define ANSI_REVERSE   (1<<4)
+#define ANSI_COLOR     (1<<5)
+
+typedef struct _ansi_attr {
+  int attr;
+  int fg;
+  int bg;
+  int pair;
+} ansi_attr;
+
+static short InHelp = 0;
+
+#if defined (USE_SLANG_CURSES) || defined (HAVE_RESIZETERM)
+static struct resize {
+  int line;
+  int SearchCompiled;
+  int SearchBack;
+} *Resize = NULL;
+#endif
+
+#define NumSigLines 4
+
+static int check_sig (const char *s, struct line_t *info, int n)
+{
+  int count = 0;
+
+  while (n > 0 && count <= NumSigLines)
+  {
+    if (info[n].type != MT_COLOR_SIGNATURE)
+      break;
+    count++;
+    n--;
+  }
+
+  if (count == 0)
+    return (-1);
+
+  if (count > NumSigLines)
+  {
+    /* check for a blank line */
+    while (*s)
+    {
+      if (!ISSPACE (*s))
+	return 0;
+      s++;
+    }
+
+    return (-1);
+  }
+
+  return (0);
+}
+
+static void
+resolve_color (struct line_t *lineInfo, int n, int cnt, int flags, int special,
+    ansi_attr *a)
+{
+  int def_color;		/* color without syntax hilight */
+  int color;			/* final color */
+  static int last_color;	/* last color set */
+  int search = 0, i, m;
+
+  if (!cnt)
+    last_color = -1;		/* force attrset() */
+
+  if (lineInfo[n].continuation)
+  {
+    if (!cnt && option (OPTMARKERS))
+    {
+      SETCOLOR (MT_COLOR_MARKERS);
+      addch ('+');
+      last_color = ColorDefs[MT_COLOR_MARKERS];
+    }
+    m = (lineInfo[n].syntax)[0].first;
+    cnt += (lineInfo[n].syntax)[0].last;
+  }
+  else
+    m = n;
+  if (!(flags & M_SHOWCOLOR))
+    def_color = ColorDefs[MT_COLOR_NORMAL];
+  else if (lineInfo[m].type == MT_COLOR_HEADER)
+    def_color = (lineInfo[m].syntax)[0].color;
+  else
+    def_color = ColorDefs[lineInfo[m].type];
+
+  if ((flags & M_SHOWCOLOR) && lineInfo[m].type == MT_COLOR_QUOTED)
+  {
+    struct q_class_t *class = lineInfo[m].quote;
+
+    if (class)
+    {
+      def_color = class->color;
+
+      while (class && class->length > cnt)
+      {
+	def_color = class->color;
+	class = class->up;
+      }
+    }
+  }
+
+  color = def_color;
+  if (flags & M_SHOWCOLOR)
+  {
+    for (i = 0; i < lineInfo[m].chunks; i++)
+    {
+      /* we assume the chunks are sorted */
+      if (cnt > (lineInfo[m].syntax)[i].last)
+	continue;
+      if (cnt < (lineInfo[m].syntax)[i].first)
+	break;
+      if (cnt != (lineInfo[m].syntax)[i].last)
+      {
+	color = (lineInfo[m].syntax)[i].color;
+	break;
+      }
+      /* don't break here, as cnt might be 
+       * in the next chunk as well */
+    }
+  }
+
+  if (flags & M_SEARCH)
+  {
+    for (i = 0; i < lineInfo[m].search_cnt; i++)
+    {
+      if (cnt > (lineInfo[m].search)[i].last)
+	continue;
+      if (cnt < (lineInfo[m].search)[i].first)
+	break;
+      if (cnt != (lineInfo[m].search)[i].last)
+      {
+	color = ColorDefs[MT_COLOR_SEARCH];
+	search = 1;
+	break;
+      }
+    }
+  }
+
+  /* handle "special" bold & underlined characters */
+  if (special || a->attr)
+  {
+#ifdef HAVE_COLOR
+    if ((a->attr & ANSI_COLOR))
+    {
+      if (a->pair == -1)
+	a->pair = mutt_alloc_color (a->fg, a->bg);
+      color = a->pair;
+      if (a->attr & ANSI_BOLD)
+	  color |= A_BOLD;
+    }
+    else
+#endif
+      if ((special & A_BOLD) || (a->attr & ANSI_BOLD))
+    {
+      if (ColorDefs[MT_COLOR_BOLD] && !search)
+	color = ColorDefs[MT_COLOR_BOLD];
+      else
+	color ^= A_BOLD;
+    }
+    if ((special & A_UNDERLINE) || (a->attr & ANSI_UNDERLINE))
+    {
+      if (ColorDefs[MT_COLOR_UNDERLINE] && !search)
+	color = ColorDefs[MT_COLOR_UNDERLINE];
+      else
+	color ^= A_UNDERLINE;
+    }
+    else if (a->attr & ANSI_REVERSE) 
+    {
+      color ^= A_REVERSE;
+    }
+    else if (a->attr & ANSI_BLINK) 
+    {
+      color ^= A_BLINK;
+    }
+    else if (a->attr & ANSI_OFF)
+    {
+      a->attr = 0;
+    }
+  }
+
+  if (color != last_color)
+  {
+    attrset (color);
+    last_color = color;
+  }
+}
+
+static void
+append_line (struct line_t *lineInfo, int n, int cnt)
+{
+  int m;
+
+  lineInfo[n+1].type = lineInfo[n].type;
+  (lineInfo[n+1].syntax)[0].color = (lineInfo[n].syntax)[0].color;
+  lineInfo[n+1].continuation = 1;
+
+  /* find the real start of the line */
+  for (m = n; m >= 0; m--)
+    if (lineInfo[m].continuation == 0) break;
+
+  (lineInfo[n+1].syntax)[0].first = m;
+  (lineInfo[n+1].syntax)[0].last = (lineInfo[n].continuation) ? 
+    cnt + (lineInfo[n].syntax)[0].last : cnt;
+}
+
+static void
+new_class_color (struct q_class_t *class, int *q_level)
+{
+  class->index = (*q_level)++;
+  class->color = ColorQuote[class->index % ColorQuoteUsed];
+}
+
+static void
+shift_class_colors (struct q_class_t *QuoteList, struct q_class_t *new_class,
+		      int index, int *q_level)
+{
+  struct q_class_t * q_list;
+
+  q_list = QuoteList;
+  new_class->index = -1;
+
+  while (q_list)
+  {
+    if (q_list->index >= index)
+    {
+      q_list->index++;
+      q_list->color = ColorQuote[q_list->index % ColorQuoteUsed];
+    }
+    if (q_list->down)
+      q_list = q_list->down;
+    else if (q_list->next)
+      q_list = q_list->next;
+    else
+    {
+      while (!q_list->next)
+      {
+	q_list = q_list->up;
+	if (q_list == NULL)
+	  break;
+      }
+      if (q_list)
+	q_list = q_list->next;
+    }
+  }
+
+  new_class->index = index;
+  new_class->color = ColorQuote[index % ColorQuoteUsed];
+  (*q_level)++;
+}
+
+static void
+cleanup_quote (struct q_class_t **QuoteList)
+{
+  struct q_class_t *ptr;
+
+  while (*QuoteList)
+  {
+    if ((*QuoteList)->down)
+      cleanup_quote (&((*QuoteList)->down));
+    ptr = (*QuoteList)->next;
+    if ((*QuoteList)->prefix)
+      FREE (&(*QuoteList)->prefix);
+    FREE (QuoteList);		/* __FREE_CHECKED__ */
+    *QuoteList = ptr;
+  }
+
+  return;
+}
+
+static struct q_class_t *
+classify_quote (struct q_class_t **QuoteList, const char *qptr,
+		int length, int *force_redraw, int *q_level)
+{
+  struct q_class_t *q_list = *QuoteList;
+  struct q_class_t *class = NULL, *tmp = NULL, *ptr, *save;
+  char *tail_qptr;
+  int offset, tail_lng;
+  int index = -1;
+
+  if (ColorQuoteUsed <= 1)
+  {
+    /* not much point in classifying quotes... */
+
+    if (*QuoteList == NULL)
+    {
+      class = (struct q_class_t *) safe_calloc (1, sizeof (struct q_class_t));
+      class->color = ColorQuote[0];
+      *QuoteList = class;
+    }
+    return (*QuoteList);
+  }
+
+  /* Did I mention how much I like emulating Lisp in C? */
+
+  /* classify quoting prefix */
+  while (q_list)
+  {
+    if (length <= q_list->length)
+    {
+      /* case 1: check the top level nodes */
+
+      if (mutt_strncmp (qptr, q_list->prefix, length) == 0)
+      {
+	if (length == q_list->length)
+	  return q_list;	/* same prefix: return the current class */
+
+	/* found shorter prefix */
+	if (tmp == NULL)
+	{
+	  /* add a node above q_list */
+	  tmp = (struct q_class_t *) safe_calloc (1, sizeof (struct q_class_t));
+	  tmp->prefix = (char *) safe_calloc (1, length + 1);
+	  strncpy (tmp->prefix, qptr, length);
+	  tmp->length = length;
+
+	  /* replace q_list by tmp in the top level list */
+	  if (q_list->next)
+	  {
+	    tmp->next = q_list->next;
+	    q_list->next->prev = tmp;
+	  }
+	  if (q_list->prev)
+	  {
+	    tmp->prev = q_list->prev;
+	    q_list->prev->next = tmp;
+	  }
+
+	  /* make q_list a child of tmp */
+	  tmp->down = q_list;
+	  q_list->up = tmp;
+
+	  /* q_list has no siblings for now */
+	  q_list->next = NULL;
+	  q_list->prev = NULL;
+
+	  /* update the root if necessary */
+	  if (q_list == *QuoteList)
+	    *QuoteList = tmp;
+
+	  index = q_list->index;
+
+	  /* tmp should be the return class too */
+	  class = tmp;
+
+	  /* next class to test; if tmp is a shorter prefix for another
+	   * node, that node can only be in the top level list, so don't
+	   * go down after this point
+	   */
+	  q_list = tmp->next;
+	}
+	else
+	{
+	  /* found another branch for which tmp is a shorter prefix */
+
+	  /* save the next sibling for later */
+	  save = q_list->next;
+
+	  /* unlink q_list from the top level list */
+	  if (q_list->next)
+	    q_list->next->prev = q_list->prev;
+	  if (q_list->prev)
+	    q_list->prev->next = q_list->next;
+
+	  /* at this point, we have a tmp->down; link q_list to it */
+	  ptr = tmp->down;
+	  /* sibling order is important here, q_list should be linked last */
+	  while (ptr->next)
+	    ptr = ptr->next;
+	  ptr->next = q_list;
+	  q_list->next = NULL;
+	  q_list->prev = ptr;
+	  q_list->up = tmp;
+
+	  index = q_list->index;
+
+	  /* next class to test; as above, we shouldn't go down */
+	  q_list = save;
+	}
+
+	/* we found a shorter prefix, so certain quotes have changed classes */
+	*force_redraw = 1;
+	continue;
+      }
+      else
+      {
+	/* shorter, but not a substring of the current class: try next */
+	q_list = q_list->next;
+	continue;
+      }
+    }
+    else
+    {
+      /* case 2: try subclassing the current top level node */
+      
+      /* tmp != NULL means we already found a shorter prefix at case 1 */
+      if (tmp == NULL && mutt_strncmp (qptr, q_list->prefix, q_list->length) == 0)
+      {
+	/* ok, it's a subclass somewhere on this branch */
+
+	ptr = q_list;
+	offset = q_list->length;
+
+	q_list = q_list->down;
+	tail_lng = length - offset;
+	tail_qptr = (char *) qptr + offset;
+
+	while (q_list)
+	{
+	  if (length <= q_list->length)
+	  {
+	    if (mutt_strncmp (tail_qptr, (q_list->prefix) + offset, tail_lng) == 0)
+	    {
+	      /* same prefix: return the current class */
+	      if (length == q_list->length)
+		return q_list;
+
+	      /* found shorter common prefix */
+	      if (tmp == NULL)
+	      {
+		/* add a node above q_list */
+		tmp = (struct q_class_t *) safe_calloc (1, 
+					    sizeof (struct q_class_t));
+		tmp->prefix = (char *) safe_calloc (1, length + 1);
+		strncpy (tmp->prefix, qptr, length);
+		tmp->length = length;
+			
+		/* replace q_list by tmp */
+		if (q_list->next)
+		{
+		  tmp->next = q_list->next;
+		  q_list->next->prev = tmp;
+		}
+		if (q_list->prev)
+		{
+		  tmp->prev = q_list->prev;
+		  q_list->prev->next = tmp;
+		}
+
+		/* make q_list a child of tmp */
+		tmp->down = q_list;
+		tmp->up = q_list->up;
+		q_list->up = tmp;
+		if (tmp->up->down == q_list)
+		  tmp->up->down = tmp;
+
+		/* q_list has no siblings */
+		q_list->next = NULL;
+		q_list->prev = NULL;
+                              
+		index = q_list->index;
+
+		/* tmp should be the return class too */
+		class = tmp;
+
+		/* next class to test */
+		q_list = tmp->next;
+	      }
+	      else
+	      {
+		/* found another branch for which tmp is a shorter prefix */
+
+		/* save the next sibling for later */
+		save = q_list->next;
+
+		/* unlink q_list from the top level list */
+		if (q_list->next)
+		  q_list->next->prev = q_list->prev;
+		if (q_list->prev)
+		  q_list->prev->next = q_list->next;
+
+		/* at this point, we have a tmp->down; link q_list to it */
+		ptr = tmp->down;
+		while (ptr->next)
+		  ptr = ptr->next;
+		ptr->next = q_list;
+		q_list->next = NULL;
+		q_list->prev = ptr;
+		q_list->up = tmp;
+
+		index = q_list->index;
+
+		/* next class to test */
+		q_list = save;
+	      }
+
+	      /* we found a shorter prefix, so we need a redraw */
+	      *force_redraw = 1;
+	      continue;
+	    }
+	    else
+	    {
+	      q_list = q_list->next;
+	      continue;
+	    }
+	  }
+	  else
+	  {
+	    /* longer than the current prefix: try subclassing it */
+	    if (tmp == NULL && mutt_strncmp (tail_qptr, (q_list->prefix) + offset,
+			  q_list->length - offset) == 0)
+	    {
+	      /* still a subclass: go down one level */
+	      ptr = q_list;
+	      offset = q_list->length;
+
+	      q_list = q_list->down;
+	      tail_lng = length - offset;
+	      tail_qptr = (char *) qptr + offset;
+
+	      continue;
+	    }
+	    else
+	    {
+	      /* nope, try the next prefix */
+	      q_list = q_list->next;
+	      continue;
+	    }
+	  }
+	}
+
+	/* still not found so far: add it as a sibling to the current node */
+	if (class == NULL)
+	{
+	  tmp = (struct q_class_t *) safe_calloc (1, sizeof (struct q_class_t));
+	  tmp->prefix = (char *) safe_calloc (1, length + 1);
+	  strncpy (tmp->prefix, qptr, length);
+	  tmp->length = length;
+
+	  if (ptr->down)
+	  {
+	    tmp->next = ptr->down;
+	    ptr->down->prev = tmp;
+	  }
+	  ptr->down = tmp;
+	  tmp->up = ptr;
+
+	  new_class_color (tmp, q_level);
+
+	  return tmp;
+	}
+	else
+	{
+	  if (index != -1)
+	    shift_class_colors (*QuoteList, tmp, index, q_level);
+
+	  return class;
+	}
+      }
+      else
+      {
+	/* nope, try the next prefix */
+	q_list = q_list->next;
+	continue;
+      }
+    }
+  }
+
+  if (class == NULL)
+  {
+    /* not found so far: add it as a top level class */
+    class = (struct q_class_t *) safe_calloc (1, sizeof (struct q_class_t));
+    class->prefix = (char *) safe_calloc (1, length + 1);
+    strncpy (class->prefix, qptr, length);
+    class->length = length;
+    new_class_color (class, q_level);
+
+    if (*QuoteList)
+    {
+      class->next = *QuoteList;
+      (*QuoteList)->prev = class;
+    }
+    *QuoteList = class;
+  }
+
+  if (index != -1)
+    shift_class_colors (*QuoteList, tmp, index, q_level);
+
+  return class;
+}
+
+static int brailleLine = -1;
+static int brailleCol = -1;
+
+static int check_attachment_marker (char *);
+
+static void
+resolve_types (char *buf, char *raw, struct line_t *lineInfo, int n, int last,
+		struct q_class_t **QuoteList, int *q_level, int *force_redraw,
+		int q_classify)
+{
+  COLOR_LINE *color_line;
+  regmatch_t pmatch[1], smatch[1];
+  int found, offset, null_rx, i;
+
+  if (n == 0 || ISHEADER (lineInfo[n-1].type))
+  {
+    if (buf[0] == '\n') /* end of header */
+    {
+      lineInfo[n].type = MT_COLOR_NORMAL;
+      getyx(stdscr, brailleLine, brailleCol);
+    }
+    else
+    {
+      /* if this is a continuation of the previous line, use the previous
+       * line's color as default. */
+      if (n > 0 && (buf[0] == ' ' || buf[0] == '\t'))
+      {
+	lineInfo[n].type = lineInfo[n-1].type; /* wrapped line */
+	(lineInfo[n].syntax)[0].color = (lineInfo[n-1].syntax)[0].color;
+	lineInfo[n].is_cont_hdr = 1;
+      }
+      else
+      {
+	lineInfo[n].type = MT_COLOR_HDEFAULT;
+      }
+
+      for (color_line = ColorHdrList; color_line; color_line = color_line->next)
+      {
+	if (REGEXEC (color_line->rx, buf) == 0)
+	{
+	  lineInfo[n].type = MT_COLOR_HEADER;
+	  lineInfo[n].syntax[0].color = color_line->pair;
+	  if (lineInfo[n].is_cont_hdr)
+	  {
+	    /* adjust the previous continuation lines to reflect the color of this continuation line */
+	    int j;
+	    for (j = n - 1; j >= 0 && lineInfo[j].is_cont_hdr; --j)
+	    {
+	      lineInfo[j].type = lineInfo[n].type;
+	      lineInfo[j].syntax[0].color = lineInfo[n].syntax[0].color;
+	    }
+	    /* now adjust the first line of this header field */
+	    if (j >= 0)
+	    {
+	      lineInfo[j].type = lineInfo[n].type;
+	      lineInfo[j].syntax[0].color = lineInfo[n].syntax[0].color;
+	    }
+	    *force_redraw = 1; /* the previous lines have already been drawn on the screen */
+	  }
+	  break;
+	}
+      }
+    }
+  }
+  else if (mutt_strncmp ("\033[0m", raw, 4) == 0)	/* a little hack... */
+    lineInfo[n].type = MT_COLOR_NORMAL;
+#if 0
+  else if (mutt_strncmp ("[-- ", buf, 4) == 0)
+    lineInfo[n].type = MT_COLOR_ATTACHMENT;
+#else
+  else if (check_attachment_marker ((char *) raw) == 0)
+    lineInfo[n].type = MT_COLOR_ATTACHMENT;
+#endif
+  else if (mutt_strcmp ("-- \n", buf) == 0 || mutt_strcmp ("-- \r\n", buf) == 0)
+  {
+    i = n + 1;
+
+    lineInfo[n].type = MT_COLOR_SIGNATURE;
+    while (i < last && check_sig (buf, lineInfo, i - 1) == 0 &&
+	   (lineInfo[i].type == MT_COLOR_NORMAL ||
+	    lineInfo[i].type == MT_COLOR_QUOTED ||
+	    lineInfo[i].type == MT_COLOR_HEADER))
+      {
+	/* oops... */
+	if (lineInfo[i].chunks)
+	{
+	  lineInfo[i].chunks = 0;
+	  safe_realloc (&(lineInfo[n].syntax), 
+			sizeof (struct syntax_t));
+	}
+	lineInfo[i++].type = MT_COLOR_SIGNATURE;
+      }
+  }
+  else if (check_sig (buf, lineInfo, n - 1) == 0)
+    lineInfo[n].type = MT_COLOR_SIGNATURE;
+  else if (regexec ((regex_t *) QuoteRegexp.rx, buf, 1, pmatch, 0) == 0)
+  {
+    if (regexec ((regex_t *) Smileys.rx, buf, 1, smatch, 0) == 0)
+    {
+      if (smatch[0].rm_so > 0)
+      {
+	char c;
+
+	/* hack to avoid making an extra copy of buf */
+	c = buf[smatch[0].rm_so];
+	buf[smatch[0].rm_so] = 0;
+
+	if (regexec ((regex_t *) QuoteRegexp.rx, buf, 1, pmatch, 0) == 0)
+	{
+	  if (q_classify && lineInfo[n].quote == NULL)
+	    lineInfo[n].quote = classify_quote (QuoteList,
+				  buf + pmatch[0].rm_so,
+				  pmatch[0].rm_eo - pmatch[0].rm_so,
+				  force_redraw, q_level);
+	  lineInfo[n].type = MT_COLOR_QUOTED;
+	}
+	else
+	  lineInfo[n].type = MT_COLOR_NORMAL;
+
+	buf[smatch[0].rm_so] = c;
+      }
+      else
+	lineInfo[n].type = MT_COLOR_NORMAL;
+    }
+    else
+    {
+      if (q_classify && lineInfo[n].quote == NULL)
+	lineInfo[n].quote = classify_quote (QuoteList, buf + pmatch[0].rm_so,
+			      pmatch[0].rm_eo - pmatch[0].rm_so,
+			      force_redraw, q_level);
+      lineInfo[n].type = MT_COLOR_QUOTED;
+    }
+  }
+  else
+    lineInfo[n].type = MT_COLOR_NORMAL;
+
+  /* body patterns */
+  if (lineInfo[n].type == MT_COLOR_NORMAL || 
+      lineInfo[n].type == MT_COLOR_QUOTED)
+  {
+    size_t nl;
+
+    /* don't consider line endings part of the buffer
+     * for regex matching */
+    if ((nl = mutt_strlen (buf)) > 0 && buf[nl-1] == '\n')
+      buf[nl-1] = 0;
+
+    i = 0;
+    offset = 0;
+    lineInfo[n].chunks = 0;
+    do
+    {
+      if (!buf[offset])
+	break;
+
+      found = 0;
+      null_rx = 0;
+      color_line = ColorBodyList;
+      while (color_line)
+      {
+	if (regexec (&color_line->rx, buf + offset, 1, pmatch,
+		     (offset ? REG_NOTBOL : 0)) == 0)
+	{
+	  if (pmatch[0].rm_eo != pmatch[0].rm_so)
+	  {
+	    if (!found)
+	    {
+	      if (++(lineInfo[n].chunks) > 1)
+		safe_realloc (&(lineInfo[n].syntax), 
+			      (lineInfo[n].chunks) * sizeof (struct syntax_t));
+	    }
+	    i = lineInfo[n].chunks - 1;
+	    pmatch[0].rm_so += offset;
+	    pmatch[0].rm_eo += offset;
+	    if (!found ||
+		pmatch[0].rm_so < (lineInfo[n].syntax)[i].first ||
+		(pmatch[0].rm_so == (lineInfo[n].syntax)[i].first &&
+		 pmatch[0].rm_eo > (lineInfo[n].syntax)[i].last))
+	    {
+	      (lineInfo[n].syntax)[i].color = color_line->pair;
+	      (lineInfo[n].syntax)[i].first = pmatch[0].rm_so;
+	      (lineInfo[n].syntax)[i].last = pmatch[0].rm_eo;
+	    }
+	    found = 1;
+	    null_rx = 0;
+	  }
+	  else
+	    null_rx = 1; /* empty regexp; don't add it, but keep looking */
+	}
+	color_line = color_line->next;
+      }
+
+      if (null_rx)
+	offset++; /* avoid degenerate cases */
+      else
+	offset = (lineInfo[n].syntax)[i].last;
+    } while (found || null_rx);
+    if (nl > 0)
+      buf[nl] = '\n';
+  }
+}
+
+static int is_ansi (unsigned char *buf)
+{
+  while (*buf && (isdigit(*buf) || *buf == ';'))
+    buf++;
+  return (*buf == 'm');
+}
+
+static int check_attachment_marker (char *p)
+{
+  char *q = AttachmentMarker;
+  
+  for (;*p == *q && *q && *p && *q != '\a' && *p != '\a'; p++, q++)
+    ;
+  return (int) (*p - *q);
+}
+
+static int grok_ansi(unsigned char *buf, int pos, ansi_attr *a)
+{
+  int x = pos;
+
+  while (isdigit(buf[x]) || buf[x] == ';')
+    x++;
+
+  /* Character Attributes */
+  if (option (OPTALLOWANSI) && a != NULL && buf[x] == 'm')
+  {
+    if (pos == x)
+    {
+#ifdef HAVE_COLOR
+      if (a->pair != -1)
+	mutt_free_color (a->fg, a->bg);
+#endif
+      a->attr = ANSI_OFF;
+      a->pair = -1;
+    }
+    while (pos < x)
+    {
+      if (buf[pos] == '1' && (pos+1 == x || buf[pos+1] == ';'))
+      {
+	a->attr |= ANSI_BOLD;
+	pos += 2;
+      } 
+      else if (buf[pos] == '4' && (pos+1 == x || buf[pos+1] == ';'))
+      {
+	a->attr |= ANSI_UNDERLINE;
+	pos += 2;
+      }
+      else if (buf[pos] == '5' && (pos+1 == x || buf[pos+1] == ';'))
+      {
+	a->attr |= ANSI_BLINK;
+	pos += 2;
+      }
+      else if (buf[pos] == '7' && (pos+1 == x || buf[pos+1] == ';'))
+      {
+	a->attr |= ANSI_REVERSE;
+	pos += 2;
+      }
+      else if (buf[pos] == '0' && (pos+1 == x || buf[pos+1] == ';'))
+      {
+#ifdef HAVE_COLOR
+	if (a->pair != -1)
+	  mutt_free_color(a->fg,a->bg);
+#endif
+	a->attr = ANSI_OFF;
+	a->pair = -1;
+	pos += 2;
+      }
+      else if (buf[pos] == '3' && isdigit(buf[pos+1]))
+      {
+#ifdef HAVE_COLOR
+	if (a->pair != -1)
+	  mutt_free_color(a->fg,a->bg);
+#endif
+	a->pair = -1;
+	a->attr |= ANSI_COLOR;
+	a->fg = buf[pos+1] - '0';
+	pos += 3;
+      }
+      else if (buf[pos] == '4' && isdigit(buf[pos+1]))
+      {
+#ifdef HAVE_COLOR
+	if (a->pair != -1)
+	  mutt_free_color(a->fg,a->bg);
+#endif
+	a->pair = -1;
+	a->attr |= ANSI_COLOR;
+	a->bg = buf[pos+1] - '0';
+	pos += 3;
+      }
+      else 
+      {
+	while (pos < x && buf[pos] != ';') pos++;
+	pos++;
+      }
+    }
+  }
+  pos = x;
+  return pos;
+}
+
+/* trim tail of buf so that it contains complete multibyte characters */
+static int
+trim_incomplete_mbyte(unsigned char *buf, size_t len)
+{
+  mbstate_t mbstate;
+  size_t k;
+
+  memset (&mbstate, 0, sizeof (mbstate));
+  for (; len > 0; buf += k, len -= k)
+  {
+    k = mbrtowc (NULL, (char *) buf, len, &mbstate);
+    if (k == -2) 
+      break; 
+    else if (k == -1 || k == 0) 
+      k = 1;
+  }
+  *buf = '\0';
+
+  return len;
+}
+
+static int
+fill_buffer (FILE *f, LOFF_T *last_pos, LOFF_T offset, unsigned char **buf,
+	     unsigned char **fmt, size_t *blen, int *buf_ready)
+{
+  unsigned char *p, *q;
+  static int b_read;
+  int l;
+
+  if (*buf_ready == 0)
+  {
+    if (offset != *last_pos)
+      fseeko (f, offset, 0);
+    if ((*buf = (unsigned char *) mutt_read_line ((char *) *buf, blen, f, &l, M_EOL)) == NULL)
+    {
+      fmt[0] = 0;
+      return (-1);
+    }
+    *last_pos = ftello (f);
+    b_read = (int) (*last_pos - offset);
+    *buf_ready = 1;
+
+    safe_realloc (fmt, *blen);
+
+    /* incomplete mbyte characters trigger a segfault in regex processing for
+     * certain versions of glibc. Trim them if necessary. */
+    if (b_read == *blen - 2)
+      b_read -= trim_incomplete_mbyte(*buf, b_read);
+    
+    /* copy "buf" to "fmt", but without bold and underline controls */
+    p = *buf;
+    q = *fmt;
+    while (*p)
+    {
+      if (*p == '\010' && (p > *buf))
+      {
+	if (*(p+1) == '_')	/* underline */
+	  p += 2;
+	else if (*(p+1) && q > *fmt)	/* bold or overstrike */
+	{
+	  *(q-1) = *(p+1);
+	  p += 2;
+	}
+	else			/* ^H */
+	  *q++ = *p++;
+      }
+      else if (*p == '\033' && *(p+1) == '[' && is_ansi (p + 2))
+      {
+	while (*p++ != 'm')	/* skip ANSI sequence */
+	  ;
+      }
+      else if (*p == '\033' && *(p+1) == ']' && check_attachment_marker ((char *) p) == 0)
+      {
+	dprint (2, (debugfile, "fill_buffer: Seen attachment marker.\n"));
+	while (*p++ != '\a')	/* skip pseudo-ANSI sequence */
+	  ;
+      }
+      else
+	*q++ = *p++;
+    }
+    *q = 0;
+  }
+  return b_read;
+}
+
+
+static int format_line (struct line_t **lineInfo, int n, unsigned char *buf,
+			int flags, ansi_attr *pa, int cnt,
+			int *pspace, int *pvch, int *pcol, int *pspecial)
+{
+  int space = -1; /* index of the last space or TAB */
+  int col = option (OPTMARKERS) ? (*lineInfo)[n].continuation : 0;
+  int ch, vch, k, last_special = -1, special = 0, t;
+  wchar_t wc;
+  mbstate_t mbstate;
+  int wrap_cols = mutt_term_width ((flags & M_PAGER_NOWRAP) ? 0 : Wrap);
+  wrap_cols -= SidebarWidth;
+
+  if (check_attachment_marker ((char *)buf) == 0)
+    wrap_cols = COLS;
+
+  /* FIXME: this should come from lineInfo */
+  memset(&mbstate, 0, sizeof(mbstate));
+
+  for (ch = 0, vch = 0; ch < cnt; ch += k, vch += k)
+  {
+    /* Handle ANSI sequences */
+    while (cnt-ch >= 2 && buf[ch] == '\033' && buf[ch+1] == '[' &&
+	   is_ansi (buf+ch+2))
+      ch = grok_ansi (buf, ch+2, pa) + 1;
+
+    while (cnt-ch >= 2 && buf[ch] == '\033' && buf[ch+1] == ']' &&
+	   check_attachment_marker ((char *) buf+ch) == 0)
+    {
+      while (buf[ch++] != '\a')
+	if (ch >= cnt)
+	  break;
+    }
+
+    /* is anything left to do? */
+    if (ch >= cnt)
+      break;
+    
+    k = mbrtowc (&wc, (char *)buf+ch, cnt-ch, &mbstate);
+    if (k == -2 || k == -1)
+    {
+      dprint (1, (debugfile, "%s:%d: mbrtowc returned %d; errno = %d.\n",
+		  __FILE__, __LINE__, k, errno));
+      if (col + 4 > wrap_cols)
+	break;
+      col += 4;
+      if (pa)
+	printw ("\\%03o", buf[ch]);
+      k = 1;
+      continue;
+    }
+    if (k == 0)
+      k = 1;
+
+    if (Charset_is_utf8 && (wc == 0x200B || wc == 0xFEFF))
+    {
+	dprint (3, (debugfile, "skip zero-width character U+%04X\n", (unsigned short)wc));
+	continue;
+    }
+
+    /* Handle backspace */
+    special = 0;
+    if (IsWPrint (wc))
+    {
+      wchar_t wc1;
+      mbstate_t mbstate1;
+      int k1, k2;
+
+      while ((wc1 = 0, mbstate1 = mbstate,
+	      k1 = k + mbrtowc (&wc1, (char *)buf+ch+k, cnt-ch-k, &mbstate1),
+	      k1 - k > 0 && wc1 == '\b') &&
+	     (wc1 = 0,
+	      k2 = mbrtowc (&wc1, (char *)buf+ch+k1, cnt-ch-k1, &mbstate1),
+	      k2 > 0 && IsWPrint (wc1)))
+      {
+	if (wc == wc1)
+	{
+	  special |= (wc == '_' && special & A_UNDERLINE)
+	    ? A_UNDERLINE : A_BOLD;
+	}
+	else if (wc == '_' || wc1 == '_')
+	{
+	  special |= A_UNDERLINE;
+	  wc = (wc1 == '_') ? wc : wc1;
+	}
+	else
+	{
+	  /* special = 0; / * overstrike: nothing to do! */
+	  wc = wc1;
+	}
+	ch += k1;
+	k = k2;
+	mbstate = mbstate1;
+      }
+    }
+
+    if (pa &&
+	((flags & (M_SHOWCOLOR | M_SEARCH | M_PAGER_MARKER)) ||
+	 special || last_special || pa->attr))
+    {
+      resolve_color (*lineInfo, n, vch, flags, special, pa);
+      last_special = special;
+    }
+
+    if (IsWPrint (wc))
+    {
+      if (wc == ' ')
+	space = ch;
+      t = wcwidth (wc);
+      if (col + t > wrap_cols)
+	break;
+      col += t;
+      if (pa)
+	mutt_addwch (wc);
+    }
+    else if (wc == '\n')
+      break;
+    else if (wc == '\t')
+    {
+      space = ch;
+      t = (col & ~7) + 8;
+      if (t > wrap_cols)
+	break;
+      if (pa)
+	for (; col < t; col++)
+	  addch (' ');
+      else
+	col = t;
+    }
+    else if (wc < 0x20 || wc == 0x7f)
+    {
+      if (col + 2 > wrap_cols)
+	break;
+      col += 2;
+      if (pa)
+	printw ("^%c", ('@' + wc) & 0x7f);
+    }
+    else if (wc < 0x100)
+    {
+      if (col + 4 > wrap_cols)
+	break;
+      col += 4;
+      if (pa)
+	printw ("\\%03o", wc);
+    }
+    else
+    {
+      if (col + 1 > wrap_cols)
+	break;
+      ++col;
+      if (pa)
+	addch (replacement_char ());
+    }
+  }
+  *pspace = space;
+  *pcol = col;
+  *pvch = vch;
+  *pspecial = special;
+  return ch;
+}
+
+/*
+ * Args:
+ *	flags	M_SHOWFLAT, show characters (used for displaying help)
+ *		M_SHOWCOLOR, show characters in color
+ *			otherwise don't show characters
+ *		M_HIDE, don't show quoted text
+ *		M_SEARCH, resolve search patterns
+ *		M_TYPES, compute line's type
+ *		M_PAGER_NSKIP, keeps leading whitespace
+ *		M_PAGER_MARKER, eventually show markers
+ *
+ * Return values:
+ *	-1	EOF was reached
+ *	0	normal exit, line was not displayed
+ *	>0	normal exit, line was displayed
+ */
+
+static int
+display_line (FILE *f, LOFF_T *last_pos, struct line_t **lineInfo, int n, 
+	      int *last, int *max, int flags, struct q_class_t **QuoteList,
+	      int *q_level, int *force_redraw, regex_t *SearchRE)
+{
+  unsigned char *buf = NULL, *fmt = NULL;
+  size_t buflen = 0;
+  unsigned char *buf_ptr = buf;
+  int ch, vch, col, cnt, b_read;
+  int buf_ready = 0, change_last = 0;
+  int special;
+  int offset;
+  int def_color;
+  int m;
+  int rc = -1;
+  ansi_attr a = {0,0,0,-1};
+  regmatch_t pmatch[1];
+
+  if (n == *last)
+  {
+    (*last)++;
+    change_last = 1;
+  }
+
+  if (*last == *max)
+  {
+    safe_realloc (lineInfo, sizeof (struct line_t) * (*max += LINES));
+    for (ch = *last; ch < *max ; ch++)
+    {
+      memset (&((*lineInfo)[ch]), 0, sizeof (struct line_t));
+      (*lineInfo)[ch].type = -1;
+      (*lineInfo)[ch].search_cnt = -1;
+      (*lineInfo)[ch].syntax = safe_malloc (sizeof (struct syntax_t));
+      ((*lineInfo)[ch].syntax)[0].first = ((*lineInfo)[ch].syntax)[0].last = -1;
+    }
+  }
+
+  /* only do color hiliting if we are viewing a message */
+  if (flags & (M_SHOWCOLOR | M_TYPES))
+  {
+    if ((*lineInfo)[n].type == -1)
+    {
+      /* determine the line class */
+      if (fill_buffer (f, last_pos, (*lineInfo)[n].offset, &buf, &fmt, &buflen, &buf_ready) < 0)
+      {
+	if (change_last)
+	  (*last)--;
+	goto out;
+      }
+
+      resolve_types ((char *) fmt, (char *) buf, *lineInfo, n, *last,
+		      QuoteList, q_level, force_redraw, flags & M_SHOWCOLOR);
+
+      /* avoid race condition for continuation lines when scrolling up */
+      for (m = n + 1; m < *last && (*lineInfo)[m].offset && (*lineInfo)[m].continuation; m++)
+	(*lineInfo)[m].type = (*lineInfo)[n].type;
+    }
+
+    /* this also prevents searching through the hidden lines */
+    if ((flags & M_HIDE) && (*lineInfo)[n].type == MT_COLOR_QUOTED)
+      flags = 0; /* M_NOSHOW */
+  }
+
+  /* At this point, (*lineInfo[n]).quote may still be undefined. We 
+   * don't want to compute it every time M_TYPES is set, since this
+   * would slow down the "bottom" function unacceptably. A compromise
+   * solution is hence to call regexec() again, just to find out the
+   * length of the quote prefix.
+   */
+  if ((flags & M_SHOWCOLOR) && !(*lineInfo)[n].continuation &&
+      (*lineInfo)[n].type == MT_COLOR_QUOTED && (*lineInfo)[n].quote == NULL)
+  {
+    if (fill_buffer (f, last_pos, (*lineInfo)[n].offset, &buf, &fmt, &buflen, &buf_ready) < 0)
+    {
+      if (change_last)
+	(*last)--;
+      goto out;
+    }
+    regexec ((regex_t *) QuoteRegexp.rx, (char *) fmt, 1, pmatch, 0);
+    (*lineInfo)[n].quote = classify_quote (QuoteList,
+			    (char *) fmt + pmatch[0].rm_so,
+			    pmatch[0].rm_eo - pmatch[0].rm_so,
+			    force_redraw, q_level);
+  }
+
+  if ((flags & M_SEARCH) && !(*lineInfo)[n].continuation && (*lineInfo)[n].search_cnt == -1) 
+  {
+    if (fill_buffer (f, last_pos, (*lineInfo)[n].offset, &buf, &fmt, &buflen, &buf_ready) < 0)
+    {
+      if (change_last)
+	(*last)--;
+      goto out;
+    }
+
+    offset = 0;
+    (*lineInfo)[n].search_cnt = 0;
+    while (regexec (SearchRE, (char *) fmt + offset, 1, pmatch, (offset ? REG_NOTBOL : 0)) == 0)
+    {
+      if (++((*lineInfo)[n].search_cnt) > 1)
+	safe_realloc (&((*lineInfo)[n].search),
+		      ((*lineInfo)[n].search_cnt) * sizeof (struct syntax_t));
+      else
+	(*lineInfo)[n].search = safe_malloc (sizeof (struct syntax_t));
+      pmatch[0].rm_so += offset;
+      pmatch[0].rm_eo += offset;
+      ((*lineInfo)[n].search)[(*lineInfo)[n].search_cnt - 1].first = pmatch[0].rm_so;
+      ((*lineInfo)[n].search)[(*lineInfo)[n].search_cnt - 1].last = pmatch[0].rm_eo;
+
+      if (pmatch[0].rm_eo == pmatch[0].rm_so)
+	offset++; /* avoid degenerate cases */
+      else
+	offset = pmatch[0].rm_eo;
+      if (!fmt[offset])
+	break;
+    }
+  }
+
+  if (!(flags & M_SHOW) && (*lineInfo)[n+1].offset > 0)
+  {
+    /* we've already scanned this line, so just exit */
+    rc = 0;
+    goto out;
+  }
+  if ((flags & M_SHOWCOLOR) && *force_redraw && (*lineInfo)[n+1].offset > 0)
+  {
+    /* no need to try to display this line... */
+    rc = 1;
+    goto out; /* fake display */
+  }
+
+  if ((b_read = fill_buffer (f, last_pos, (*lineInfo)[n].offset, &buf, &fmt, 
+			     &buflen, &buf_ready)) < 0)
+  {
+    if (change_last)
+      (*last)--;
+    goto out;
+  }
+
+  /* now chose a good place to break the line */
+  cnt = format_line (lineInfo, n, buf, flags, 0, b_read, &ch, &vch, &col, &special);
+  buf_ptr = buf + cnt;
+
+  /* move the break point only if smart_wrap is set */
+  if (option (OPTWRAP))
+  {
+    if (cnt < b_read)
+    {
+      if (ch != -1 && buf[0] != ' ' && buf[0] != '\t' &&
+	  buf[cnt] != ' ' && buf[cnt] != '\t' && buf[cnt] != '\n' && buf[cnt] != '\r')
+      {
+	buf_ptr = buf + ch;
+	/* skip trailing blanks */
+	while (ch && (buf[ch] == ' ' || buf[ch] == '\t' || buf[ch] == '\r'))
+	  ch--;
+        /* a very long word with leading spaces causes infinite wrapping */
+        if ((!ch) && (flags & M_PAGER_NSKIP))
+          buf_ptr = buf + cnt;
+        else
+          cnt = ch + 1;
+      }
+      else
+	buf_ptr = buf + cnt; /* a very long word... */
+    }
+    if (!(flags & M_PAGER_NSKIP))
+      /* skip leading blanks on the next line too */
+      while (*buf_ptr == ' ' || *buf_ptr == '\t') 
+	buf_ptr++;
+  }
+
+  if (*buf_ptr == '\r')
+    buf_ptr++;
+  if (*buf_ptr == '\n')
+    buf_ptr++;
+
+  if ((int) (buf_ptr - buf) < b_read && !(*lineInfo)[n+1].continuation)
+    append_line (*lineInfo, n, (int) (buf_ptr - buf));
+  (*lineInfo)[n+1].offset = (*lineInfo)[n].offset + (long) (buf_ptr - buf);
+
+  /* if we don't need to display the line we are done */
+  if (!(flags & M_SHOW))
+  {
+    rc = 0;
+    goto out;
+  }
+
+  /* display the line */
+  format_line (lineInfo, n, buf, flags, &a, cnt, &ch, &vch, &col, &special);
+
+  /* avoid a bug in ncurses... */
+#ifndef USE_SLANG_CURSES
+  if (col == 0)
+  {
+    SETCOLOR (MT_COLOR_NORMAL);
+    addch (' ');
+  }
+#endif
+
+  /* end the last color pattern (needed by S-Lang) */
+  if (special || (col != COLS && (flags & (M_SHOWCOLOR | M_SEARCH))))
+    resolve_color (*lineInfo, n, vch, flags, 0, &a);
+          
+  /*
+   * Fill the blank space at the end of the line with the prevailing color.
+   * ncurses does an implicit clrtoeol() when you do addch('\n') so we have
+   * to make sure to reset the color *after* that
+   */
+  if (flags & M_SHOWCOLOR)
+  {
+    m = ((*lineInfo)[n].continuation) ? ((*lineInfo)[n].syntax)[0].first : n;
+    if ((*lineInfo)[m].type == MT_COLOR_HEADER)
+      def_color = ((*lineInfo)[m].syntax)[0].color;
+    else
+      def_color = ColorDefs[ (*lineInfo)[m].type ];
+
+    attrset (def_color);
+#ifdef HAVE_BKGDSET
+    bkgdset (def_color | ' ');
+#endif
+  }
+
+  /* ncurses always wraps lines when you get to the right side of the
+   * screen, but S-Lang seems to only wrap if the next character is *not*
+   * a newline (grr!).
+   */
+#ifndef USE_SLANG_CURSES
+    if (col < COLS)
+#endif
+      addch ('\n');
+
+  /*
+   * reset the color back to normal.  This *must* come after the
+   * addch('\n'), otherwise the color for this line will not be
+   * filled to the right margin.
+   */
+  if (flags & M_SHOWCOLOR)
+  {
+    SETCOLOR(MT_COLOR_NORMAL);
+    BKGDSET(MT_COLOR_NORMAL);
+  }
+
+  /* build a return code */
+  if (!(flags & M_SHOW))
+    flags = 0;
+
+  rc = flags;
+
+out:
+  FREE(&buf);
+  FREE(&fmt);
+  return rc;
+}
+
+static int
+upNLines (int nlines, struct line_t *info, int cur, int hiding)
+{
+  while (cur > 0 && nlines > 0)
+  {
+    cur--;
+    if (!hiding || info[cur].type != MT_COLOR_QUOTED)
+      nlines--;
+  }
+
+  return cur;
+}
+
+static struct mapping_t PagerHelp[] = {
+  { N_("Exit"),	OP_EXIT },
+  { N_("PrevPg"), OP_PREV_PAGE },
+  { N_("NextPg"), OP_NEXT_PAGE },
+  { NULL,	0 }
+};
+static struct mapping_t PagerHelpExtra[] = {
+  { N_("View Attachm."), OP_VIEW_ATTACHMENTS },
+  { N_("Del"), OP_DELETE },
+  { N_("Reply"), OP_REPLY },
+  { N_("Next"),	OP_MAIN_NEXT_UNDELETED },
+  { NULL,	0 }
+};
+
+
+
+/* This pager is actually not so simple as it once was.  It now operates in
+   two modes: one for viewing messages and the other for viewing help.  These
+   can be distinguished by whether or not ``hdr'' is NULL.  The ``hdr'' arg
+   is there so that we can do operations on the current message without the
+   need to pop back out to the main-menu.  */
+int 
+mutt_pager (const char *banner, const char *fname, int flags, pager_t *extra)
+{
+  static char searchbuf[STRING] = "";
+  char buffer[LONG_STRING];
+  char helpstr[SHORT_STRING*2];
+  char tmphelp[SHORT_STRING*2];
+  int maxLine, lastLine = 0;
+  struct line_t *lineInfo;
+  struct q_class_t *QuoteList = NULL;
+  int i, j, ch = 0, rc = -1, hideQuoted = 0, q_level = 0, force_redraw = 0;
+  int lines = 0, curline = 0, topline = 0, oldtopline = 0, err, first = 1;
+  int r = -1, wrapped = 0, searchctx = 0;
+  int redraw = REDRAW_FULL;
+  FILE *fp = NULL;
+  LOFF_T last_pos = 0, last_offset = 0;
+  int old_smart_wrap, old_markers;
+  struct stat sb;
+  regex_t SearchRE;
+  int SearchCompiled = 0, SearchFlag = 0, SearchBack = 0;
+  int has_types = (IsHeader(extra) || (flags & M_SHOWCOLOR)) ? M_TYPES : 0; /* main message or rfc822 attachment */
+
+  int bodyoffset = 1;			/* offset of first line of real text */
+  int statusoffset = 0; 		/* offset for the status bar */
+  int helpoffset = LINES - 2;		/* offset for the help bar. */
+  int bodylen = LINES - 2 - bodyoffset; /* length of displayable area */
+
+  MUTTMENU *index = NULL;		/* the Pager Index (PI) */
+  int indexoffset = 0;			/* offset for the PI */
+  int indexlen = PagerIndexLines;	/* indexlen not always == PIL */
+  int indicator = indexlen / 3; 	/* the indicator line of the PI */
+  int old_PagerIndexLines;		/* some people want to resize it
+  					 * while inside the pager... */
+
+  if (!(flags & M_SHOWCOLOR))
+    flags |= M_SHOWFLAT;
+
+  if ((fp = fopen (fname, "r")) == NULL)
+  {
+    mutt_perror (fname);
+    return (-1);
+  }
+
+  if (stat (fname, &sb) != 0)
+  {
+    mutt_perror (fname);
+    safe_fclose (&fp);
+    return (-1);
+  }
+  unlink (fname);
+
+  /* Initialize variables */
+
+  if (IsHeader (extra) && !extra->hdr->read)
+  {
+    Context->msgnotreadyet = extra->hdr->msgno;
+    mutt_set_flag (Context, extra->hdr, M_READ, 1);
+  }
+
+  lineInfo = safe_malloc (sizeof (struct line_t) * (maxLine = LINES));
+  for (i = 0 ; i < maxLine ; i++)
+  {
+    memset (&lineInfo[i], 0, sizeof (struct line_t));
+    lineInfo[i].type = -1;
+    lineInfo[i].search_cnt = -1;
+    lineInfo[i].syntax = safe_malloc (sizeof (struct syntax_t));
+    (lineInfo[i].syntax)[0].first = (lineInfo[i].syntax)[0].last = -1;
+  }
+
+  mutt_compile_help (helpstr, sizeof (helpstr), MENU_PAGER, PagerHelp);
+  if (IsHeader (extra))
+  {
+    strfcpy (tmphelp, helpstr, sizeof (tmphelp));
+    mutt_compile_help (buffer, sizeof (buffer), MENU_PAGER, PagerHelpExtra);
+    snprintf (helpstr, sizeof (helpstr), "%s %s", tmphelp, buffer);
+  }
+  if (!InHelp)
+  {
+    strfcpy (tmphelp, helpstr, sizeof (tmphelp));
+    mutt_make_help (buffer, sizeof (buffer), _("Help"), MENU_PAGER, OP_HELP);
+    snprintf (helpstr, sizeof (helpstr), "%s %s", tmphelp, buffer);
+  }
+
+  while (ch != -1)
+  {
+    mutt_curs_set (0);
+
+    if (redraw & REDRAW_FULL)
+    {
+      SETCOLOR (MT_COLOR_NORMAL);
+      /* clear() doesn't optimize screen redraws */
+      move (0, 0);
+      clrtobot ();
+
+      if (IsHeader (extra) && Context->vcount + 1 < PagerIndexLines)
+	indexlen = Context->vcount + 1;
+      else
+	indexlen = PagerIndexLines;
+
+      indicator = indexlen / 3;
+
+      if (option (OPTSTATUSONTOP))
+      {
+	indexoffset = 0;
+	statusoffset = IsHeader (extra) ? indexlen : 0;
+	bodyoffset = statusoffset + 1;
+	helpoffset = LINES - 2;
+	bodylen = helpoffset - bodyoffset;
+	if (!option (OPTHELP))
+	  bodylen++;
+      }
+      else
+      {
+	helpoffset = 0;
+	indexoffset = 1;
+	statusoffset = LINES - 2;
+	if (!option (OPTHELP))
+	  indexoffset = 0;
+	bodyoffset = indexoffset + (IsHeader (extra) ? indexlen : 0);
+	bodylen = statusoffset - bodyoffset;
+      }
+
+      if (option (OPTHELP))
+      {
+	SETCOLOR (MT_COLOR_STATUS);
+	move (helpoffset, 0);
+	mutt_paddstr (COLS, helpstr);
+	SETCOLOR (MT_COLOR_NORMAL);
+      }
+
+#if defined (USE_SLANG_CURSES) || defined (HAVE_RESIZETERM)
+      if (Resize != NULL)
+      {
+	if ((SearchCompiled = Resize->SearchCompiled))
+	{
+	  REGCOMP
+	    (&SearchRE, searchbuf, REG_NEWLINE | mutt_which_case (searchbuf));
+	  SearchFlag = M_SEARCH;
+	  SearchBack = Resize->SearchBack;
+	}
+	lines = Resize->line;
+	redraw |= REDRAW_SIGWINCH;
+
+	FREE (&Resize);
+      }
+#endif
+
+      if (IsHeader (extra) && PagerIndexLines)
+      {
+	if (index == NULL)
+	{
+	  /* only allocate the space if/when we need the index.
+	     Initialise the menu as per the main index */
+	  index = mutt_new_menu(MENU_MAIN);
+	  index->make_entry = index_make_entry;
+	  index->color = index_color;
+	  index->max = Context->vcount;
+	  index->current = extra->hdr->virtual;
+	}
+
+	SETCOLOR (MT_COLOR_NORMAL);
+	index->offset  = indexoffset + (option (OPTSTATUSONTOP) ? 1 : 0);
+
+	index->pagelen = indexlen - 1;
+
+	/* some fudge to work out where abouts the indicator should go */
+	if (index->current - indicator < 0)
+	  index->top = 0;
+	else if (index->max - index->current < index->pagelen - indicator)
+	  index->top = index->max - index->pagelen;
+	else
+	  index->top = index->current - indicator;
+
+	menu_redraw_index(index);
+      }
+
+      redraw |= REDRAW_BODY | REDRAW_INDEX | REDRAW_STATUS;
+      mutt_show_error ();
+    }
+
+    if (redraw & REDRAW_SIGWINCH)
+    {
+      i = -1;
+      j = -1;
+      while (display_line (fp, &last_pos, &lineInfo, ++i, &lastLine, &maxLine,
+	     has_types | SearchFlag | (flags & M_PAGER_NOWRAP), &QuoteList, &q_level, &force_redraw,
+	     &SearchRE) == 0)
+	if (!lineInfo[i].continuation && ++j == lines)
+	{
+	  topline = i;
+	  if (!SearchFlag)
+	    break;
+	}
+    }
+
+    if ((redraw & REDRAW_BODY) || topline != oldtopline)
+    {
+      do {
+	move (bodyoffset, SidebarWidth);
+	curline = oldtopline = topline;
+	lines = 0;
+	force_redraw = 0;
+
+	while (lines < bodylen && lineInfo[curline].offset <= sb.st_size - 1)
+	{
+	  if (display_line (fp, &last_pos, &lineInfo, curline, &lastLine, 
+			    &maxLine,
+			    (flags & M_DISPLAYFLAGS) | hideQuoted | SearchFlag | (flags & M_PAGER_NOWRAP),
+			    &QuoteList, &q_level, &force_redraw, &SearchRE) > 0)
+	    lines++;
+	  curline++;
+  	  move(lines + bodyoffset, SidebarWidth);
+	}
+	last_offset = lineInfo[curline].offset;
+      } while (force_redraw);
+
+      SETCOLOR (MT_COLOR_TILDE);
+      BKGDSET (MT_COLOR_TILDE);
+      while (lines < bodylen)
+      {
+	clrtoeol ();
+	if (option (OPTTILDE))
+	  addch ('~');
+	addch ('\n');
+	lines++;
+  	move(lines + bodyoffset, SidebarWidth);
+      }
+      /* We are going to update the pager status bar, so it isn't
+       * necessary to reset to normal color now. */
+
+      redraw |= REDRAW_STATUS; /* need to update the % seen */
+    }
+
+    if (redraw & REDRAW_STATUS)
+    {
+      struct hdr_format_info hfi;
+      char pager_progress_str[4];
+
+      hfi.ctx = Context;
+      hfi.pager_progress = pager_progress_str;
+
+      if (last_pos < sb.st_size - 1)
+	snprintf(pager_progress_str, sizeof(pager_progress_str), OFF_T_FMT "%%", (100 * last_offset / sb.st_size));
+      else
+	strfcpy(pager_progress_str, (topline == 0) ? "all" : "end", sizeof(pager_progress_str));
+
+      /* print out the pager status bar */
+      SETCOLOR (MT_COLOR_STATUS);
+      BKGDSET (MT_COLOR_STATUS);
+      CLEARLINE_WIN (statusoffset);
+
+      if (IsHeader (extra) || IsMsgAttach (extra))
+      {
+	size_t l1 = (COLS-SidebarWidth) * MB_LEN_MAX;
+	size_t l2 = sizeof (buffer);
+	hfi.hdr = (IsHeader (extra)) ? extra->hdr : extra->bdy->hdr;
+	mutt_make_string_info (buffer, l1 < l2 ? l1 : l2, NONULL (PagerFmt), &hfi, M_FORMAT_MAKEPRINT);
+	mutt_paddstr (COLS-SidebarWidth, buffer);
+      }
+      else
+      {
+	char bn[STRING];
+	snprintf (bn, sizeof (bn), "%s (%s)", banner, pager_progress_str);
+	mutt_paddstr (COLS-SidebarWidth, bn);
+      }
+      BKGDSET (MT_COLOR_NORMAL);
+      SETCOLOR (MT_COLOR_NORMAL);
+    }
+
+    if ((redraw & REDRAW_INDEX) && index)
+    {
+      /* redraw the pager_index indicator, because the
+       * flags for this message might have changed. */
+      menu_redraw_current (index);
+      draw_sidebar(MENU_PAGER);
+
+      /* print out the index status bar */
+      menu_status_line (buffer, sizeof (buffer), index, NONULL(Status));
+ 
+      move (indexoffset + (option (OPTSTATUSONTOP) ? 0 : (indexlen - 1)), SidebarWidth);
+      SETCOLOR (MT_COLOR_STATUS);
+      BKGDSET (MT_COLOR_STATUS);
+      mutt_paddstr (COLS-SidebarWidth, buffer);
+      SETCOLOR (MT_COLOR_NORMAL);
+      BKGDSET (MT_COLOR_NORMAL);
+    }
+
+    /* if we're not using the index, update every time */
+    if ( index == 0 )
+      draw_sidebar(MENU_PAGER);
+
+    redraw = 0;
+
+    if (option(OPTBRAILLEFRIENDLY)) {
+      if (brailleLine!=-1) {
+        move(brailleLine+1, 0);
+        brailleLine = -1;
+      }
+    } else move (statusoffset, COLS-1);
+    mutt_refresh ();
+
+    if (IsHeader (extra) && OldHdr == extra->hdr && TopLine != topline
+        && lineInfo[curline].offset < sb.st_size-1)
+    {
+      if (TopLine - topline > lines)
+        topline += lines;
+      else
+        topline = TopLine;
+      continue;
+    }
+    else
+      OldHdr = NULL;
+      
+    ch = km_dokey (MENU_PAGER);
+    if (ch != -1)
+      mutt_clear_error ();
+    mutt_curs_set (1);
+
+    if (SigInt)
+    {
+      mutt_query_exit ();
+      continue;
+    }
+#if defined (USE_SLANG_CURSES) || defined (HAVE_RESIZETERM)
+    else if (SigWinch)
+    {
+      mutt_resize_screen ();
+
+      /* Store current position. */
+      lines = -1;
+      for (i = 0; i <= topline; i++)
+	if (!lineInfo[i].continuation)
+	  lines++;
+
+      if (flags & M_PAGER_RETWINCH)
+      {
+	Resize = safe_malloc (sizeof (struct resize));
+
+	Resize->line = lines;
+	Resize->SearchCompiled = SearchCompiled;
+	Resize->SearchBack = SearchBack;
+
+	ch = -1;
+	rc = OP_REFORMAT_WINCH;
+      }
+      else
+      {
+	for (i = 0; i < maxLine; i++)
+	{
+	  lineInfo[i].offset = 0;
+	  lineInfo[i].type = -1;
+	  lineInfo[i].continuation = 0;
+	  lineInfo[i].chunks = 0;
+	  lineInfo[i].search_cnt = -1;
+	  lineInfo[i].quote = NULL;
+
+	  safe_realloc (&(lineInfo[i].syntax),
+			sizeof (struct syntax_t));
+	  if (SearchCompiled && lineInfo[i].search)
+	      FREE (&(lineInfo[i].search));
+	}
+
+	lastLine = 0;
+	topline = 0;
+
+	redraw = REDRAW_FULL | REDRAW_SIGWINCH;
+	ch = 0;
+      }
+
+      SigWinch = 0;
+      clearok(stdscr,TRUE);/*force complete redraw*/
+      continue;
+    }
+#endif
+    else if (ch == -1)
+    {
+      ch = 0;
+      continue;
+    }
+
+    rc = ch;
+
+    switch (ch)
+    {
+      case OP_EXIT:
+	rc = -1;
+	ch = -1;
+	break;
+
+      case OP_NEXT_PAGE:
+	if (lineInfo[curline].offset < sb.st_size-1)
+	{
+	  topline = upNLines (PagerContext, lineInfo, curline, hideQuoted);
+	}
+	else if (option (OPTPAGERSTOP))
+	{
+	  /* emulate "less -q" and don't go on to the next message. */
+	  mutt_error _("Bottom of message is shown.");
+	}
+	else
+	{
+	  /* end of the current message, so display the next message. */
+	  rc = OP_MAIN_NEXT_UNDELETED;
+	  ch = -1;
+	}
+	break;
+
+      case OP_PREV_PAGE:
+	if (topline != 0)
+	{
+	  topline = upNLines (bodylen-PagerContext, lineInfo, topline, hideQuoted);
+	}
+	else
+	  mutt_error _("Top of message is shown.");
+	break;
+
+      case OP_NEXT_LINE:
+	if (lineInfo[curline].offset < sb.st_size-1)
+	{
+	  topline++;
+	  if (hideQuoted)
+	  {
+	    while (lineInfo[topline].type == MT_COLOR_QUOTED &&
+		   topline < lastLine)
+	      topline++;
+	  }
+	}
+	else
+	  mutt_error _("Bottom of message is shown.");
+	break;
+
+      case OP_PREV_LINE:
+	if (topline)
+	  topline = upNLines (1, lineInfo, topline, hideQuoted);
+	else
+	  mutt_error _("Top of message is shown.");
+	break;
+
+      case OP_PAGER_TOP:
+        if (topline)
+	  topline = 0;
+      	else
+	  mutt_error _("Top of message is shown.");
+	break;
+
+      case OP_HALF_UP:
+	if (topline)
+	  topline = upNLines (bodylen/2, lineInfo, topline, hideQuoted);
+	else
+	  mutt_error _("Top of message is shown.");
+	break;
+
+      case OP_HALF_DOWN:
+	if (lineInfo[curline].offset < sb.st_size-1)
+	{
+	  topline = upNLines (bodylen/2, lineInfo, curline, hideQuoted);
+	}
+	else if (option (OPTPAGERSTOP))
+	{
+	  /* emulate "less -q" and don't go on to the next message. */
+	  mutt_error _("Bottom of message is shown.");
+	}
+	else
+	{
+	  /* end of the current message, so display the next message. */
+	  rc = OP_MAIN_NEXT_UNDELETED;
+	  ch = -1;
+	}
+	break;
+
+      case OP_SEARCH_NEXT:
+      case OP_SEARCH_OPPOSITE:
+	if (SearchCompiled)
+	{
+	  wrapped = 0;
+
+	  if (SearchContext > 0 && SearchContext < LINES - 2 - option (OPTHELP) ? 1 : 0)
+	    searchctx = SearchContext;
+	  else
+	    searchctx = 0;
+
+search_next:
+	  if ((!SearchBack && ch==OP_SEARCH_NEXT) ||
+	      (SearchBack &&ch==OP_SEARCH_OPPOSITE))
+	  {
+	    /* searching forward */
+	    for (i = wrapped ? 0 : topline + searchctx + 1; i < lastLine; i++)
+	    {
+	      if ((!hideQuoted || lineInfo[i].type != MT_COLOR_QUOTED) && 
+		    !lineInfo[i].continuation && lineInfo[i].search_cnt > 0)
+		break;
+	    }
+
+	    if (i < lastLine)
+	      topline = i;
+	    else if (wrapped || !option (OPTWRAPSEARCH))
+	      mutt_error _("Not found.");
+	    else
+	    {
+	      mutt_message _("Search wrapped to top.");
+	      wrapped = 1;
+	      goto search_next;
+	    }
+	  }
+	  else
+	  {
+	    /* searching backward */
+	    for (i = wrapped ? lastLine : topline + searchctx - 1; i >= 0; i--)
+	    {
+	      if ((!hideQuoted || (has_types && 
+		    lineInfo[i].type != MT_COLOR_QUOTED)) && 
+		    !lineInfo[i].continuation && lineInfo[i].search_cnt > 0)
+		break;
+	    }
+
+	    if (i >= 0)
+	      topline = i;
+	    else if (wrapped || !option (OPTWRAPSEARCH))
+	      mutt_error _("Not found.");
+	    else
+	    {
+	      mutt_message _("Search wrapped to bottom.");
+	      wrapped = 1;
+	      goto search_next;
+	    }
+	  }
+
+	  if (lineInfo[topline].search_cnt > 0)
+	  {
+	    SearchFlag = M_SEARCH;
+	    /* give some context for search results */
+	    if (topline - searchctx > 0)
+	      topline -= searchctx;
+	  }
+
+	  break;
+	}
+	/* no previous search pattern, so fall through to search */
+
+      case OP_SEARCH:
+      case OP_SEARCH_REVERSE:
+        strfcpy (buffer, searchbuf, sizeof (buffer));
+	if (mutt_get_field ((ch == OP_SEARCH || ch == OP_SEARCH_NEXT) ?
+			    _("Search for: ") : _("Reverse search for: "),
+			    buffer, sizeof (buffer),
+			    M_CLEAR) != 0)
+	  break;
+
+	if (!strcmp (buffer, searchbuf))
+	{
+	  if (SearchCompiled)
+	  {
+	    /* do an implicit search-next */
+	    if (ch == OP_SEARCH)
+	      ch = OP_SEARCH_NEXT;
+	    else
+	      ch = OP_SEARCH_OPPOSITE;
+
+	    wrapped = 0;
+	    goto search_next;
+	  }
+	}
+      
+        if (!buffer[0])
+	  break;
+      
+	strfcpy (searchbuf, buffer, sizeof (searchbuf));
+
+	/* leave SearchBack alone if ch == OP_SEARCH_NEXT */
+	if (ch == OP_SEARCH)
+	  SearchBack = 0;
+	else if (ch == OP_SEARCH_REVERSE)
+	  SearchBack = 1;
+
+	if (SearchCompiled)
+	{
+	  regfree (&SearchRE);
+	  for (i = 0; i < lastLine; i++)
+	  {
+	    if (lineInfo[i].search)
+	      FREE (&(lineInfo[i].search));
+	    lineInfo[i].search_cnt = -1;
+	  }
+	}
+
+	if ((err = REGCOMP (&SearchRE, searchbuf, REG_NEWLINE | mutt_which_case (searchbuf))) != 0)
+	{
+	  regerror (err, &SearchRE, buffer, sizeof (buffer));
+	  mutt_error ("%s", buffer);
+	  for (i = 0; i < maxLine ; i++)
+	  {
+	    /* cleanup */
+	    if (lineInfo[i].search)
+	      FREE (&(lineInfo[i].search));
+	    lineInfo[i].search_cnt = -1;
+	  }
+	  SearchFlag = 0;
+	  SearchCompiled = 0;
+	}
+	else
+	{
+	  SearchCompiled = 1;
+	  /* update the search pointers */
+	  i = 0;
+	  while (display_line (fp, &last_pos, &lineInfo, i, &lastLine, 
+				&maxLine, M_SEARCH | (flags & M_PAGER_NSKIP) | (flags & M_PAGER_NOWRAP),
+				&QuoteList, &q_level,
+				&force_redraw, &SearchRE) == 0)
+	    i++;
+
+	  if (!SearchBack)
+	  {
+	    /* searching forward */
+	    for (i = topline; i < lastLine; i++)
+	    {
+	      if ((!hideQuoted || lineInfo[i].type != MT_COLOR_QUOTED) && 
+		    !lineInfo[i].continuation && lineInfo[i].search_cnt > 0)
+		break;
+	    }
+
+	    if (i < lastLine) topline = i;
+	  }
+	  else
+	  {
+	    /* searching backward */
+	    for (i = topline; i >= 0; i--)
+	    {
+	      if ((!hideQuoted || lineInfo[i].type != MT_COLOR_QUOTED) && 
+		    !lineInfo[i].continuation && lineInfo[i].search_cnt > 0)
+		break;
+	    }
+
+	    if (i >= 0) topline = i;
+	  }
+
+	  if (lineInfo[topline].search_cnt == 0)
+	  {
+	    SearchFlag = 0;
+	    mutt_error _("Not found.");
+	  }
+	  else
+	  {
+	    SearchFlag = M_SEARCH;
+	    /* give some context for search results */
+	    if (SearchContext > 0 && SearchContext < LINES - 2 - option (OPTHELP) ? 1 : 0)
+	      searchctx = SearchContext;
+	    else
+	      searchctx = 0;
+	    if (topline - searchctx > 0)
+	      topline -= searchctx;
+	  }
+
+	}
+	redraw = REDRAW_BODY;
+	break;
+
+      case OP_SEARCH_TOGGLE:
+	if (SearchCompiled)
+	{
+	  SearchFlag ^= M_SEARCH;
+	  redraw = REDRAW_BODY;
+	}
+	break;
+
+      case OP_HELP:
+	/* don't let the user enter the help-menu from the help screen! */
+	if (! InHelp)
+	{
+	  InHelp = 1;
+	  mutt_help (MENU_PAGER);
+	  redraw = REDRAW_FULL;
+	  InHelp = 0;
+	}
+	else
+	  mutt_error _("Help is currently being shown.");
+	break;
+
+      case OP_PAGER_HIDE_QUOTED:
+	if (has_types)
+	{
+	  hideQuoted ^= M_HIDE;
+	  if (hideQuoted && lineInfo[topline].type == MT_COLOR_QUOTED)
+	    topline = upNLines (1, lineInfo, topline, hideQuoted);
+	  else
+	    redraw = REDRAW_BODY;
+	}
+	break;
+
+      case OP_PAGER_SKIP_QUOTED:
+	if (has_types)
+	{
+	  int dretval = 0;
+	  int new_topline = topline;
+
+	  while ((new_topline < lastLine ||
+		  (0 == (dretval = display_line (fp, &last_pos, &lineInfo,
+			 new_topline, &lastLine, &maxLine, M_TYPES | (flags & M_PAGER_NOWRAP),
+			 &QuoteList, &q_level, &force_redraw, &SearchRE))))
+		 && lineInfo[new_topline].type != MT_COLOR_QUOTED)
+	    new_topline++;
+
+	  if (dretval < 0)
+	  {
+	    mutt_error _("No more quoted text.");
+	    break;
+	  }
+
+	  while ((new_topline < lastLine ||
+		  (0 == (dretval = display_line (fp, &last_pos, &lineInfo,
+			 new_topline, &lastLine, &maxLine, M_TYPES | (flags & M_PAGER_NOWRAP),
+			 &QuoteList, &q_level, &force_redraw, &SearchRE))))
+		 && lineInfo[new_topline].type == MT_COLOR_QUOTED)
+	    new_topline++;
+
+	  if (dretval < 0)
+	  {
+	    mutt_error _("No more unquoted text after quoted text.");
+	    break;	  
+	  }
+	  topline = new_topline;
+	}
+	break;
+
+      case OP_PAGER_BOTTOM: /* move to the end of the file */
+	if (lineInfo[curline].offset < sb.st_size - 1)
+	{
+	  i = curline;
+	  /* make sure the types are defined to the end of file */
+	  while (display_line (fp, &last_pos, &lineInfo, i, &lastLine, 
+				&maxLine, has_types | (flags & M_PAGER_NOWRAP),
+				&QuoteList, &q_level, &force_redraw,
+				&SearchRE) == 0)
+	    i++;
+	  topline = upNLines (bodylen, lineInfo, lastLine, hideQuoted);
+	}
+	else
+	  mutt_error _("Bottom of message is shown.");
+	break;
+
+      case OP_REDRAW:
+	clearok (stdscr, TRUE);
+	redraw = REDRAW_FULL;
+	break;
+
+      case OP_NULL:
+	km_error_key (MENU_PAGER);
+	break;
+
+	/* --------------------------------------------------------------------
+	 * The following are operations on the current message rather than
+	 * adjusting the view of the message.
+	 */
+
+      case OP_BOUNCE_MESSAGE:
+	CHECK_MODE(IsHeader (extra) || IsMsgAttach (extra))
+        CHECK_ATTACH;
+        if (IsMsgAttach (extra))
+	  mutt_attach_bounce (extra->fp, extra->hdr,
+			      extra->idx, extra->idxlen,
+			      extra->bdy);
+        else
+          ci_bounce_message (extra->hdr, &redraw);
+	break;
+
+      case OP_RESEND:
+        CHECK_MODE(IsHeader (extra) || IsMsgAttach (extra))
+        CHECK_ATTACH;
+        if (IsMsgAttach (extra))
+	  mutt_attach_resend (extra->fp, extra->hdr,
+			      extra->idx, extra->idxlen,
+			      extra->bdy);
+        else
+	  mutt_resend_message (NULL, extra->ctx, extra->hdr);
+        redraw = REDRAW_FULL;
+        break;
+
+      case OP_CHECK_TRADITIONAL:
+        CHECK_MODE (IsHeader (extra));
+        if (!(WithCrypto & APPLICATION_PGP))
+	  break;
+        if (!(extra->hdr->security & PGP_TRADITIONAL_CHECKED)) 
+        {
+	  ch = -1;
+	  rc = OP_CHECK_TRADITIONAL;
+	}
+        break;
+      
+      case OP_CREATE_ALIAS:
+	CHECK_MODE(IsHeader (extra) || IsMsgAttach (extra));
+        if (IsMsgAttach (extra))
+	  mutt_create_alias (extra->bdy->hdr->env, NULL);
+        else
+	  mutt_create_alias (extra->hdr->env, NULL);
+	MAYBE_REDRAW (redraw);
+	break;
+
+      case OP_DELETE:
+	CHECK_MODE(IsHeader (extra));
+	CHECK_READONLY;
+	CHECK_ACL(M_ACL_DELETE, _("delete message"));
+
+	mutt_set_flag (Context, extra->hdr, M_DELETE, 1);
+        if (option (OPTDELETEUNTAG))
+	  mutt_set_flag (Context, extra->hdr, M_TAG, 0);
+	redraw = REDRAW_STATUS | REDRAW_INDEX;
+	if (option (OPTRESOLVE))
+	{
+	  ch = -1;
+	  rc = OP_MAIN_NEXT_UNDELETED;
+	}
+	break;
+
+      case OP_MAIN_SET_FLAG:
+      case OP_MAIN_CLEAR_FLAG:
+	CHECK_MODE(IsHeader (extra));
+	CHECK_READONLY;
+
+	if (mutt_change_flag (extra->hdr, (ch == OP_MAIN_SET_FLAG)) == 0)
+	  redraw |= REDRAW_STATUS | REDRAW_INDEX;
+	if (extra->hdr->deleted && option (OPTRESOLVE))
+	{
+	  ch = -1;
+	  rc = OP_MAIN_NEXT_UNDELETED;
+	}
+	break;
+
+      case OP_DELETE_THREAD:
+      case OP_DELETE_SUBTHREAD:
+	CHECK_MODE(IsHeader (extra));
+	CHECK_READONLY;
+	CHECK_ACL(M_ACL_DELETE, _("delete message(s)"));
+
+	r = mutt_thread_set_flag (extra->hdr, M_DELETE, 1,
+				  ch == OP_DELETE_THREAD ? 0 : 1);
+
+	if (r != -1)
+	{
+	  if (option (OPTDELETEUNTAG))
+	    mutt_thread_set_flag (extra->hdr, M_TAG, 0,
+				  ch == OP_DELETE_THREAD ? 0 : 1);
+	  if (option (OPTRESOLVE))
+	  {
+	    rc = OP_MAIN_NEXT_UNDELETED;
+	    ch = -1;
+	  }
+
+	  if (!option (OPTRESOLVE) && PagerIndexLines)
+	    redraw = REDRAW_FULL;
+	  else
+	    redraw = REDRAW_STATUS | REDRAW_INDEX;
+	}
+	break;
+
+      case OP_DISPLAY_ADDRESS:
+	CHECK_MODE(IsHeader (extra) || IsMsgAttach (extra));
+        if (IsMsgAttach (extra))
+	  mutt_display_address (extra->bdy->hdr->env);
+        else
+	  mutt_display_address (extra->hdr->env);
+	break;
+
+      case OP_ENTER_COMMAND:
+	old_smart_wrap = option (OPTWRAP);
+	old_markers = option (OPTMARKERS);
+	old_PagerIndexLines = PagerIndexLines;
+
+	CurrentMenu = MENU_PAGER;
+	mutt_enter_command ();
+
+	if (option (OPTNEEDRESORT))
+	{
+	  unset_option (OPTNEEDRESORT);
+	  CHECK_MODE(IsHeader (extra));
+	  set_option (OPTNEEDRESORT);
+	}
+
+	if (old_PagerIndexLines != PagerIndexLines)
+	{
+	  if (index)
+	    mutt_menuDestroy (&index);
+	  index = NULL;
+	}
+	
+	if (option (OPTWRAP) != old_smart_wrap || 
+	    option (OPTMARKERS) != old_markers)
+	{
+	  if (flags & M_PAGER_RETWINCH)
+	  {
+	    ch = -1;
+	    rc = OP_REFORMAT_WINCH;
+	    continue;
+	  }
+
+	  /* count the real lines above */
+	  j = 0;
+	  for (i = 0; i <= topline; i++)
+	  {
+	    if (!lineInfo[i].continuation)
+	      j++;
+	  }
+
+	  /* we need to restart the whole thing */
+	  for (i = 0; i < maxLine; i++)
+	  {
+	    lineInfo[i].offset = 0;
+	    lineInfo[i].type = -1;
+	    lineInfo[i].continuation = 0;
+	    lineInfo[i].chunks = 0;
+	    lineInfo[i].search_cnt = -1;
+	    lineInfo[i].quote = NULL;
+
+	    safe_realloc (&(lineInfo[i].syntax), sizeof (struct syntax_t));
+	    if (SearchCompiled && lineInfo[i].search)
+		FREE (&(lineInfo[i].search));
+	  }
+
+	  if (SearchCompiled)
+	  {
+	    regfree (&SearchRE);
+	    SearchCompiled = 0;
+	  }
+	  SearchFlag = 0;
+
+	  /* try to keep the old position */
+	  topline = 0;
+	  lastLine = 0;
+	  while (j > 0 && display_line (fp, &last_pos, &lineInfo, topline, 
+					&lastLine, &maxLine,
+					(has_types ? M_TYPES : 0) | (flags & M_PAGER_NOWRAP),
+					&QuoteList, &q_level, &force_redraw,
+					&SearchRE) == 0)
+	  {
+	    if (! lineInfo[topline].continuation)
+	      j--;
+	    if (j > 0)
+	      topline++;
+	  }
+
+	  ch = 0;
+	}
+
+	if (option (OPTFORCEREDRAWPAGER))
+	  redraw = REDRAW_FULL;
+	unset_option (OPTFORCEREDRAWINDEX);
+	unset_option (OPTFORCEREDRAWPAGER);
+	break;
+
+      case OP_FLAG_MESSAGE:
+	CHECK_MODE(IsHeader (extra));
+	CHECK_READONLY;
+	CHECK_ACL(M_ACL_WRITE, "flag message");
+
+	mutt_set_flag (Context, extra->hdr, M_FLAG, !extra->hdr->flagged);
+	redraw = REDRAW_STATUS | REDRAW_INDEX;
+	if (option (OPTRESOLVE))
+	{
+	  ch = -1;
+	  rc = OP_MAIN_NEXT_UNDELETED;
+	}
+	break;
+
+      case OP_PIPE:
+	CHECK_MODE(IsHeader (extra) || IsAttach (extra));
+	if (IsAttach (extra))
+	  mutt_pipe_attachment_list (extra->fp, 0, extra->bdy, 0);
+	else
+	  mutt_pipe_message (extra->hdr);
+	MAYBE_REDRAW (redraw);
+	break;
+
+      case OP_PRINT:
+	CHECK_MODE(IsHeader (extra) || IsAttach (extra));
+        if (IsAttach (extra))
+	  mutt_print_attachment_list (extra->fp, 0, extra->bdy);
+        else
+	  mutt_print_message (extra->hdr);
+	break;
+
+      case OP_MAIL:
+	CHECK_MODE(IsHeader (extra) && !IsAttach (extra));
+        CHECK_ATTACH;      
+	ci_send_message (0, NULL, NULL, extra->ctx, NULL);
+	redraw = REDRAW_FULL;
+	break;
+
+      case OP_REPLY:
+	CHECK_MODE(IsHeader (extra) || IsMsgAttach (extra));
+        CHECK_ATTACH;      
+        if (IsMsgAttach (extra)) 
+	  mutt_attach_reply (extra->fp, extra->hdr, extra->idx,
+			     extra->idxlen, extra->bdy,
+			     SENDREPLY);
+	else
+	  ci_send_message (SENDREPLY, NULL, NULL, extra->ctx, extra->hdr);
+	redraw = REDRAW_FULL;
+	break;
+
+      case OP_RECALL_MESSAGE:
+	CHECK_MODE(IsHeader (extra) && !IsAttach(extra));
+        CHECK_ATTACH;
+	ci_send_message (SENDPOSTPONED, NULL, NULL, extra->ctx, extra->hdr);
+	redraw = REDRAW_FULL;
+	break;
+
+      case OP_GROUP_REPLY:
+	CHECK_MODE(IsHeader (extra) || IsMsgAttach (extra));
+        CHECK_ATTACH;
+        if (IsMsgAttach (extra))
+	  mutt_attach_reply (extra->fp, extra->hdr, extra->idx,
+			     extra->idxlen, extra->bdy, SENDREPLY|SENDGROUPREPLY);
+        else
+	  ci_send_message (SENDREPLY | SENDGROUPREPLY, NULL, NULL, extra->ctx, extra->hdr);
+	redraw = REDRAW_FULL;
+	break;
+
+      case OP_LIST_REPLY:
+	CHECK_MODE(IsHeader (extra) || IsMsgAttach (extra));
+        CHECK_ATTACH;        
+        if (IsMsgAttach (extra))
+	  mutt_attach_reply (extra->fp, extra->hdr, extra->idx,
+			     extra->idxlen, extra->bdy, SENDREPLY|SENDLISTREPLY);
+        else
+	  ci_send_message (SENDREPLY | SENDLISTREPLY, NULL, NULL, extra->ctx, extra->hdr);
+	redraw = REDRAW_FULL;
+	break;
+
+      case OP_FORWARD_MESSAGE:
+	CHECK_MODE(IsHeader (extra) || IsMsgAttach (extra));
+        CHECK_ATTACH;
+        if (IsMsgAttach (extra))
+	  mutt_attach_forward (extra->fp, extra->hdr, extra->idx,
+			       extra->idxlen, extra->bdy);
+        else
+	  ci_send_message (SENDFORWARD, NULL, NULL, extra->ctx, extra->hdr);
+	redraw = REDRAW_FULL;
+	break;
+
+      case OP_DECRYPT_SAVE:
+        if (!WithCrypto)
+        {
+          ch = -1;
+          break;
+        }
+	/* fall through */
+      case OP_SAVE:
+	if (IsAttach (extra))
+	{
+	  mutt_save_attachment_list (extra->fp, 0, extra->bdy, extra->hdr, NULL);
+	  break;
+	}
+	/* fall through */
+      case OP_COPY_MESSAGE:
+      case OP_DECODE_SAVE:
+      case OP_DECODE_COPY:
+      case OP_DECRYPT_COPY:
+        if (!WithCrypto && ch == OP_DECRYPT_COPY)
+        {
+          ch = -1;
+          break;
+        }
+	CHECK_MODE(IsHeader (extra));
+	if (mutt_save_message (extra->hdr,
+			       (ch == OP_DECRYPT_SAVE) ||
+			       (ch == OP_SAVE) || (ch == OP_DECODE_SAVE),
+			       (ch == OP_DECODE_SAVE) || (ch == OP_DECODE_COPY),
+			       (ch == OP_DECRYPT_SAVE) || (ch == OP_DECRYPT_COPY) ||
+			       0,
+			       &redraw) == 0 && (ch == OP_SAVE || ch == OP_DECODE_SAVE
+						 || ch == OP_DECRYPT_SAVE
+						 ))
+	{
+	  if (option (OPTRESOLVE))
+	  {
+	    ch = -1;
+	    rc = OP_MAIN_NEXT_UNDELETED;
+	  }
+	  else
+	    redraw |= REDRAW_STATUS | REDRAW_INDEX;
+	}
+	MAYBE_REDRAW (redraw);
+	break;
+
+      case OP_SHELL_ESCAPE:
+	mutt_shell_escape ();
+	MAYBE_REDRAW (redraw);
+	break;
+
+      case OP_TAG:
+	CHECK_MODE(IsHeader (extra));
+	mutt_set_flag (Context, extra->hdr, M_TAG, !extra->hdr->tagged);
+
+	Context->last_tag = extra->hdr->tagged ? extra->hdr :
+	  ((Context->last_tag == extra->hdr && !extra->hdr->tagged)
+	   ? NULL : Context->last_tag);
+
+	redraw = REDRAW_STATUS | REDRAW_INDEX;
+	if (option (OPTRESOLVE))
+	{
+	  ch = -1;
+	  rc = OP_NEXT_ENTRY;
+	}
+	break;
+
+      case OP_TOGGLE_NEW:
+	CHECK_MODE(IsHeader (extra));
+	CHECK_READONLY;
+	CHECK_ACL(M_ACL_SEEN, _("toggle new"));
+
+	if (extra->hdr->read || extra->hdr->old)
+	  mutt_set_flag (Context, extra->hdr, M_NEW, 1);
+	else if (!first)
+	  mutt_set_flag (Context, extra->hdr, M_READ, 1);
+	first = 0;
+        Context->msgnotreadyet = -1;
+	redraw = REDRAW_STATUS | REDRAW_INDEX;
+	if (option (OPTRESOLVE))
+	{
+	  ch = -1;
+	  rc = OP_MAIN_NEXT_UNDELETED;
+	}
+	break;
+
+      case OP_UNDELETE:
+	CHECK_MODE(IsHeader (extra));
+	CHECK_READONLY;
+	CHECK_ACL(M_ACL_DELETE, _("undelete message"));
+
+	mutt_set_flag (Context, extra->hdr, M_DELETE, 0);
+	redraw = REDRAW_STATUS | REDRAW_INDEX;
+	if (option (OPTRESOLVE))
+	{
+	  ch = -1;
+	  rc = OP_NEXT_ENTRY;
+	}
+	break;
+
+      case OP_UNDELETE_THREAD:
+      case OP_UNDELETE_SUBTHREAD:
+	CHECK_MODE(IsHeader (extra));
+	CHECK_READONLY;
+	CHECK_ACL(M_ACL_DELETE, _("undelete message(s)"));
+
+	r = mutt_thread_set_flag (extra->hdr, M_DELETE, 0,
+				  ch == OP_UNDELETE_THREAD ? 0 : 1);
+
+	if (r != -1)
+	{
+	  if (option (OPTRESOLVE))
+	  {
+	    rc = (ch == OP_DELETE_THREAD) ?
+				  OP_MAIN_NEXT_THREAD : OP_MAIN_NEXT_SUBTHREAD;
+	    ch = -1;
+	  }
+
+	  if (!option (OPTRESOLVE) && PagerIndexLines)
+	    redraw = REDRAW_FULL;
+	  else
+	    redraw = REDRAW_STATUS | REDRAW_INDEX;
+	}
+	break;
+
+      case OP_VERSION:
+	mutt_version ();
+	break;
+
+      case OP_BUFFY_LIST:
+	mutt_buffy_list ();
+	break;
+
+      case OP_VIEW_ATTACHMENTS:
+        if (flags & M_PAGER_ATTACHMENT)
+        {
+	  ch = -1;
+	  rc = OP_ATTACH_COLLAPSE;
+	  break;
+	}
+	CHECK_MODE(IsHeader (extra));
+	mutt_view_attachments (extra->hdr);
+	if (extra->hdr->attach_del)
+	  Context->changed = 1;
+	redraw = REDRAW_FULL;
+	break;
+
+
+      case OP_MAIL_KEY:
+        if (!(WithCrypto & APPLICATION_PGP))
+        {
+          ch = -1;
+          break;
+        }
+	CHECK_MODE(IsHeader(extra));
+        CHECK_ATTACH;
+	ci_send_message (SENDKEY, NULL, NULL, extra->ctx, extra->hdr);
+	redraw = REDRAW_FULL;
+	break;
+
+
+      case OP_FORGET_PASSPHRASE:
+	crypt_forget_passphrase ();
+	break;
+
+      case OP_EXTRACT_KEYS:
+        if (!WithCrypto)
+        {
+          ch = -1;
+          break;
+        }
+        CHECK_MODE(IsHeader(extra));
+	crypt_extract_keys_from_messages(extra->hdr);
+        redraw = REDRAW_FULL;
+        break;
+
+      case OP_WHAT_KEY:
+	mutt_what_key ();
+	break;
+
+      case OP_SIDEBAR_SCROLL_UP:
+      case OP_SIDEBAR_SCROLL_DOWN:
+      case OP_SIDEBAR_NEXT:
+      case OP_SIDEBAR_PREV:
+	scroll_sidebar(ch, MENU_PAGER);
+ 	break;
+
+      default:
+	ch = -1;
+	break;
+    }
+  }
+
+  safe_fclose (&fp);
+  if (IsHeader (extra))
+  {
+    Context->msgnotreadyet = -1;
+    if (rc == -1)
+      OldHdr = NULL;
+    else
+    {
+      TopLine = topline;
+      OldHdr = extra->hdr;
+    }
+  }
+    
+  cleanup_quote (&QuoteList);
+  
+  for (i = 0; i < maxLine ; i++)
+  {
+    FREE (&(lineInfo[i].syntax));
+    if (SearchCompiled && lineInfo[i].search)
+      FREE (&(lineInfo[i].search));
+  }
+  if (SearchCompiled)
+  {
+    regfree (&SearchRE);
+    SearchCompiled = 0;
+  }
+  FREE (&lineInfo);
+  if (index)
+    mutt_menuDestroy(&index);
+  return (rc != -1 ? rc : 0);
+}
diff -udprP mutt-1.5.21/parse.c mutt-nntp-sidebar/parse.c
--- mutt-1.5.21/parse.c	2009-08-25 12:08:52.000000000 -0700
+++ mutt-nntp-sidebar/parse.c	2011-06-03 07:05:58.939622665 -0700
@@ -89,7 +89,7 @@ char *mutt_read_rfc822_line (FILE *f, ch
   /* not reached */
 }
 
-static LIST *mutt_parse_references (char *s, int in_reply_to)
+LIST *mutt_parse_references (char *s, int in_reply_to)
 {
   LIST *t, *lst = NULL;
   char *m;
@@ -1067,6 +1067,17 @@ int mutt_parse_rfc822_line (ENVELOPE *e,
       e->from = rfc822_parse_adrlist (e->from, p);
       matched = 1;
     }
+#ifdef USE_NNTP
+    else if (!mutt_strcasecmp (line+1, "ollowup-to"))
+    {
+      if (!e->followup_to)
+      {
+	mutt_remove_trailing_ws (p);
+	e->followup_to = safe_strdup (mutt_skip_whitespace (p));
+      }
+      matched = 1;
+    }
+#endif
     break;
     
     case 'i':
@@ -1149,6 +1160,27 @@ int mutt_parse_rfc822_line (ENVELOPE *e,
     }
     break;
     
+#ifdef USE_NNTP
+    case 'n':
+    if (!mutt_strcasecmp (line + 1, "ewsgroups"))
+    {
+      FREE (&e->newsgroups);
+      mutt_remove_trailing_ws (p);
+      e->newsgroups = safe_strdup (mutt_skip_whitespace (p));
+      matched = 1;
+    }
+    break;
+#endif
+
+    case 'o':
+    /* field `Organization:' saves only for pager! */
+    if (!mutt_strcasecmp (line + 1, "rganization"))
+    {
+      if (!e->organization && mutt_strcasecmp (p, "unknown"))
+	e->organization = safe_strdup (p);
+    }
+    break;
+
     case 'r':
     if (!ascii_strcasecmp (line + 1, "eferences"))
     {
@@ -1257,6 +1289,20 @@ int mutt_parse_rfc822_line (ENVELOPE *e,
       e->x_label = safe_strdup(p);
       matched = 1;
     }
+#ifdef USE_NNTP
+    else if (!mutt_strcasecmp (line + 1, "-comment-to"))
+    {
+      if (!e->x_comment_to)
+	e->x_comment_to = safe_strdup (p);
+      matched = 1;
+    }
+    else if (!mutt_strcasecmp (line + 1, "ref"))
+    {
+      if (!e->xref)
+	e->xref = safe_strdup (p);
+      matched = 1;
+    }
+#endif
     
     default:
     break;
diff -udprP mutt-1.5.21/pattern.c mutt-nntp-sidebar/pattern.c
--- mutt-1.5.21/pattern.c	2010-08-24 09:34:21.000000000 -0700
+++ mutt-nntp-sidebar/pattern.c	2011-06-03 07:05:58.916289332 -0700
@@ -92,6 +92,9 @@ Flags[] =
   { 'U', M_UNREAD,		0,		NULL },
   { 'v', M_COLLAPSED,		0,		NULL },
   { 'V', M_CRYPT_VERIFIED,	0,		NULL },
+#ifdef USE_NNTP
+  { 'w', M_NEWSGROUPS,		0,		eat_regexp },
+#endif
   { 'x', M_REFERENCE,		0,		eat_regexp },
   { 'X', M_MIMEATTACH,		0,		eat_range },
   { 'y', M_XLABEL,		0,		eat_regexp },
@@ -1213,6 +1216,10 @@ mutt_pattern_exec (struct pattern_t *pat
       }
     case M_UNREFERENCED:
       return (pat->not ^ (h->thread && !h->thread->child));
+#ifdef USE_NNTP
+    case M_NEWSGROUPS:
+      return (pat->not ^ (h->env->newsgroups && patmatch (pat, h->env->newsgroups) == 0));
+#endif
   }
   mutt_error (_("error: unknown op %d (report this error)."), pat->op);
   return (-1);
@@ -1294,6 +1301,7 @@ int mutt_pattern_func (int op, char *pro
   progress_t progress;
 
   strfcpy (buf, NONULL (Context->pattern), sizeof (buf));
+  if (prompt || op != M_LIMIT)
   if (mutt_get_field (prompt, buf, sizeof (buf), M_PATTERN | M_CLEAR) != 0 || !buf[0])
     return (-1);
 
diff -udprP mutt-1.5.21/po/POTFILES.in mutt-nntp-sidebar/po/POTFILES.in
--- mutt-1.5.21/po/POTFILES.in	2008-03-19 13:07:57.000000000 -0700
+++ mutt-nntp-sidebar/po/POTFILES.in	2011-06-03 07:05:58.926289333 -0700
@@ -46,6 +46,8 @@ mutt_ssl_gnutls.c
 mutt_tunnel.c
 muttlib.c
 mx.c
+newsrc.c
+nntp.c
 pager.c
 parse.c
 pattern.c
diff -udprP mutt-1.5.21/postpone.c mutt-nntp-sidebar/postpone.c
--- mutt-1.5.21/postpone.c	2010-08-24 09:34:21.000000000 -0700
+++ mutt-nntp-sidebar/postpone.c	2011-06-03 07:05:58.929622666 -0700
@@ -125,15 +125,26 @@ int mutt_num_postponed (int force)
 
   if (LastModify < st.st_mtime)
   {
+#ifdef USE_NNTP
+    int optnews = option (OPTNEWS);
+#endif
     LastModify = st.st_mtime;
 
     if (access (Postponed, R_OK | F_OK) != 0)
       return (PostCount = 0);
+#ifdef USE_NNTP
+    if (optnews)
+	unset_option (OPTNEWS);
+#endif
     if (mx_open_mailbox (Postponed, M_NOSORT | M_QUIET, &ctx) == NULL)
       PostCount = 0;
     else
       PostCount = ctx.msgcount;
     mx_fastclose_mailbox (&ctx);
+#ifdef USE_NNTP
+    if (optnews)
+	set_option (OPTNEWS);
+#endif
   }
 
   return (PostCount);
diff -udprP mutt-1.5.21/protos.h mutt-nntp-sidebar/protos.h
--- mutt-1.5.21/protos.h	2010-08-24 09:34:21.000000000 -0700
+++ mutt-nntp-sidebar/protos.h	2011-06-03 07:05:58.939622665 -0700
@@ -110,6 +110,7 @@ HASH *mutt_make_id_hash (CONTEXT *);
 HASH *mutt_make_subj_hash (CONTEXT *);
 
 LIST *mutt_make_references(ENVELOPE *e);
+LIST *mutt_parse_references (char *, int);
 
 char *mutt_read_rfc822_line (FILE *, char *, size_t *);
 ENVELOPE *mutt_read_rfc822_header (FILE *, HEADER *, short, short);
diff -udprP mutt-1.5.21/recvattach.c mutt-nntp-sidebar/recvattach.c
--- mutt-1.5.21/recvattach.c	2010-09-13 10:19:55.000000000 -0700
+++ mutt-nntp-sidebar/recvattach.c	2011-06-03 07:05:58.942955998 -0700
@@ -1119,6 +1119,15 @@ void mutt_view_attachments (HEADER *hdr)
 	}
 #endif
 
+#ifdef USE_NNTP
+	if (Context->magic == M_NNTP)
+	{
+	  mutt_flushinp ();
+	  mutt_error _("Can't delete attachment from newsserver.");
+	  break;
+	}
+#endif
+
         if (WithCrypto && hdr->security & ~PGP_TRADITIONAL_CHECKED)
         {
 	  mutt_message _(
@@ -1210,10 +1219,33 @@ void mutt_view_attachments (HEADER *hdr)
       case OP_FORWARD_MESSAGE:
         CHECK_ATTACH;
         mutt_attach_forward (fp, hdr, idx, idxlen,
-			     menu->tagprefix ? NULL : idx[menu->current]->content);
+			     menu->tagprefix ? NULL : idx[menu->current]->content, 0);
         menu->redraw = REDRAW_FULL;
         break;
       
+#ifdef USE_NNTP
+      case OP_FORWARD_TO_GROUP:
+	CHECK_ATTACH;
+	mutt_attach_forward (fp, hdr, idx, idxlen,
+		menu->tagprefix ? NULL : idx[menu->current]->content, SENDNEWS);
+	menu->redraw = REDRAW_FULL;
+	break;
+
+      case OP_FOLLOWUP:
+	CHECK_ATTACH;
+
+	if (!idx[menu->current]->content->hdr->env->followup_to ||
+	    mutt_strcasecmp (idx[menu->current]->content->hdr->env->followup_to, "poster") ||
+	    query_quadoption (OPT_FOLLOWUPTOPOSTER,_("Reply by mail as poster prefers?")) != M_YES)
+	{
+	  mutt_attach_reply (fp, hdr, idx, idxlen,
+		menu->tagprefix ? NULL : idx[menu->current]->content,
+		SENDNEWS|SENDREPLY);
+	  menu->redraw = REDRAW_FULL;
+	  break;
+	}
+#endif
+
       case OP_REPLY:
       case OP_GROUP_REPLY:
       case OP_LIST_REPLY:
diff -udprP mutt-1.5.21/recvcmd.c mutt-nntp-sidebar/recvcmd.c
--- mutt-1.5.21/recvcmd.c	2010-09-13 10:19:55.000000000 -0700
+++ mutt-nntp-sidebar/recvcmd.c	2011-06-03 07:05:58.929622666 -0700
@@ -401,7 +401,7 @@ static BODY ** copy_problematic_attachme
 static void attach_forward_bodies (FILE * fp, HEADER * hdr,
 				   ATTACHPTR ** idx, short idxlen,
 				   BODY * cur,
-				   short nattach)
+				   short nattach, int flags)
 {
   short i;
   short mime_fwd_all = 0;
@@ -547,7 +547,7 @@ _("Can't decode all tagged attachments.
   tmpfp = NULL;
 
   /* now that we have the template, send it. */
-  ci_send_message (0, tmphdr, tmpbody, NULL, parent);
+  ci_send_message (flags, tmphdr, tmpbody, NULL, parent);
   return;
   
   bail:
@@ -574,7 +574,7 @@ _("Can't decode all tagged attachments.
  */
 
 static void attach_forward_msgs (FILE * fp, HEADER * hdr, 
-	       ATTACHPTR ** idx, short idxlen, BODY * cur)
+	       ATTACHPTR ** idx, short idxlen, BODY * cur, int flags)
 {
   HEADER *curhdr = NULL;
   HEADER *tmphdr;
@@ -679,23 +679,23 @@ static void attach_forward_msgs (FILE *
   else
     mutt_free_header (&tmphdr);
 
-  ci_send_message (0, tmphdr, *tmpbody ? tmpbody : NULL, 
+  ci_send_message (flags, tmphdr, *tmpbody ? tmpbody : NULL, 
 		   NULL, curhdr);
 
 }
 
 void mutt_attach_forward (FILE * fp, HEADER * hdr, 
-			  ATTACHPTR ** idx, short idxlen, BODY * cur)
+			  ATTACHPTR ** idx, short idxlen, BODY * cur, int flags)
 {
   short nattach;
   
 
   if (check_all_msg (idx, idxlen, cur, 0) == 0)
-    attach_forward_msgs (fp, hdr, idx, idxlen, cur);
+    attach_forward_msgs (fp, hdr, idx, idxlen, cur, flags);
   else
   {
     nattach = count_tagged (idx, idxlen);
-    attach_forward_bodies (fp, hdr, idx, idxlen, cur, nattach);
+    attach_forward_bodies (fp, hdr, idx, idxlen, cur, nattach, flags);
   }
 }
 
@@ -753,28 +753,40 @@ attach_reply_envelope_defaults (ENVELOPE
     return -1;
   }
 
-  if (parent)
+#ifdef USE_NNTP
+  if ((flags & SENDNEWS))
   {
-    if (mutt_fetch_recips (env, curenv, flags) == -1)
-      return -1;
+    /* in case followup set Newsgroups: with Followup-To: if it present */
+    if (!env->newsgroups && curenv &&
+	mutt_strcasecmp (curenv->followup_to, "poster"))
+      env->newsgroups = safe_strdup (curenv->followup_to);
   }
   else
+#endif
   {
-    for (i = 0; i < idxlen; i++)
+    if (parent)
     {
-      if (idx[i]->content->tagged
-	  && mutt_fetch_recips (env, idx[i]->content->hdr->env, flags) == -1)
+      if (mutt_fetch_recips (env, curenv, flags) == -1)
 	return -1;
     }
+    else
+    {
+      for (i = 0; i < idxlen; i++)
+      {
+	if (idx[i]->content->tagged
+	    && mutt_fetch_recips (env, idx[i]->content->hdr->env, flags) == -1)
+	  return -1;
+      }
+    }
+
+    if ((flags & SENDLISTREPLY) && !env->to)
+    {
+      mutt_error _("No mailing lists found!");
+      return (-1);
+    }
+
+    mutt_fix_reply_recipients (env);
   }
-  
-  if ((flags & SENDLISTREPLY) && !env->to)
-  {
-    mutt_error _("No mailing lists found!");
-    return (-1);
-  }
-  
-  mutt_fix_reply_recipients (env);
   mutt_make_misc_reply_headers (env, Context, curhdr, curenv);
 
   if (parent)
@@ -835,6 +847,13 @@ void mutt_attach_reply (FILE * fp, HEADE
   char prefix[SHORT_STRING];
   int rc;
   
+#ifdef USE_NNTP
+  if (flags & SENDNEWS)
+    set_option (OPTNEWSSEND);
+  else
+    unset_option (OPTNEWSSEND);
+#endif
+
   if (check_all_msg (idx, idxlen, cur, 0) == -1)
   {
     nattach = count_tagged (idx, idxlen);
diff -udprP mutt-1.5.21/rfc1524.c mutt-nntp-sidebar/rfc1524.c
--- mutt-1.5.21/rfc1524.c	2010-03-01 10:56:19.000000000 -0700
+++ mutt-nntp-sidebar/rfc1524.c	2011-06-03 07:05:58.912955998 -0700
@@ -570,13 +570,13 @@ int rfc1524_expand_filename (char *namet
  * safe_fopen().
  */
 
-int mutt_rename_file (char *oldfile, char *newfile)
+int _mutt_rename_file (char *oldfile, char *newfile, int overwrite)
 {
   FILE *ofp, *nfp;
 
   if (access (oldfile, F_OK) != 0)
     return 1;
-  if (access (newfile, F_OK) == 0)
+  if (!overwrite && access (newfile, F_OK) == 0)
     return 2;
   if ((ofp = fopen (oldfile,"r")) == NULL)
     return 3;
@@ -591,3 +591,8 @@ int mutt_rename_file (char *oldfile, cha
   mutt_unlink (oldfile);
   return 0;
 }
+
+int mutt_rename_file (char *oldfile, char *newfile)
+{
+  return _mutt_rename_file (oldfile, newfile, 0);
+}
diff -udprP mutt-1.5.21/rfc1524.h mutt-nntp-sidebar/rfc1524.h
--- mutt-1.5.21/rfc1524.h	2008-03-19 13:07:06.000000000 -0700
+++ mutt-nntp-sidebar/rfc1524.h	2011-06-03 07:05:58.916289332 -0700
@@ -40,5 +40,6 @@ int rfc1524_expand_command (BODY *, char
 int rfc1524_expand_filename (char *, char *, char *, size_t);
 int rfc1524_mailcap_lookup (BODY *, char *, rfc1524_entry *, int);
 int mutt_rename_file (char *, char *);
+int _mutt_rename_file (char *, char *, int);
 
 #endif /* _RFC1524_H */
diff -udprP mutt-1.5.21/send.c mutt-nntp-sidebar/send.c
--- mutt-1.5.21/send.c	2010-09-13 10:19:55.000000000 -0700
+++ mutt-nntp-sidebar/send.c	2011-06-03 07:05:58.939622665 -0700
@@ -44,6 +44,11 @@
 #include <sys/types.h>
 #include <utime.h>
 
+#ifdef USE_NNTP
+#include "nntp.h"
+#include "mx.h"
+#endif
+
 #ifdef MIXMASTER
 #include "remailer.h"
 #endif
@@ -213,17 +218,51 @@ static int edit_address (ADDRESS **a, /*
   return 0;
 }
 
-static int edit_envelope (ENVELOPE *en)
+static int edit_envelope (ENVELOPE *en, int flags)
 {
   char buf[HUGE_STRING];
   LIST *uh = UserHeader;
 
-  if (edit_address (&en->to, "To: ") == -1 || en->to == NULL)
-    return (-1);
-  if (option (OPTASKCC) && edit_address (&en->cc, "Cc: ") == -1)
-    return (-1);
-  if (option (OPTASKBCC) && edit_address (&en->bcc, "Bcc: ") == -1)
-    return (-1);
+#ifdef USE_NNTP
+  if (option (OPTNEWSSEND))
+  {
+    if (en->newsgroups)
+      strfcpy (buf, en->newsgroups, sizeof (buf));
+    else
+      buf[0] = 0;
+    if (mutt_get_field ("Newsgroups: ", buf, sizeof (buf), 0) != 0)
+      return (-1);
+    FREE (&en->newsgroups);
+    en->newsgroups = safe_strdup (buf);
+
+    if (en->followup_to)
+      strfcpy (buf, en->followup_to, sizeof (buf));
+    else
+      buf[0] = 0;
+    if (option (OPTASKFOLLOWUP) && mutt_get_field ("Followup-To: ", buf, sizeof (buf), 0) != 0)
+      return (-1);
+    FREE (&en->followup_to);
+    en->followup_to = safe_strdup (buf);
+
+    if (en->x_comment_to)
+      strfcpy (buf, en->x_comment_to, sizeof (buf));
+    else
+      buf[0] = 0;
+    if (option (OPTXCOMMENTTO) && option (OPTASKXCOMMENTTO) && mutt_get_field ("X-Comment-To: ", buf, sizeof (buf), 0) != 0)
+      return (-1);
+    FREE (&en->x_comment_to);
+    en->x_comment_to = safe_strdup (buf);
+  }
+  else
+#endif
+  {
+    if (edit_address (&en->to, "To: ") == -1 || en->to == NULL)
+      return (-1);
+    if (option (OPTASKCC) && edit_address (&en->cc, "Cc: ") == -1)
+      return (-1);
+    if (option (OPTASKBCC) && edit_address (&en->bcc, "Bcc: ") == -1)
+      return (-1);
+  }
 
   if (en->subject)
   {
@@ -259,6 +298,14 @@ static int edit_envelope (ENVELOPE *en)
   return 0;
 }
 
+#ifdef USE_NNTP
+char *nntp_get_header (const char *s)
+{
+  SKIPWS (s);
+  return safe_strdup (s);
+}
+#endif
+
 static void process_user_recips (ENVELOPE *env)
 {
   LIST *uh = UserHeader;
@@ -271,6 +318,14 @@ static void process_user_recips (ENVELOP
       env->cc = rfc822_parse_adrlist (env->cc, uh->data + 3);
     else if (ascii_strncasecmp ("bcc:", uh->data, 4) == 0)
       env->bcc = rfc822_parse_adrlist (env->bcc, uh->data + 4);
+#ifdef USE_NNTP
+    else if (ascii_strncasecmp ("newsgroups:", uh->data, 11) == 0)
+      env->newsgroups = nntp_get_header (uh->data + 11);
+    else if (ascii_strncasecmp ("followup-to:", uh->data, 12) == 0)
+      env->followup_to = nntp_get_header (uh->data + 12);
+    else if (ascii_strncasecmp ("x-comment-to:", uh->data, 13) == 0)
+      env->x_comment_to = nntp_get_header (uh->data + 13);
+#endif
   }
 }
 
@@ -309,6 +364,12 @@ static void process_user_header (ENVELOP
     else if (ascii_strncasecmp ("to:", uh->data, 3) != 0 &&
 	     ascii_strncasecmp ("cc:", uh->data, 3) != 0 &&
 	     ascii_strncasecmp ("bcc:", uh->data, 4) != 0 &&
+#ifdef USE_NNTP
+	     ascii_strncasecmp ("newsgroups:", uh->data, 11) != 0 &&
+	     ascii_strncasecmp ("followup-to:", uh->data, 12) != 0 &&
+	     ascii_strncasecmp ("x-comment-to:", uh->data, 13) != 0 &&
+#endif
+	     ascii_strncasecmp ("supersedes:", uh->data, 11) != 0 &&
 	     ascii_strncasecmp ("subject:", uh->data, 8) != 0 &&
 	     ascii_strncasecmp ("return-path:", uh->data, 12) != 0)
     {
@@ -657,6 +718,10 @@ void mutt_add_to_reference_headers (ENVE
   if (pp) *pp = p;
   if (qq) *qq = q;
   
+#ifdef USE_NNTP
+  if (option (OPTNEWSSEND) && option (OPTXCOMMENTTO) && curenv->from)
+    env->x_comment_to = safe_strdup (mutt_get_name (curenv->from));
+#endif
 }
 
 static void 
@@ -719,6 +784,16 @@ envelope_defaults (ENVELOPE *env, CONTEX
 
   if (flags & SENDREPLY)
   {
+#ifdef USE_NNTP
+    if ((flags & SENDNEWS))
+    {
+      /* in case followup set Newsgroups: with Followup-To: if it present */
+      if (!env->newsgroups && curenv &&
+	  mutt_strcasecmp (curenv->followup_to, "poster"))
+	env->newsgroups = safe_strdup (curenv->followup_to);
+    }
+    else
+#endif
     if (tag)
     {
       HEADER *h;
@@ -865,7 +940,18 @@ void mutt_set_followup_to (ENVELOPE *e)
    * it hasn't already been set
    */
 
-  if (option (OPTFOLLOWUPTO) && !e->mail_followup_to)
+  if (!option (OPTFOLLOWUPTO))
+    return;
+#ifdef USE_NNTP
+  if (option (OPTNEWSSEND))
+  {
+    if (!e->followup_to && e->newsgroups && (strrchr (e->newsgroups, ',')))
+      e->followup_to = safe_strdup (e->newsgroups);
+    return;
+  }
+#endif
+
+  if (!e->mail_followup_to)
   {
     if (mutt_is_list_cc (0, e->to, e->cc))
     {
@@ -1027,6 +1113,9 @@ static int send_message (HEADER *msg)
 #endif
 
 #if USE_SMTP
+#ifdef USE_NNTP
+  if (!option (OPTNEWSSEND))
+#endif /* USE_NNTP */
   if (SmtpUrl)
       return mutt_smtp_send (msg->env->from, msg->env->to, msg->env->cc,
                              msg->env->bcc, tempfile,
@@ -1138,6 +1227,13 @@ ci_send_message (int flags,		/* send mod
 
   int rv = -1;
   
+#ifdef USE_NNTP
+  if (flags & SENDNEWS)
+    set_option (OPTNEWSSEND);
+  else
+    unset_option (OPTNEWSSEND);
+#endif
+
   if (!flags && !msg && quadoption (OPT_RECALL) != M_NO &&
       mutt_num_postponed (1))
   {
@@ -1168,6 +1264,22 @@ ci_send_message (int flags,		/* send mod
     {
       if ((flags = mutt_get_postponed (ctx, msg, &cur, fcc, sizeof (fcc))) < 0)
 	goto cleanup;
+#ifdef USE_NNTP
+      /*
+       * If postponed message is a news article, it have
+       * a "Newsgroups:" header line, then set appropriate flag.
+       */
+      if (msg->env->newsgroups)
+      {
+	flags |= SENDNEWS;
+	set_option (OPTNEWSSEND);
+      }
+      else
+      {
+	flags &= ~SENDNEWS;
+	unset_option (OPTNEWSSEND);
+      }
+#endif
     }
 
     if (flags & (SENDPOSTPONED|SENDRESEND))
@@ -1262,11 +1374,16 @@ ci_send_message (int flags,		/* send mod
     if (flags & SENDREPLY)
       mutt_fix_reply_recipients (msg->env);
 
+#ifdef USE_NNTP
+    if ((flags & SENDNEWS) && ctx && ctx->magic == M_NNTP && !msg->env->newsgroups)
+      msg->env->newsgroups = safe_strdup (((NNTP_DATA *)ctx->data)->group);
+#endif
+
     if (! (flags & (SENDMAILX|SENDBATCH)) &&
 	! (option (OPTAUTOEDIT) && option (OPTEDITHDRS)) &&
 	! ((flags & SENDREPLY) && option (OPTFASTREPLY)))
     {
-      if (edit_envelope (msg->env) == -1)
+      if (edit_envelope (msg->env, flags) == -1)
 	goto cleanup;
     }
 
@@ -1534,6 +1651,11 @@ main_loop:
     if (i == -1)
     {
       /* abort */
+#ifdef USE_NNTP
+      if (flags & SENDNEWS)
+	mutt_message _("Article not posted.");
+      else
+#endif
       mutt_message _("Mail not sent.");
       goto cleanup;
     }
@@ -1566,6 +1688,9 @@ main_loop:
     }
   }
 
+#ifdef USE_NNTP
+  if (!(flags & SENDNEWS))
+#endif
   if (!has_recips (msg->env->to) && !has_recips (msg->env->cc) &&
       !has_recips (msg->env->bcc))
   {
@@ -1599,6 +1724,19 @@ main_loop:
       mutt_error _("No subject specified.");
     goto main_loop;
   }
+#ifdef USE_NNTP
+  if ((flags & SENDNEWS) && !msg->env->subject)
+  {
+    mutt_error _("No subject specified.");
+    goto main_loop;
+  }
+
+  if ((flags & SENDNEWS) && !msg->env->newsgroups)
+  {
+    mutt_error _("No newsgroup specified.");
+    goto main_loop;
+  }
+#endif
 
   if (msg->content->next)
     msg->content = mutt_make_multipart (msg->content);
@@ -1805,7 +1943,12 @@ full_fcc:
     }
   }
   else if (!option (OPTNOCURSES) && ! (flags & SENDMAILX))
-    mutt_message (i == 0 ? _("Mail sent.") : _("Sending in background."));
+    mutt_message (i != 0 ? _("Sending in background.") :
+#ifdef USE_NNTP
+		  (flags & SENDNEWS) ? _("Article posted.") : _("Mail sent."));
+#else
+		  _("Mail sent."));
+#endif
 
   if (WithCrypto && (msg->security & ENCRYPT))
     FREE (&pgpkeylist);
diff -udprP mutt-1.5.21/sendlib.c mutt-nntp-sidebar/sendlib.c
--- mutt-1.5.21/sendlib.c	2010-09-13 10:19:55.000000000 -0700
+++ mutt-nntp-sidebar/sendlib.c	2011-06-03 07:05:58.939622665 -0700
@@ -46,6 +46,10 @@
 #include <sys/wait.h>
 #include <fcntl.h>
 
+#ifdef USE_NNTP
+#include "nntp.h"
+#endif
+
 #ifdef HAVE_SYSEXITS_H
 #include <sysexits.h>
 #else /* Make sure EX_OK is defined <philiph@pobox.com> */
@@ -1543,6 +1547,14 @@ void mutt_write_references (LIST *r, FIL
 {
   LIST **ref = NULL;
   int refcnt = 0, refmax = 0;
+  int multiline = 1;
+  int space = 0;
+
+  if (trim < 0)
+  {
+    trim = -trim;
+    multiline = 0;
+  }
 
   for ( ; (trim == 0 || refcnt < trim) && r ; r = r->next)
   {
@@ -1553,9 +1565,11 @@ void mutt_write_references (LIST *r, FIL
 
   while (refcnt-- > 0)
   {
-    fputc (' ', f);
+    if (multiline || space)
+      fputc (' ', f);
+    space = 1;
     fputs (ref[refcnt]->data, f);
-    if (refcnt >= 1)
+    if (multiline && refcnt >= 1)
       fputc ('\n', f);
   }
 
@@ -1962,6 +1976,9 @@ int mutt_write_rfc822_header (FILE *fp,
     mutt_write_address_list (env->to, fp, 4, 0);
   }
   else if (mode > 0)
+#ifdef USE_NNTP
+  if (!option (OPTNEWSSEND))
+#endif
     fputs ("To: \n", fp);
 
   if (env->cc)
@@ -1970,6 +1987,9 @@ int mutt_write_rfc822_header (FILE *fp,
     mutt_write_address_list (env->cc, fp, 4, 0);
   }
   else if (mode > 0)
+#ifdef USE_NNTP
+  if (!option (OPTNEWSSEND))
+#endif
     fputs ("Cc: \n", fp);
 
   if (env->bcc)
@@ -1981,8 +2001,28 @@ int mutt_write_rfc822_header (FILE *fp,
     }
   }
   else if (mode > 0)
+#ifdef USE_NNTP
+  if (!option (OPTNEWSSEND))
+#endif
     fputs ("Bcc: \n", fp);
 
+#ifdef USE_NNTP
+  if (env->newsgroups)
+    fprintf (fp, "Newsgroups: %s\n", env->newsgroups);
+  else if (mode == 1 && option (OPTNEWSSEND))
+    fputs ("Newsgroups: \n", fp);
+
+  if (env->followup_to)
+    fprintf (fp, "Followup-To: %s\n", env->followup_to);
+  else if (mode == 1 && option (OPTNEWSSEND))
+    fputs ("Followup-To: \n", fp);
+
+  if (env->x_comment_to)
+    fprintf (fp, "X-Comment-To: %s\n", env->x_comment_to);
+  else if (mode == 1 && option (OPTNEWSSEND) && option (OPTXCOMMENTTO))
+    fputs ("X-Comment-To: \n", fp);
+#endif
+
   if (env->subject)
     mutt_write_one_header (fp, "Subject", env->subject, NULL, 0, 0);
   else if (mode == 1)
@@ -2001,6 +2041,9 @@ int mutt_write_rfc822_header (FILE *fp,
     fputs ("Reply-To: \n", fp);
 
   if (env->mail_followup_to)
+#ifdef USE_NNTP
+  if (!option (OPTNEWSSEND))
+#endif
   {
     fputs ("Mail-Followup-To: ", fp);
     mutt_write_address_list (env->mail_followup_to, fp, 18, 0);
@@ -2339,11 +2382,30 @@ mutt_invoke_sendmail (ADDRESS *from,	/*
 		 const char *msg, /* file containing message */
 		 int eightbit) /* message contains 8bit chars */
 {
-  char *ps = NULL, *path = NULL, *s = safe_strdup (Sendmail), *childout = NULL;
+  char *ps = NULL, *path = NULL, *s = NULL, *childout = NULL;
   char **args = NULL;
   size_t argslen = 0, argsmax = 0;
   int i;
 
+#ifdef USE_NNTP
+  if (option (OPTNEWSSEND))
+  {
+    char cmd[LONG_STRING];
+
+    mutt_FormatString (cmd, sizeof (cmd), 0, NONULL (Inews), nntp_format_str, 0, 0);
+    if (!*cmd)
+    {
+      i = nntp_post (msg);
+      unlink (msg);
+      return i;
+    }
+
+    s = safe_strdup (cmd);
+  }
+  else
+#endif
+    s = safe_strdup (Sendmail);
+
   ps = s;
   i = 0;
   while ((ps = strtok (ps, " ")))
@@ -2367,6 +2429,10 @@ mutt_invoke_sendmail (ADDRESS *from,	/*
     i++;
   }
 
+#ifdef USE_NNTP
+  if (!option (OPTNEWSSEND))
+  {
+#endif
   if (eightbit && option (OPTUSE8BITMIME))
     args = add_option (args, &argslen, &argsmax, "-B8BITMIME");
 
@@ -2398,6 +2464,9 @@ mutt_invoke_sendmail (ADDRESS *from,	/*
   args = add_args (args, &argslen, &argsmax, to);
   args = add_args (args, &argslen, &argsmax, cc);
   args = add_args (args, &argslen, &argsmax, bcc);
+#ifdef USE_NNTP
+  }
+#endif
 
   if (argslen == argsmax)
     safe_realloc (&args, sizeof (char *) * (++argsmax));
@@ -2478,6 +2547,9 @@ void mutt_prepare_envelope (ENVELOPE *en
   rfc2047_encode_string (&env->x_label);
 
   if (env->subject)
+#ifdef USE_NNTP
+  if (!option (OPTNEWSSEND) || option (OPTMIMESUBJECT))
+#endif
   {
     rfc2047_encode_string (&env->subject);
   }
@@ -2598,6 +2670,10 @@ int mutt_bounce_message (FILE *fp, HEADE
   }
   rfc822_write_address (resent_from, sizeof (resent_from), from, 0);
 
+#ifdef USE_NNTP
+  unset_option (OPTNEWSSEND);
+#endif
+
   ret = _mutt_bounce_message (fp, h, to, resent_from, from);
 
   rfc822_free_address (&from);
diff -udprP mutt-1.5.21/sort.c mutt-nntp-sidebar/sort.c
--- mutt-1.5.21/sort.c	2008-10-28 15:29:44.000000000 -0700
+++ mutt-nntp-sidebar/sort.c	2011-06-03 07:05:58.909622665 -0700
@@ -151,6 +151,15 @@ static int compare_order (const void *a,
   HEADER **ha = (HEADER **) a;
   HEADER **hb = (HEADER **) b;
 
+#ifdef USE_NNTP
+  if ((*ha)->article_num && (*hb)->article_num)
+  {
+    int result = (*ha)->article_num - (*hb)->article_num;
+    AUXSORT(result,a,b);
+    return (SORTCODE (result));
+  }
+  else
+#endif
   /* no need to auxsort because you will never have equality here */
   return (SORTCODE ((*ha)->index - (*hb)->index));
 }
diff -udprP mutt-1.5.21/url.c mutt-nntp-sidebar/url.c
--- mutt-1.5.21/url.c	2010-08-24 09:34:21.000000000 -0700
+++ mutt-nntp-sidebar/url.c	2011-06-03 07:05:58.909622665 -0700
@@ -39,6 +39,8 @@ static struct mapping_t UrlMap[] =
   { "imaps", 	U_IMAPS },
   { "pop",  	U_POP },
   { "pops", 	U_POPS },
+  { "news",	U_NNTP },
+  { "newss",	U_NNTPS },
   { "mailto",	U_MAILTO },
   { "smtp",     U_SMTP },
   { "smtps",    U_SMTPS },
diff -udprP mutt-1.5.21/url.h mutt-nntp-sidebar/url.h
--- mutt-1.5.21/url.h	2009-08-25 12:08:52.000000000 -0700
+++ mutt-nntp-sidebar/url.h	2011-06-03 07:05:58.909622665 -0700
@@ -8,6 +8,8 @@ typedef enum url_scheme
   U_POPS,
   U_IMAP,
   U_IMAPS,
+  U_NNTP,
+  U_NNTPS,
   U_SMTP,
   U_SMTPS,
   U_MAILTO,
